/* Generated by Together */

#include "DataObject.h"
#include "COMUtils.h"
#include "MemoryStream.h"

using namespace ImprovCOM;
using namespace ImprovUI;


DataRendering::DataRendering( FORMATETC * formatETC, STGMEDIUM * stgMedium, IUnknown* newStorageOwner ):
	Object()
{
	this->m_formatETC = *formatETC;
	this->m_storage = *stgMedium;
	this->m_owner = stgMedium->pUnkForRelease;
	this->m_storage.pUnkForRelease = newStorageOwner;
}

DataRendering::~DataRendering()
{	
	if ( NULL != m_owner ){
		m_owner->Release();
		m_owner = NULL;	
	}
}

DataObject::DataObject():
	COMObject()
{

}

DataObject::~DataObject()
{
	clearRenderings();
}

bool DataObject::supportsInterface( REFIID riid, void** object )
{
	bool result = 0 != (IID_IDataObject == riid);
	if ( true == result ){
		*object = (IDataObject*)(COMObject*)this;
	}
	return 	result;
}

void DataObject::clearRenderings()
{
	for ( std::vector<DataRendering*>::iterator it = m_renderings.begin(); it != m_renderings.end(); it++ ){
		delete *it;
	}
}

STDMETHODIMP DataObject::GetData( FORMATETC * formatETC, STGMEDIUM * stgMedium )
{
	HRESULT result = E_NOTIMPL;

	std::cout << "DataObject::GetData" << std::endl;

	if ( (NULL == formatETC) || (NULL == stgMedium) ){
		result = ResultFromScode(DATA_E_FORMATETC);
	}
	else{
		result = ResultFromScode(DATA_E_FORMATETC);

		DataRendering* dataRender = findDataRenderingForType( formatETC );

		if ( NULL != dataRender ){
			if ( TYMED_ISTORAGE == dataRender->m_formatETC.tymed ){
				dataRender->m_storage.pstg->AddRef();
			}
			if ( TYMED_ISTREAM == dataRender->m_formatETC.tymed){
				dataRender->m_storage.pstm->AddRef();
			}
			
			*stgMedium = dataRender->m_storage;
			AddRef();
			result = S_OK;
		}
	}

	return result;
}

STDMETHODIMP DataObject::GetDataHere( FORMATETC * formatETC, STGMEDIUM * stgMedium )
{
#ifdef _DEBUG
	std::cout << "DataObject::GetDataHere" << std::endl;
#endif
	return E_NOTIMPL;
}

STDMETHODIMP DataObject::QueryGetData( FORMATETC * formatETC )
{
	HRESULT result = E_NOTIMPL;
#ifdef _DEBUG	
	std::cout << ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\nDataObject::QueryGetData" << std::endl;
#endif
	if ( NULL==formatETC ){
		#ifdef _DEBUG	
		std::cout << "DataObject::QueryGetData  NULL==formatETC" << std::endl;
		#endif
        return ResultFromScode(DATA_E_FORMATETC);
	}
	
	if ( NULL != findDataRenderingForType( formatETC ) ){
		#ifdef _DEBUG	
		std::cout << "DataObject::QueryGetData found supported data type" << std::endl;
		#endif

		result = S_OK;//NOERROR;		
	}
	else {
		#ifdef _DEBUG	
		std::cout << "DataObject::QueryGetData didn't find supported data type" << std::endl;
		#endif
	}
	#ifdef _DEBUG	
	std::cout << ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n" << std::endl;
	#endif
	return result;
}

STDMETHODIMP DataObject::GetCanonicalFormatEtc( FORMATETC * formatETCIn, FORMATETC * formatETCOut )
{
#ifdef _DEBUG
	std::cout << "DataObject::GetCanonicalFormatEtc" << std::endl;
#endif

	return ResultFromScode(DATA_S_SAMEFORMATETC);
}

/**
* if the releaseData is false we cannot go on - Our data objects need to release the data.
*This may change in future releases.
*if the FormatETC or stgMedium passed in are NULL we should also quit - can't do anything
*otherwise we do the following:
*	1.) Create a data Rendering and add it to the vector m_renderings.
*	2.) 
*/
STDMETHODIMP DataObject::SetData( FORMATETC * formatETC, STGMEDIUM * stgMedium, BOOL releaseData )
{
	HRESULT result = E_NOTIMPL;
	//m_clipboardDataObject
	if ( false  == releaseData ){
        result = ResultFromScode(E_FAIL);
	}
	else if ( (NULL==formatETC) || (NULL==stgMedium) ){
		//clean out the clipboard data
		result = ResultFromScode(E_FAIL);
	}
	else {
		DataRendering* rendering = new DataRendering( formatETC,  stgMedium, AS_IUNKNOWN(this) );
		m_renderings.push_back( rendering );
		result = S_OK;
	}

	return result;
}

STDMETHODIMP DataObject::EnumFormatEtc( DWORD dwDirection, IEnumFORMATETC ** ppenumFormatetc )
{
#ifdef _DEBUG
	std::cout << "DataObject::EnumFormatEtc" << std::endl;
#endif

	HRESULT result = ResultFromScode(E_FAIL);
	*ppenumFormatetc = NULL;
	EnumFormatETC* enumObj = NULL;
	switch ( dwDirection ){
		case DATADIR_GET:{
             enumObj = new EnumFormatETC();
		}
        break;
	
        case DATADIR_SET:
        default:{
            enumObj = NULL;
		}
        break;
    }
	
	if ( NULL == enumObj ){
        result = ResultFromScode(E_FAIL);
	}
    else{
        //Let the enumerator copy our format list.
		for ( std::vector<DataRendering*>::iterator it = m_renderings.begin(); it != m_renderings.end(); it++ ){
			DataRendering* render = *it;
			enumObj->add( render->m_formatETC );
		}
		enumObj->Reset();
		enumObj->AddRef();
    }

    *ppenumFormatetc = (IEnumFORMATETC*)(COMObject*)enumObj;

	return result;
}

STDMETHODIMP DataObject::DAdvise( FORMATETC * formatETC, DWORD advf, IAdviseSink * pAdvSink,  DWORD * pdwConnection )
{
	return E_NOTIMPL;
}

STDMETHODIMP DataObject::DUnadvise( DWORD dwConnection )
{
	return OLE_E_ADVISENOTSUPPORTED ;
}

STDMETHODIMP DataObject::EnumDAdvise( IEnumSTATDATA ** ppenumAdvise )
{
	return OLE_E_ADVISENOTSUPPORTED;
}
 
bool DataObject::isTypeSupported(const unsigned long & dataType)
{
	return true;
}

void DataObject::addSupportedData( const unsigned long & dataType, ClipboardDataObject* data )
{
	this->m_dataMap[dataType] = data;
	MemoryStream memStream;
	//Write the data to the mem stream
	memStream.write( data );
	
	STGMEDIUM stgMedium = {0};
	FORMATETC fmtETC = translateFrameworkFormatToFormatETC( dataType );
	stgMedium.tymed = fmtETC.tymed;
	stgMedium.pUnkForRelease = AS_IUNKNOWN(this);
	stgMedium.hGlobal = ::GlobalAlloc( GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_SHARE, memStream.getSize() );
	
	

	if ( 0 != stgMedium.hGlobal ){
		char* globalMemPtr = (char*)::GlobalLock( stgMedium.hGlobal );
		if ( NULL != globalMemPtr ){
			memStream.read( globalMemPtr, memStream.getSize() );
		}				

		if ( S_OK != SetData( &fmtETC, &stgMedium, true ) ){
			//throw exception ?			
		}
	}	
}

ClipboardDataObject* DataObject::getSupportedData( const unsigned long & dataType )
{	
	ClipboardDataObject* result = NULL;
	std::map<unsigned long,ClipboardDataObject*>::iterator found = m_dataMap.find( dataType );
	
	if ( found != m_dataMap.end() ){	
		result = found->second;
	}
	return result;
}

static long _findDataRenderingForTypeCallCount = 0;

DataRendering* DataObject::findDataRenderingForType( FORMATETC* formatETC )
{
	DataRendering* result = NULL;
	bool found = false;
	_findDataRenderingForTypeCallCount++;
	if ( NULL != formatETC ){

#ifdef _DEBUG
		std::cout << "searching for " << translateClipboardFmt( formatETC->cfFormat ) << std::endl;
		std::cout << "called " << _findDataRenderingForTypeCallCount << " times" << std::endl;
#endif

		for ( std::vector<DataRendering*>::iterator it = m_renderings.begin(); it != m_renderings.end(); it++ ){
			DataRendering* dataRender = *it;

			found = (dataRender->m_formatETC.cfFormat == formatETC->cfFormat);//(*dataRender == (*formatETC));
			std::cout << dataRender->toString() << std::endl;
			if ( true == found ){
				result = dataRender;				
				break;
			}
		}
	}
	return result;
}

UINT DataObject::translateFrameworkFormat( const unsigned long& dataType )
{
	UINT result = 0;
	switch ( dataType ){
		case STRING_DATA_TYPE:{
			result = CF_TEXT;
		}
		break;

		case FILE_DATA_TYPE:{
			result = CF_HDROP;
		}
		break;

		case IMAGE_DATA_TYPE:{
			result = CF_BITMAP;
		}
		break;
	}
	return result;
}

FORMATETC DataObject::translateFrameworkFormatToFormatETC( const unsigned long& dataType )
{
	FORMATETC result = {0};
	result.cfFormat = translateFrameworkFormat( dataType );

	COMUtils::makeDefaultFormatETC( result.cfFormat, &result ); 

	return result;
}

ImprovUI::String DataObject::translateClipboardFmt( const UINT& fmtType )
{
	String result = "";
	switch ( fmtType ){
		case CF_BITMAP:{
			result += "CF_BITMAP";		
		}
		break;
		
		case CF_DIB:{
			result += "CF_DIB";		
		}
		break;

		case CF_DIF:{
			result += "CF_DIF";		
		}
		break;

		case CF_HDROP:{
			result += "CF_HDROP";		
		}
		break;

		case CF_METAFILEPICT:{
			result += "CF_METAFILEPICT";		
		}
		break;

		case CF_OEMTEXT:{
			result += "CF_OEMTEXT";		
		}
		break;

		case CF_TEXT:{
			result += "CF_TEXT";		
		}
		break;
		
		case CF_WAVE:{
			result += "CF_WAVE";		
		}
		break;
		
		case CF_TIFF:{
			result += "CF_TIFF";		
		}
		break;

		default:{
			char s[256];
			sprintf( s, " %d", fmtType );
			result = s;
		};
		break;
	};		
	return result;
};
}