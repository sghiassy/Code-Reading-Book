/* Generated by Together */
#include "ApplicationKit.h"
#include "COMUtils.h"
#include <atlbase.h>
#include <comdef.h>
#include <shlobj.h>

#define IT_FAILURE				1
#define IT_SUCCESS				0
#define IT_OUT_OF_MEMORY		2

using namespace VCFCOM;
using namespace VCF;

void COMUtils::isEqualIID(){}
void COMUtils::isEqualCLSID(){}
void COMUtils::isEqualGUID(){}
void COMUtils::createGUID(){}

HRESULT COMUtils::createCOMObject( const std::string& progID, IID interfaceID,
		                             void** object )
{
	HRESULT result = IT_FAILURE;
	
	HRESULT comResult =0;

	CLSID clsid;

	USES_CONVERSION;
	
	LPOLESTR tmpProgID = A2OLE( progID.c_str() );
	comResult = CLSIDFromProgID( tmpProgID, &clsid );

	if ( SUCCEEDED(comResult) ){
		result = createCOMObject( clsid, interfaceID, object );
	}
	
	return result;
}

HRESULT COMUtils::createCOMObject( CLSID clsid, IID interfaceID,
		                             void** object )
{
	HRESULT result = IT_FAILURE;
	
	HRESULT comResult = 0;

	IUnknown* pIUnknown = NULL;

	comResult = CoCreateInstance( clsid, 0, CLSCTX_INPROC_SERVER, IID_IUnknown, 
		                          (void**) &pIUnknown );
	
	if ( (SUCCEEDED(comResult)) && (NULL != pIUnknown) ){
		comResult = pIUnknown->QueryInterface( interfaceID, object );
		if ( (SUCCEEDED(comResult)) && (NULL != object) ){
			result = IT_SUCCESS;
		}
		
		pIUnknown->Release();

	}	
	return result;

}

HRESULT COMUtils::BSTRtoString( const BSTR src, std::string& dest )
{
	HRESULT result = IT_FAILURE;
	USES_CONVERSION;
	_bstr_t tmp( src );
	std::string tmpString( tmp );
	dest = tmpString;
	result = IT_SUCCESS;
	return result;
}

HRESULT COMUtils::UUIDtoString( const UUID id, std::string& dest )
{
	HRESULT result = IT_FAILURE;
	
	unsigned char *tmpid = NULL;

	RPC_STATUS rpcresult = UuidToString( const_cast<UUID*>( &id ), &tmpid );

	if ( RPC_S_OUT_OF_MEMORY == rpcresult ) {
		result = IT_OUT_OF_MEMORY;
	} 
	else {
		dest = "";
		dest = std::string( (char *)tmpid );

		RpcStringFree( &tmpid );

		result = IT_SUCCESS;
	}

	return result;
}

HRESULT COMUtils::StringtoUUID( const std::string& src, UUID& destID )
{
	HRESULT result = IT_FAILURE;	
	//the (unsigned char*) cast below might be a bad idea ????
	unsigned char *tmpid = (unsigned char*) const_cast<char*>( src.c_str() );
	UUID tmpUUID;

	RPC_STATUS rpcresult = UuidFromString ( tmpid, &tmpUUID );

	if ( RPC_S_OUT_OF_MEMORY == rpcresult ) {
		result = IT_OUT_OF_MEMORY;
	} 
	else {
		destID = tmpUUID;

		//RpcStringFree( &tmpid );

		result = IT_SUCCESS;
	}

	return result;	
}

HRESULT COMUtils::makeDefaultFormatETC( const CLIPFORMAT& clipboardFormat, FORMATETC* formatETC )
{
	HRESULT result = IT_FAILURE;	
	
	if ( NULL != formatETC ){
		formatETC->cfFormat = clipboardFormat;
		formatETC->dwAspect = DVASPECT_CONTENT;
		formatETC->lindex = -1;
		formatETC->ptd = NULL;
		formatETC->tymed = TYMED_HGLOBAL;
		result = IT_SUCCESS;	
	}	

	return result;	
}

HRESULT COMUtils::getPidlsFromHGlobal(const HGLOBAL HGlob, std::vector<std::string>& fileNames  )
{
	LPIDA pCIDA = NULL;
	HRESULT result = IT_FAILURE;

	pCIDA = LPIDA(GlobalLock(HGlob));

	fileNames.clear();

	int count = pCIDA->cidl;
	for (int i=0;i < count; i++){
		 // [0]: folder IDList, [1] to [cidl]: item IDList
		LPCITEMIDLIST pidlf = NULL;
		pidlf = (LPCITEMIDLIST)( ((UINT)pCIDA) + pCIDA->aoffset[0]);

		char pathf[MAX_PATH] = "";
		SHGetPathFromIDList(pidlf, pathf);
		
		std::string fixedPath( pathf );		

		LPCITEMIDLIST pidl = NULL;
		pidl = (LPCITEMIDLIST)( ((UINT)pCIDA) + pCIDA->aoffset[i+1]);

		char path[MAX_PATH] = "";
		SHGetPathFromIDList(pidl, path);
		std::string pidlPath( path );
		int pos = pidlPath.find_last_of( "\\"); 
		if ( pos != 0 ){
			int strLength = pidlPath.length();
			strLength -= pos;
			std::string subStr = pidlPath.substr( pos, strLength );
			if ( (subStr != "") && (subStr.length() > 0) ){
				fixedPath += subStr;				
				fileNames.push_back( fixedPath );
				//dropFiles.AddHead( fixedPath.c_str() );
				result = IT_SUCCESS;
			}
		}			
	}
	GlobalUnlock(HGlob);
	
	return result;
}

HRESULT COMUtils::StringtoBSTR( const std::string& src, BSTR& dest )
{
	HRESULT result = IT_FAILURE;

	_bstr_t tmp( src.c_str() );
	dest = tmp.copy();

	result = IT_SUCCESS;
	return result;
}

HRESULT COMUtils::invokeDispatchMethod( IUnknown* invokingObject, const std::string& methodName,
		                                  DISPPARAMS& dispatchParams, VARIANTARG* methodResults )
{
	HRESULT result = E_FAIL;
	
	if ( NULL != invokingObject ) {
		IDispatch * dispatchInterface = NULL;

		result = invokingObject->QueryInterface( IID_IDispatch, (void **) &dispatchInterface);
		if ( SUCCEEDED(result) ) {
			DISPID dispatchID = 0;
			USES_CONVERSION; 
			//represents the name of the dispach method we want to call
			LPOLESTR tmpMethodName = A2OLE( methodName.c_str() ); 
			
			//retreive the id of the dispatch method
			result = dispatchInterface->GetIDsOfNames( IID_NULL, &tmpMethodName, 1, 
				                                    LOCALE_USER_DEFAULT, &dispatchID );
			if ( SUCCEEDED (result) ) {
				//initialize the variant arguments and results and then store them in a 
				//DISPPARAMS stucture to pass to the invoke() method

				if ( NULL != methodResults ){
					VariantInit( methodResults);
				}
				
				//invoke the method on the dispatch interface
				result = dispatchInterface->Invoke( dispatchID, IID_NULL, 
					                                LOCALE_USER_DEFAULT, DISPATCH_METHOD, 
													&dispatchParams, methodResults, 0, 0);				
				
			}

			dispatchInterface->Release();
		}		
	}
	return result;
}


DWORD COMUtils::translateActionType( const VCF::DragActionType& action )
{
	DWORD result = 0;
	switch ( action ){
		case DRAG_ACTION_COPY:{
			result = DROPEFFECT_COPY;	
		}
		break;
		
		case DRAG_ACTION_MOVE:{
			result = DROPEFFECT_MOVE;	
		}
		break;

		case DRAG_ACTION_LINK:{
			result = DROPEFFECT_LINK;	
		}
		break;
	};

	return result;
}

UINT COMUtils::translateFrameworkFormat( const unsigned long& dataType )
{
	UINT result = 0;
	switch ( dataType ){
		case STRING_DATA_TYPE:{
			result = CF_TEXT;
		}
		break;

		case FILE_DATA_TYPE:{
			result = CF_HDROP;
		}
		break;

		case IMAGE_DATA_TYPE:{
			result = CF_BITMAP;
		}
		break;
	}
	return result;
}

unsigned long COMUtils::translateWin32ClipboardFormat( const UINT& clipboardFormat )
{
	unsigned long result = 0;
	
	switch ( clipboardFormat ){
		case CF_TEXT:{
			result = STRING_DATA_TYPE;
		}
		break;

		case CF_HDROP:{
			result = FILE_DATA_TYPE;
		}
		break;

		case CF_BITMAP:{
			result = IMAGE_DATA_TYPE;
		}
		break;
	}
	return result;
}