/* Generated by Together */
#include "ApplicationKit.h"
#include "COMObject.h"
#include "EnumObject.h"
#include "MemoryStream.h"
#include "COMDataObject.h"
#include "COMUtils.h"

using namespace VCFCOM;
using namespace VCF;


DataRendering::DataRendering( FORMATETC * formatETC, STGMEDIUM * stgMedium, IUnknown* newStorageOwner ):
	Object()
{
	this->m_formatETC = *formatETC;
	this->m_storage = *stgMedium;
	this->m_owner = stgMedium->pUnkForRelease;
	this->m_storage.pUnkForRelease = newStorageOwner;
}

DataRendering::~DataRendering()
{	
	if ( NULL != m_owner ){
		m_owner->Release();
		m_owner = NULL;	
	}
}

VCF::String DataRendering::toString()
{
	VCF::String result;
	//result = format( "DataRendering @ %p \n", this );
	switch ( m_formatETC.cfFormat ){
	case CF_BITMAP:{
		result += "m_formatETC.cfFormat = CF_BITMAP";		
				   }
		break;
		
	case CF_DIB:{
		result += "m_formatETC.cfFormat = CF_DIB";		
				}
		break;
		
	case CF_DIF:{
		result += "m_formatETC.cfFormat = CF_DIF";		
				}
		break;
		
	case CF_HDROP:{
		result += "m_formatETC.cfFormat = CF_HDROP";		
				  }
		break;
		
	case CF_METAFILEPICT:{
		result += "m_formatETC.cfFormat = CF_METAFILEPICT";		
						 }
		break;
		
	case CF_OEMTEXT:{
		result += "m_formatETC.cfFormat = CF_OEMTEXT";		
					}
		break;
		
	case CF_TEXT:{
		result += "m_formatETC.cfFormat = CF_TEXT";		
				 }
		break;
		
	case CF_WAVE:{
		result += "m_formatETC.cfFormat = CF_WAVE";		
				 }
		break;
		
	case CF_TIFF:{
		result += "m_formatETC.cfFormat = CF_TIFF";		
				 }
		break;
	};		
	return result;
}

/**
*COMDataObject
*/

COMDataObject::COMDataObject( IDataObject* outerDataObject ):
	COMObject()
{
	this->m_outerDataObject = outerDataObject;
}

COMDataObject::~COMDataObject()
{
	clearRenderings();
}

STDMETHODIMP_(ULONG) COMDataObject::AddRef(void)
{
	if ( NULL != this->m_outerDataObject ){
		m_outerDataObject->AddRef();
	}

	return COMObject::AddRef();
}

STDMETHODIMP_(ULONG) COMDataObject::Release(void)
{
	if ( NULL != this->m_outerDataObject ){
		m_outerDataObject->Release();
	}

	return COMObject::Release();
}

bool COMDataObject::supportsInterface( REFIID riid, void** object )
{
	bool result = 0 != (IID_IDataObject == riid);
	if ( true == result ){
		*object = (IDataObject*)(COMObject*)this;
	}
	return 	result;
}

void COMDataObject::clearRenderings()
{
	for ( std::vector<DataRendering*>::iterator it = m_renderings.begin(); it != m_renderings.end(); it++ ){
		delete *it;
	}
	m_renderings.clear();
}

STDMETHODIMP COMDataObject::GetData( FORMATETC * formatETC, STGMEDIUM * stgMedium )
{
	HRESULT result = E_NOTIMPL;

	StringUtils::trace( "COMDataObject::GetData\n" );
	
	if ( NULL != this->m_outerDataObject ){
		result = m_outerDataObject->GetData( formatETC, stgMedium );
	}
	else {
		if ( (NULL == formatETC) || (NULL == stgMedium) ){
			result = ResultFromScode(DATA_E_FORMATETC);
		}
		else{
			result = ResultFromScode(DATA_E_FORMATETC);
			
			DataRendering* dataRender = findDataRenderingForType( formatETC );
			
			if ( NULL != dataRender ){
				if ( TYMED_ISTORAGE == dataRender->m_formatETC.tymed ){
					dataRender->m_storage.pstg->AddRef();
				}
				if ( TYMED_ISTREAM == dataRender->m_formatETC.tymed){
					dataRender->m_storage.pstm->AddRef();
				}
				
				*stgMedium = dataRender->m_storage;
				AddRef();
				result = S_OK;
			}
		}
	}
	return result;
}

STDMETHODIMP COMDataObject::GetDataHere( FORMATETC * formatETC, STGMEDIUM * stgMedium )
{
	HRESULT result = E_NOTIMPL;
#ifdef _DEBUG
	StringUtils::trace( "COMDataObject::GetDataHere\n" );
#endif
	if ( NULL != this->m_outerDataObject ){
		result = m_outerDataObject->GetDataHere( formatETC, stgMedium );
	}
	return result;
}

STDMETHODIMP COMDataObject::QueryGetData( FORMATETC * formatETC )
{
	HRESULT result = E_NOTIMPL;
#ifdef _DEBUG	
	StringUtils::trace( ">>>>>>>>>>>>>>\nCOMDataObject::QueryGetData<<<<<<<<<<<<<<<<<<<<<<\n" );
#endif
	if ( NULL==formatETC ){
		#ifdef _DEBUG	
		StringUtils::trace( "COMDataObject::QueryGetData  NULL==formatETC\n" );
		#endif
        return ResultFromScode(DATA_E_FORMATETC);
	}
	
	if ( NULL != findDataRenderingForType( formatETC ) ){
		#ifdef _DEBUG	
		StringUtils::trace( "COMDataObject::QueryGetData found supported data type\n" );
		#endif

		result = S_OK;//NOERROR;		
	}
	else {
		#ifdef _DEBUG	
		StringUtils::trace( "COMDataObject::QueryGetData didn't find supported data type\n" );
		#endif
	}
	#ifdef _DEBUG	
	StringUtils::trace( ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n" );
	#endif

	if ( NULL != this->m_outerDataObject ){
		result = m_outerDataObject->QueryGetData( formatETC );
	}
	return result;
}

STDMETHODIMP COMDataObject::GetCanonicalFormatEtc( FORMATETC * formatETCIn, FORMATETC * formatETCOut )
{
	HRESULT result = ResultFromScode(DATA_S_SAMEFORMATETC);
#ifdef _DEBUG
	StringUtils::trace( "COMDataObject::GetCanonicalFormatEtc\n" );
#endif
	if ( NULL != m_outerDataObject ){
		result = m_outerDataObject->GetCanonicalFormatEtc( formatETCIn, formatETCOut );
	}

	return result;
}

/**
* if the releaseData is false we cannot go on - Our data objects need to release the data.
*This may change in future releases.
*if the FormatETC or stgMedium passed in are NULL we should also quit - can't do anything
*otherwise we do the following:
*	1.) Create a data Rendering and add it to the vector m_renderings.
*	2.) 
*/
STDMETHODIMP COMDataObject::SetData( FORMATETC * formatETC, STGMEDIUM * stgMedium, BOOL releaseData )
{
	HRESULT result = E_NOTIMPL;
	//m_ClipboardDataObject
	if ( NULL != m_outerDataObject ){
		result = m_outerDataObject->SetData( formatETC, stgMedium, releaseData );
	}
	else {
		if ( false  == releaseData ){
			result = ResultFromScode(E_FAIL);
		}
		else if ( (NULL==formatETC) || (NULL==stgMedium) ){
			//clean out the clipboard data
			result = ResultFromScode(E_FAIL);
		}
		else {
			DataRendering* rendering = new DataRendering( formatETC,  stgMedium, AS_IUNKNOWN(this) );
			m_renderings.push_back( rendering );
			result = S_OK;
		}
	}
	return result;
}

STDMETHODIMP COMDataObject::EnumFormatEtc( DWORD dwDirection, IEnumFORMATETC ** ppenumFormatetc )
{
#ifdef _DEBUG
	StringUtils::trace( "COMDataObject::EnumFormatEtc\n" );
#endif

	HRESULT result = ResultFromScode(E_FAIL);

	if ( NULL != m_outerDataObject ){
		result = m_outerDataObject->EnumFormatEtc( dwDirection, ppenumFormatetc );
	}
	else {
		*ppenumFormatetc = NULL;
		EnumFormatETC* enumObj = NULL;
		switch ( dwDirection ){
		case DATADIR_GET:{
			enumObj = new EnumFormatETC();
						 }
			break;
			
        case DATADIR_SET:
        default:{
            enumObj = NULL;
				}
			break;
		}
		
		if ( NULL == enumObj ){
			result = ResultFromScode(E_FAIL);
		}
		else{
			//Let the enumerator copy our format list.
			for ( std::vector<DataRendering*>::iterator it = m_renderings.begin(); it != m_renderings.end(); it++ ){
				DataRendering* render = *it;
				enumObj->add( render->m_formatETC );
			}
			enumObj->Reset();
			enumObj->AddRef();
		}
		
		*ppenumFormatetc = (IEnumFORMATETC*)(COMObject*)enumObj;
	}
	return result;
}

STDMETHODIMP COMDataObject::DAdvise( FORMATETC * formatETC, DWORD advf, IAdviseSink * pAdvSink,  DWORD * pdwConnection )
{
	HRESULT result = E_NOTIMPL;
	if ( NULL != m_outerDataObject ){
		result = m_outerDataObject->DAdvise( formatETC, advf, pAdvSink, pdwConnection );
	}
	return result;
}

STDMETHODIMP COMDataObject::DUnadvise( DWORD dwConnection )
{
	HRESULT result = OLE_E_ADVISENOTSUPPORTED;
	if ( NULL != m_outerDataObject ){
		result = m_outerDataObject->DUnadvise( dwConnection );
	}
	return result ;
}

STDMETHODIMP COMDataObject::EnumDAdvise( IEnumSTATDATA ** ppenumAdvise )
{
	HRESULT result = OLE_E_ADVISENOTSUPPORTED;
	if ( NULL != m_outerDataObject ){
		result = m_outerDataObject->EnumDAdvise( ppenumAdvise );
	}
	return result;
}
 
bool COMDataObject::isTypeSupported(const unsigned long & dataType)
{
	return true;
}

void COMDataObject::addSupportedData( const unsigned long & dataType, ClipboardDataObject* data )
{
	this->m_dataMap[dataType] = data;	
	VCF::MemoryStream memStream;
	//Write the data to the mem stream
	memStream.write( data );
	
	STGMEDIUM stgMedium = {0};
	FORMATETC fmtETC = translateFrameworkFormatToFormatETC( dataType );
	stgMedium.tymed = fmtETC.tymed;
	stgMedium.pUnkForRelease = AS_IUNKNOWN(this);
	stgMedium.hGlobal = ::GlobalAlloc( GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_SHARE, memStream.getSize() );
	
	

	if ( 0 != stgMedium.hGlobal ){
		char* globalMemPtr = (char*)::GlobalLock( stgMedium.hGlobal );
		if ( NULL != globalMemPtr ){
			memStream.read( globalMemPtr, memStream.getSize() );
		}				

		if ( S_OK != SetData( &fmtETC, &stgMedium, true ) ){
			//throw exception ?			
		}
	}	
}

ClipboardDataObject* COMDataObject::getSupportedData( const unsigned long & dataType )
{	
	ClipboardDataObject* result = NULL;
	std::map<unsigned long,ClipboardDataObject*>::iterator found = m_dataMap.find( dataType );
	
	if ( found != m_dataMap.end() ){	
		result = found->second;
	}
	return result;
}

static long _findDataRenderingForTypeCallCount = 0;

DataRendering* COMDataObject::findDataRenderingForType( FORMATETC* formatETC )
{
	DataRendering* result = NULL;
	bool found = false;
	_findDataRenderingForTypeCallCount++;
	if ( NULL != formatETC ){

		for ( std::vector<DataRendering*>::iterator it = m_renderings.begin(); it != m_renderings.end(); it++ ){
			DataRendering* dataRender = *it;

			found = (dataRender->m_formatETC.cfFormat == formatETC->cfFormat);//(*dataRender == (*formatETC));
			
			if ( true == found ){
				result = dataRender;				
				break;
			}
		}
	}
	return result;
}

UINT COMDataObject::translateFrameworkFormat( const unsigned long& dataType )
{
	UINT result = 0;
	switch ( dataType ){
		case STRING_DATA_TYPE:{
			result = CF_TEXT;
		}
		break;

		case FILE_DATA_TYPE:{
			result = CF_HDROP;
		}
		break;

		case IMAGE_DATA_TYPE:{
			result = CF_BITMAP;
		}
		break;
	}
	return result;
}

FORMATETC COMDataObject::translateFrameworkFormatToFormatETC( const unsigned long& dataType )
{
	FORMATETC result = {0};
	result.cfFormat = translateFrameworkFormat( dataType );

	COMUtils::makeDefaultFormatETC( result.cfFormat, &result ); 

	return result;
}

String COMDataObject::translateClipboardFmt( const UINT& fmtType )
{
	String result = "";
	switch ( fmtType ){
		case CF_BITMAP:{
			result += "CF_BITMAP";		
		}
		break;
		
		case CF_DIB:{
			result += "CF_DIB";		
		}
		break;

		case CF_DIF:{
			result += "CF_DIF";		
		}
		break;

		case CF_HDROP:{
			result += "CF_HDROP";		
		}
		break;

		case CF_METAFILEPICT:{
			result += "CF_METAFILEPICT";		
		}
		break;

		case CF_OEMTEXT:{
			result += "CF_OEMTEXT";		
		}
		break;

		case CF_TEXT:{
			result += "CF_TEXT";		
		}
		break;
		
		case CF_WAVE:{
			result += "CF_WAVE";		
		}
		break;
		
		case CF_TIFF:{
			result += "CF_TIFF";		
		}
		break;

		default:{
			char s[256];
			sprintf( s, " %d", fmtType );
			result = s;
		};
		break;
	};		
	return result;
};
