/**
*Copyright (c) 2000-2001, Jim Crafton
*All rights reserved.
*Redistribution and use in source and binary forms, with or without
*modification, are permitted provided that the following conditions
*are met:
*	Redistributions of source code must retain the above copyright
*	notice, this list of conditions and the following disclaimer.
*
*	Redistributions in binary form must reproduce the above copyright
*	notice, this list of conditions and the following disclaimer in 
*	the documentation and/or other materials provided with the distribution.
*
*THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
*AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
*LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
*A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS
*OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
*EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
*PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
*PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
*LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
*SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*NB: This software will not save the world.
*/

/* Generated by Together */

#include "ApplicationKit.h"
#include "ListBoxControl.h"
#include "DefaultListModel.h"


using namespace VCF;


static ListItem* previouslySelectedListItem = NULL;


ListBoxControl::ListBoxControl()
{
	m_singleSelectedItem = NULL;

	m_allowsMultiSelect = false;

	setColor( GraphicsToolkit::getDefaultGraphicsToolkit()->getSystemColor( SYSCOLOR_WINDOW ) );

	m_defaultItemHeight = getContext()->getTextHeight( "EM" ) + 4;

	m_listModel = new DefaultListModel();
	ListModelEventHandler<ListBoxControl>* lmh = 
		new ListModelEventHandler<ListBoxControl>( this, ListBoxControl::onItemAdded, "ListBoxControl::onItemAdded" );

	m_listModel->addItemAddedHandler( lmh );

	lmh = 
		new ListModelEventHandler<ListBoxControl>( this, ListBoxControl::onItemDeleted, "ListBoxControl::onItemDeleted" );

	m_listModel->addItemDeletedHandler( lmh );

	lmh = 
		new ListModelEventHandler<ListBoxControl>( this, ListBoxControl::onListModelContentsChanged, "ListBoxControl::onListModelContentsChanged" );
	
	m_listModel->addContentsChangedHandler( lmh );

	m_selectedItemsContainer.initContainer( m_selectedItems );
}

ListBoxControl::~ListBoxControl()
{
	delete m_listModel;	
}

ListModel* ListBoxControl::getListModel()
{
	return m_listModel;
}

void ListBoxControl::setListModel( ListModel * model )
{
	m_listModel = model;
	repaint();
}

void ListBoxControl::onListModelContentsChanged( ListModelEvent* event )
{
	repaint();
	/*
	if ( NULL != event ){
		switch ( event->getType() ){
			case LIST_MODEL_CONTENTS_DELETED: {
				
			}
			break;

			case LIST_MODEL_ITEM_CHANGED: {
				ListItem* item = event->getListItem();
				if ( NULL != item ){
					m_listBoxPeer->removeItem( item );
					m_listBoxPeer->addItem( item );
				}
			}
			break;		
		}
	}
	*/
}

void ListBoxControl::onItemAdded( ListModelEvent* event )
{
	
	//m_listBoxPeer->addItem( event->getListItem() );
	repaint();
}

void ListBoxControl::onItemDeleted( ListModelEvent* event )
{
	repaint();
}

void ListBoxControl::rangeSelect( const bool & isSelected, ListItem * first, ListItem * last )
{
	if ( NULL == last ) {
		setSelectedItem( first ); //this will select it
		if ( false == isSelected ) { // we'll deselect it
			first->setSelected( isSelected );
			m_singleSelectedItem = NULL;	
		}		
		repaint();
	}
	else {
		if ( NULL != m_singleSelectedItem ) {
			m_singleSelectedItem->setSelected( false );
		}	
		m_singleSelectedItem = NULL;

		m_selectedItems.clear();

		ListModel* lm = getListModel();
		if ( NULL != lm ) {
			ulong32 start = first->getIndex();
			ulong32 end = last->getIndex();
			for ( ulong32 i=start;i<=end;i++) {
				ListItem* item = lm->getItemFromIndex( i );
				if ( NULL != item ) {
					item->setSelected( isSelected );
					if ( true == isSelected ) {
						m_selectedItems.push_back( item );
					}
				}
			}
		}
	}
}

void ListBoxControl::paint( GraphicsContext* ctx )
{
	CustomControl::paint( ctx );
	ListModel* lm = getListModel();
	if ( NULL != lm ) {
		Enumerator<ListItem*>* items= lm->getItems();
		double currentTop = 0.0;
		Rect itemRect;
		while ( true == items->hasMoreElements() ) {
			ListItem* item = items->nextElement();
			itemRect.setRect( 0, currentTop, getWidth(), currentTop + m_defaultItemHeight );

			double y = currentTop + ( (itemRect.getHeight()/2.0) - (ctx->getTextHeight( "EM" )/2.0) );
			
			Color oldFontColor;
			oldFontColor = *getFont()->getColor();

			if ( true == item->isSelected() ) {
				paintSelectionRect( ctx, &itemRect, item );
			}
			ctx->textAt( 4, y, item->getCaption() );

			ctx->getCurrentFont()->setColor( &oldFontColor );

			if ( true == item->canPaint() ) {
				item->paint( ctx, &itemRect );
			}
			currentTop += itemRect.getHeight();
		}
	}	
}

void ListBoxControl::paintSelectionRect( GraphicsContext* ctx, Rect* rect, ListItem* item )
{		
	Color* selectedColor = GraphicsToolkit::getDefaultGraphicsToolkit()->getSystemColor( SYSCOLOR_SELECTION );
	Color* selectedTextColor = GraphicsToolkit::getDefaultGraphicsToolkit()->getSystemColor( SYSCOLOR_SELECTION_TEXT );
	Color* greyColor = GraphicsToolkit::getDefaultGraphicsToolkit()->getSystemColor( SYSCOLOR_SHADOW );
	ctx->setColor( selectedColor );
	ctx->rectangle( rect );
	ctx->fillPath();
	ctx->setColor( greyColor );
	ctx->strokePath();
	ctx->getCurrentFont()->setColor( selectedTextColor );	
}

ListItem* ListBoxControl::findSingleSelectedItem( Point* pt )
{
	ListItem* result = NULL;

	Point tmpPt = *pt;
	tmpPt.m_x = 1;

	ListModel* lm = getListModel();
	if ( NULL != lm ) {
		Enumerator<ListItem*>* items= lm->getItems();
		double currentTop = 0.0;
		Rect itemRect;
		while ( true == items->hasMoreElements() ) {
			ListItem* item = items->nextElement();
			itemRect.setRect( 0, currentTop, getWidth(), currentTop + m_defaultItemHeight );
			if ( true == itemRect.containsPt( &tmpPt ) ) {
				result = item;
				break;
			}
			currentTop += itemRect.getHeight();
		}
	}

	return result;
}

void ListBoxControl::mouseDown( MouseEvent* event )
{
	CustomControl::mouseDown( event );
	if ( (true == event->hasLeftButton()) && (CS_NORMAL == getComponentState()) ) {
		keepMouseEvents();
		
		ListItem* foundItem = findSingleSelectedItem( event->getPoint() );
		if ( NULL != foundItem ) {
			//rangeSelect( true, foundItem, NULL );
			if ( true == m_allowsMultiSelect ) {
				if ( NULL != m_singleSelectedItem ) {
					m_singleSelectedItem->setSelected( false );
				}
				m_singleSelectedItem = NULL;
				
				foundItem->setSelected( true );	
				m_selectedItems.push_back( foundItem );
				
			}
			else {
				m_selectedItems.clear();
				setSelectedItem( foundItem );
			}
		}
	}
}

void ListBoxControl::mouseMove( MouseEvent* event )
{
	CustomControl::mouseMove( event );
	if ( (true == event->hasLeftButton()) && (CS_NORMAL == getComponentState()) ) {
		ListItem* foundItem = findSingleSelectedItem( event->getPoint() );
		if ( NULL != foundItem ) {
			if ( true == m_allowsMultiSelect ) { 
				
			}
			else {
				if ( foundItem != m_singleSelectedItem ) {
					
					setSelectedItem( foundItem );
				}
			}
		}
	}
}

void ListBoxControl::mouseUp( MouseEvent* event )
{
	CustomControl::mouseUp( event );
	if ( (true == event->hasLeftButton()) && (CS_NORMAL == getComponentState()) ) {
		releaseMouseEvents();
	}
}

void ListBoxControl::mouseClick( MouseEvent* event )
{
	CustomControl::mouseClick( event );
}

void ListBoxControl::mouseDblClick( MouseEvent* event )
{
	CustomControl::mouseDblClick( event );
}

void ListBoxControl::keyDown( KeyboardEvent* event )
{
	CustomControl::keyDown( event );

	if ( CS_NORMAL == getComponentState() ) {
		if ( true == this->m_allowsMultiSelect ) {
			
		}
		else {
			ListItem* item = this->getSelectedItem();
			ListModel* lm = getListModel();
			if ( (NULL != item) && (NULL != lm) ) {
				ulong32 index = item->getIndex();
				
				if ( VIRT_KEY_UP_ARROW == event->getVirtualCode() ) {				
					index --;
					
				}
				else if ( VIRT_KEY_DOWN_ARROW == event->getVirtualCode() ) {
					index ++;
				}
				item = lm->getItemFromIndex( index );
				if ( NULL != item ) {
					setSelectedItem( item );
				}
			}
		}
	}
}

void ListBoxControl::keyUp( KeyboardEvent* event )
{
	CustomControl::keyUp( event );
}

void ListBoxControl::keyPressed( KeyboardEvent* event )
{
	CustomControl::keyPressed( event );
}

void ListBoxControl::setDefaultItemHeight( const double& defaultItemHeight )
{
	m_defaultItemHeight = defaultItemHeight;
	repaint();
}

Enumerator<ListItem*>* ListBoxControl::getSelectedItems()
{
	return m_selectedItemsContainer.getEnumerator();
}

void ListBoxControl::setAllowsMultiSelect( const bool& allowsMultiSelect )
{
	m_allowsMultiSelect = allowsMultiSelect;
}

void ListBoxControl::setSelectedItem( ListItem* selectedItem )
{
	if ( NULL != m_singleSelectedItem ) {
		m_singleSelectedItem->setSelected( false );
	}		
	m_singleSelectedItem = selectedItem;
	if ( NULL != m_singleSelectedItem ) {
		m_singleSelectedItem->setSelected( true );
	}
	repaint();
}