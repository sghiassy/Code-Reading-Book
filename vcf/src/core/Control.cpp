/**
*Visual Control Framework for C++
*
*Copyright © 2000 Jim Crafton
*
*This program is free software; you can redistribute it and/or
*modify it under the terms of the GNU General Public License
*as published by the Free Software Foundation; either version 2
*of the License, or (at your option) any later version.
*
*This program is distributed in the hope that it will be useful,
*but WITHOUT ANY WARRANTY; without even the implied warranty of
*MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*GNU General Public License for more details.
*
*You should have received a copy of the GNU General Public License
*along with this program; if not, write to the Free Software
*Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*
*
*Contact Jim Crafton at ddiego@one.net for more information about the 
*Visual Control Framework
*/ 

/* Generated by Together */
#include "ApplicationKit.h"
#include "Scrollable.h"


using namespace VCF;

Control* Control::capturedMouseControl = NULL;


Control::Control()
{		
	INIT_EVENT_HANDLER_LIST(ControlSized);	
	INIT_EVENT_HANDLER_LIST(ControlPositioned);	
	INIT_EVENT_HANDLER_LIST(ControlParentChanged);	
	INIT_EVENT_HANDLER_LIST(MouseDoubleClicked);	
	INIT_EVENT_HANDLER_LIST(MouseClicked);	
	INIT_EVENT_HANDLER_LIST(MouseMove);	
	INIT_EVENT_HANDLER_LIST(MouseUp);	
	INIT_EVENT_HANDLER_LIST(MouseDown);	
	INIT_EVENT_HANDLER_LIST(KeyPressed);	
	INIT_EVENT_HANDLER_LIST(KeyDown);	
	INIT_EVENT_HANDLER_LIST(KeyUp);	
	INIT_EVENT_HANDLER_LIST(ControlHelpRequested);	
	INIT_EVENT_HANDLER_LIST(HelpRequested);	
	INIT_EVENT_HANDLER_LIST(FocusLost);	
	INIT_EVENT_HANDLER_LIST(FocusGained);	
	INIT_EVENT_HANDLER_LIST(ToolTipRequested);	
	INIT_EVENT_HANDLER_LIST(ToolTip);	

	this->m_Peer = NULL;
	this->m_aligment = ALIGN_NONE;
	this->m_border = NULL;
	this->m_font = new Font();
	m_font->setName( "Tahoma" );
	this->m_context = new ControlGraphicsContext( this );
	m_parent = NULL;
	m_view = NULL;
	this->m_doubleBuffered = true;
	m_hasMouseCapture = false;

	m_bounds = new Rect();
	m_clientBounds = new Rect();
	m_color = new Color;
	
	this->m_popupMenu = NULL;

	m_scrollable = NULL;

	m_cursor = NULL;

	setCursorID( (long)Cursor::SCT_DEFAULT );

	GraphicsToolkit* toolkit = GraphicsToolkit::getDefaultGraphicsToolkit();
	if ( NULL != toolkit ){
		this->setColor( toolkit->getSystemColor( SYSCOLOR_FACE ) );
	}
	
	
	this->m_viewControl = this;

	this->m_anchor = ANCHOR_NONE;
	
	m_anchorDeltas[ANCHOR_DTOP] = 0.0f;
	m_anchorDeltas[ANCHOR_DLEFT] = 0.0f;
	m_anchorDeltas[ANCHOR_DBOTTOM] = 0.0f;
	m_anchorDeltas[ANCHOR_DRIGHT] = 0.0f;
}

Control::~Control()
{
	delete m_bounds;
	delete m_clientBounds;
	delete m_color;

	delete m_context;

	if ( NULL != m_Peer ) {
		delete m_Peer;
		m_Peer = NULL;
	}
	if ( NULL != m_border ){
		delete m_border;
		m_border = NULL;
	}

	if ( NULL != m_font ){
		delete m_font;
		m_font = NULL;
	}
}


Border* Control::getBorder()
{
	return this->m_border;
}

void Control::setBorder( Border* border )
{
	if ( NULL != m_border ){
		delete m_border;
		m_border = NULL;
	}
	this->m_border = border;
}

Rect* Control::getBounds()
{	
	if ( NULL == this->m_Peer ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};	

	*m_bounds = *(m_Peer->getBounds()); 

	return this->m_bounds;
}

Rect* Control::getClientBounds( const bool& includeBorder )
{	
	if ( NULL == this->m_Peer ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};	
	
	Rect* r = this->m_Peer->getBounds(); 
	m_clientBounds->setRect( 0.0, 0.0, r->getWidth(), r->getHeight() );

	if ( (false == includeBorder) && (NULL != this->m_border) ){
		*m_clientBounds = *m_border->getClientRect( this );
	}

	return this->m_clientBounds;
}

double Control::getLeft()
{
	if ( NULL == this->m_Peer ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};	
	double result = 0.0;
	if ( NULL != this->m_Peer ){
		*m_bounds = *(m_Peer->getBounds());		
		result = this->m_bounds->m_left;
	};
	return result;
}

double Control::getWidth()
{
	if ( NULL == this->m_Peer ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};	

	double result = 0.0;
	if ( NULL != this->m_Peer ){
		*m_bounds = *(this->m_Peer->getBounds());		
		result = this->m_bounds->getWidth();
	};
	return result;
}

double Control::getTop()
{
	if ( NULL == this->m_Peer ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};	

	double result = 0.0;
	if ( NULL != this->m_Peer ){
		*m_bounds = *(m_Peer->getBounds());		
		result = this->m_bounds->m_top;
	};
	return result;
}

double Control::getHeight()
{
	if ( NULL == this->m_Peer ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};
	
	double result = 0.0;
	if ( NULL != this->m_Peer ){
		*m_bounds = *(this->m_Peer->getBounds());		
		result = this->m_bounds->getHeight();
	};

	return result;
}

bool Control::getVisible()
{
	if ( NULL == this->m_Peer ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};	

	return this->m_Peer->getVisible();
}

AlignmentType Control::getAlignment()
{
	return this->m_aligment;
}

void Control::setBounds( Rect* rect, const bool& anchorDeltasNeedUpdating )
{
	if ( NULL == this->m_Peer ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};	
	

	*m_bounds = *rect;
	this->m_Peer->setBounds( m_bounds );
	/*
	if ( NULL != this->m_parent ) {
		Container* containerParent = dynamic_cast<Container*>( m_parent );
		if ( NULL != containerParent ) {
			containerParent->resizeChildren();
		}
	}
	*/
	if ( true == anchorDeltasNeedUpdating ) {
		updateAnchorDeltas();
	}
}

void Control::setAlignment( const AlignmentType& alignment )
{
	this->m_aligment = alignment;
	Control* parent = this->getParent();
	if ( NULL != parent ){
		Container* container = dynamic_cast<Container*>(parent );
		if ( NULL != container ){
			container->resizeChildren();
		}
	}
	m_anchor = ANCHOR_NONE;
	updateAnchorDeltas();
}

void Control::setLeft( const double& left )
{	
	if ( NULL == this->m_Peer ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};
	
	if ( NULL != this->m_Peer ){
		double dx = m_bounds->getWidth();
		this->m_bounds->m_left = left;
		this->m_bounds->m_right = left + dx;
		setBounds( m_bounds );
	};
}

void Control::setWidth( const double& width )
{
	if ( NULL == this->m_Peer ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};	

	if ( NULL != this->m_Peer ){
		this->m_bounds->m_right = this->m_bounds->m_left + width;
		setBounds( m_bounds );
	};
}

void Control::setTop( const double& top )
{
	if ( NULL == this->m_Peer ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};

	if ( NULL != this->m_Peer ){
		double dy = this->m_bounds->getHeight();
		this->m_bounds->m_top = top;
		this->m_bounds->m_bottom = top + dy;
		setBounds( m_bounds );
	};
}

void Control::setHeight( const double& height )
{
	if ( NULL == this->m_Peer ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};	

	if ( NULL != this->m_Peer ){
		this->m_bounds->m_bottom = this->m_bounds->m_top + height;
		setBounds( m_bounds );
	};
}

void Control::setVisible( const bool& visible )
{
	if ( NULL == this->m_Peer ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};	
	this->m_Peer->setVisible( visible );
}

void Control::loadFromStream( InputStream * stream )
{
	if ( NULL != stream ){
		Class* clazz = this->getClass();
		if ( NULL != clazz ){
			String propName = "";	
			String strVal = "";
			long count = 0;
			stream->read( count );
			while ( count > 0 ){
				stream->read( propName );
				Property* prop = clazz->getProperty( propName );
				if ( NULL != prop ){
					VariantData* val = prop->get();
					stream->read( strVal );
					val->setFromString( strVal );
				}
				count --;
			}
		}
	}
}

void Control::saveToStream( OutputStream * stream )
{
	if ( NULL != stream ){
		Class* clazz = this->getClass();
		if ( NULL != clazz ){
			Enumerator<Property*>* props = clazz->getProperties();
			long count = clazz->getPropertyCount();
			stream->write( count );
			while ( props->hasMoreElements() ){
				Property* prop = props->nextElement();
				if ( NULL != prop ){
					stream->write( prop->getName() );
					VariantData* val = prop->get();
					String strVal = "null";
					if ( NULL != val ){
						strVal = val->toString();
						stream->write( strVal );
					}
					else {
						stream->write( strVal );
					}
				}
			}
		}
	}
}

void Control::processMouseEvent( MouseEvent* mouseEvent )
{
	if ( NULL != mouseEvent ){
		unsigned long eventType = mouseEvent->getType();

		switch ( eventType ){
			case MOUSE_EVENT_DOWN:{
				//this->mouseDown( mouseEvent );
				//if ( !mouseEvent->isConsumed() )
				fireOnMouseDown( mouseEvent );
				if (!mouseEvent->isConsumed())
					this->mouseDown( mouseEvent );
			}
			break;

			case MOUSE_EVENT_MOVE:{
				//this->mouseMove( mouseEvent );
				this->m_Peer->setCursor( this->m_cursor );
				fireOnMouseMove( mouseEvent );
				if (!mouseEvent->isConsumed())
					this->mouseMove( mouseEvent );
			}
			break;

			case MOUSE_EVENT_UP:{
				//this->mouseUp( mouseEvent );
				bool rightBtn = mouseEvent->hasRightButton();
				fireOnMouseUp( mouseEvent );
				if (!mouseEvent->isConsumed())
					this->mouseUp( mouseEvent );
				if ( (NULL != this->m_popupMenu) && (true == rightBtn) ){
					m_popupMenu->popup( mouseEvent->getPoint() );	
				}
			}
			break;

			case MOUSE_EVENT_CLICK:{
				fireOnMouseClicked( mouseEvent );
				mouseClick( mouseEvent );
			}
			break;

			case MOUSE_EVENT_DBLCLICK:{
				fireOnMouseDoubleClicked( mouseEvent );
				mouseDblClick( mouseEvent );
			}
			break;
		}
		//if ( !mouseEvent->isConsumed() )
			//mouseEvent->setConsumed(true);
	}
}

void Control::processKeyboardEvent( KeyboardEvent* keyboardEvent )
{
	if ( NULL != keyboardEvent ){
		unsigned long eventType = keyboardEvent->getType();
		switch ( eventType ){
			case KEYBOARD_EVENT_DOWN:{
				this->keyDown( keyboardEvent );
				fireOnKeyDown( keyboardEvent );
			}
			break;

			case KEYBOARD_EVENT_PRESSED:{
				this->keyPressed( keyboardEvent );
				fireOnKeyPressed( keyboardEvent );
			}
			break;

			case KEYBOARD_EVENT_UP:{
				this->keyUp ( keyboardEvent );
				fireOnKeyUp( keyboardEvent );
			}
			break;
		}
	}
}

void Control::processControlEvent( ControlEvent* ControlEvent )
{
	if ( NULL != ControlEvent ){
		unsigned long eventType = ControlEvent->getType();

		switch ( eventType ){
			case CONTROL_EVENT_SIZED:{
				fireOnControlSized( ControlEvent );
			}
			break;

			case CONTROL_EVENT_POSITIONED:{
				fireOnControlPositioned( ControlEvent );
			}
			break;

			case CONTROL_EVENT_PARENT_CHANGED:{
				fireOnControlParentChanged( ControlEvent );
			}
			break;
		}
	}
}

bool Control::canBeginDragDrop()
{
	return false;
}

void Control::setAutoStartDragDrop(const bool& canAutoStartDragDrop)
{
	m_autoStartDragDrop = canAutoStartDragDrop;
}

bool Control::getAutoStartDragDrop()
{
	return m_autoStartDragDrop;
}

void Control::beginDragDrop()
{

}

ControlPeer* Control::getPeer()
{
	return m_Peer;
}

void Control::setParent( Control* parent )
{
	if ( NULL == m_Peer ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};	

	if ( parent != m_parent ) {
		ControlEvent event( this, parent );
		fireOnControlParentChanged( &event );
	}

	m_parent = parent;
	m_Peer->setParent( parent );
	updateAnchorDeltas();
}

Control* Control::getParent()
{
	if ( NULL == this->m_Peer ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};

	return m_parent;
}

bool Control::isFocused()
{
	if ( NULL == this->m_Peer ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};

	return this->m_Peer->isFocused();
}

void Control::setFocus( const bool& focused )
{
	if ( NULL == this->m_Peer ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	}

	//if ( getComponentState() == CS_NORMAL ) {
		this->m_Peer->setFocus( focused );
	//}
}

bool Control::isEnabled()
{
	if ( NULL == this->m_Peer ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};
	return this->m_Peer->isEnabled();
}

void Control::setEnabled( const bool& enabled )
{
	if ( NULL == this->m_Peer ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};
	this->m_Peer->setEnabled( enabled );
}

void Control::mouseDown( MouseEvent* event )
{
	this->setFocus( true );
}

void Control::mouseMove( MouseEvent* event )
{
	
}

void Control::mouseUp( MouseEvent* event )
{
	
}

void Control::keyDown( KeyboardEvent* event )
{

}

void Control::mouseClick(  MouseEvent* event )
{

}
	
void Control::mouseDblClick(  MouseEvent* event )
{

}

void Control::keyPressed( KeyboardEvent* event )
{

}

void Control::keyUp( KeyboardEvent* event )
{

}

void Control::translateToParent( Point* point )
{
	Control* parent = this->getParent();
	if ( NULL != parent ){
		Rect* bounds = parent->getBounds();
		point->m_x += bounds->m_left;
		point->m_y += bounds->m_top;
	}
	else{
		//throw exception ?
	}
}

void Control::translateToLocal( Point* point )
{
	Control* parent = this->getParent();
	if ( NULL != parent ){
		Rect* bounds = this->getBounds();
		point->m_x -= bounds->m_left;
		point->m_y -= bounds->m_top;
	}
	else{
		//throw exception ?
	}
}

void Control::beforeDestroy( ControlEvent* event )
{

}

bool Control::isLightWeight()
{	
	return false;
}

Control* Control::getHeavyweightParent()
{	
	Control* parent = NULL;
	Control* result = NULL;
	result = this->getParent();
	while ( true == result->isLightWeight() ){
		parent = result;
		result = parent->getParent();
	}

	return result;
}

Color* Control::getColor()
{
	return this->m_color;
}

void Control::setColor( Color* color )
{
	m_color->copy( color );
}

String Control::toString()
{
	return Component::toString();
}

Font* Control::getFont()
{
	return m_font;
}

void Control::setFont( Font* font )
{
	if ( NULL != font ){
		m_font->copy( font );
	}
	if ( NULL == this->m_Peer ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};
	this->m_Peer->setFont( m_font );

}

bool Control::useParentFont()
{
	return m_useParentFont;
}

void Control::setUseParentFont( const bool& useParentFont )
{
	m_useParentFont = useParentFont;
}

void Control::afterCreate( ComponentEvent* event )
{
	if ( NULL == this->m_Peer ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};

	this->m_Peer->setFont( m_font );
}

void Control::repaint( Rect* repaintRect )
{
	if ( NULL == this->m_Peer ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};
	this->m_Peer->repaint( repaintRect );
}

bool Control::isDoubleBuffered()
{
	return this->m_doubleBuffered;
}

void Control::setDoubleBuffered( const bool& doubleBuffered )
{
	m_doubleBuffered = doubleBuffered;
}

void Control::keepMouseEvents()
{	
	if ( NULL == this->m_Peer ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};
	m_hasMouseCapture = true;
	Control::setCapturedMouseControl( this );
	this->m_Peer->keepMouseEvents();	
}

void Control::releaseMouseEvents()
{
	if ( NULL == this->m_Peer ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};
	m_hasMouseCapture = false;
	Control::setCapturedMouseControl( NULL );
	this->m_Peer->releaseMouseEvents();	
}

Control* Control::getCapturedMouseControl()
{
	return Control::capturedMouseControl;
}
	
void Control::setCapturedMouseControl( Control* control )
{
	Control::capturedMouseControl = control;
}

GraphicsContext* Control::getContext()
{		
	return this->m_context;
}

PopupMenu* Control::getPopupMenu()
{
	return this->m_popupMenu;
}

void Control::setPopupMenu( PopupMenu* popupMenu )
{
	if ( NULL != m_popupMenu ){
		m_popupMenu->setControl( NULL );
	}
	
	m_popupMenu = popupMenu;

	if ( NULL != m_popupMenu ){
		m_popupMenu->setControl( this );
	}
}

View* Control::getView()
{
	return m_view;
}

void Control::setView( View* view )
{
	m_view = view;
}

void Control::setScrollable( Scrollable* scrollable )
{
	m_scrollable = scrollable;
	if ( NULL != m_scrollable ) {
		m_scrollable->recalcScrollPositions();
	}
}

void Control::processWhatsThisHelpEvent()
{
	WhatsThisHelpEvent event( this, m_whatThisHelpString );
	if ( NULL != m_ControlHelpRequestedList ) {
		if ( true == m_ControlHelpRequestedList->empty() ) {
			
		}
		else {
			fireOnControlHelpRequested( &event );
		}
	}
}

void Control::setToolTip( const String& tooltip )
{
	m_toolTip = tooltip;
}

void Control::setCursorID( const long& cursorID )
{
	m_cursor = CursorManager::getCursorManager()->getCursor( cursorID );
}

void Control::setAnchor( const long& anchor )
{
	m_anchor = anchor;
	m_aligment = ALIGN_NONE;
	updateAnchorDeltas();

	Control* parent = this->getParent();	
	if ( NULL != parent ){
		Container* container = dynamic_cast<Container*>(parent );
		if ( NULL != container ){
			container->resizeChildren();
		}
	}	
}

void Control::updateAnchorDeltas() {
	if ( ANCHOR_NONE == m_anchor ) {
		m_anchorDeltas[ANCHOR_DTOP] = 0.0f;
		m_anchorDeltas[ANCHOR_DLEFT] = 0.0f;
		m_anchorDeltas[ANCHOR_DBOTTOM] = 0.0f;
		m_anchorDeltas[ANCHOR_DRIGHT] = 0.0f;
	}
	else {
		Control* parent = getParent();
		if ( NULL != parent ) {
			Rect* parentBounds = parent->getBounds();
			Rect* bounds = getBounds();			
			m_anchorDeltas[ANCHOR_DTOP] = (float) bounds->m_top;
			m_anchorDeltas[ANCHOR_DLEFT] = (float) bounds->m_left;
			m_anchorDeltas[ANCHOR_DBOTTOM] = (float) parentBounds->m_bottom -  bounds->m_bottom;
			m_anchorDeltas[ANCHOR_DRIGHT] = (float) parentBounds->m_right -  bounds->m_right;
		}
	}	
}

