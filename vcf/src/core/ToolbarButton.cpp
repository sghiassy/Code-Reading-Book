/**
*Copyright (c) 2000-2001, Jim Crafton
*All rights reserved.
*Redistribution and use in source and binary forms, with or without
*modification, are permitted provided that the following conditions
*are met:
*	Redistributions of source code must retain the above copyright
*	notice, this list of conditions and the following disclaimer.
*
*	Redistributions in binary form must reproduce the above copyright
*	notice, this list of conditions and the following disclaimer in 
*	the documentation and/or other materials provided with the distribution.
*
*THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
*AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
*LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
*A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS
*OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
*EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
*PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
*PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
*LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
*SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*NB: This software will not save the world.
*/

/* Generated by Together */

#include "ApplicationKit.h"
#include "ToolbarButton.h"



using namespace VCF;

std::multimap<long,ToolbarButton*> groupIDMap;
typedef std::multimap<long,ToolbarButton*>::value_type TGroupPair;
typedef std::multimap<long,ToolbarButton*>::iterator TGroupIterator;

ToolbarButton* ToolbarButton::highlightedToolbarButton = NULL;

ToolbarButton::ToolbarButton():
	CustomControl( false ) //make a lightweight control !
{
	init();
}

ToolbarButton::~ToolbarButton()
{

}

void ToolbarButton::init()
{
	INIT_EVENT_HANDLER_LIST(ButtonClicked);

	m_preferredHeight = 25;
	m_preferredWidth = 25;
	m_isHighlighted = false;
	m_isPressed = false;
	m_groupID = -1;
	m_stateToggle = true;
	m_showCaption = true;
	m_BtnImageIndex = -1;
	m_imageList = NULL;
	m_autoSizeForCaption = true;
	m_captionAlignment = BCA_RIGHT;
	m_userData = NULL;
}

void ToolbarButton::paint(GraphicsContext * context)
{
	CustomControl::paint( context );
	Rect r( 0,0,getWidth(), getHeight() );
	r.inflate( 0, -1 );
	
	if ( (true == m_isHighlighted)  ) {		
		Light3DBorder bdr;
		bdr.setInverted( m_isPressed );
		bdr.paint( &r, context );
	}
	else if ( /*(true == m_stateToggle) &&*/ (true == m_isPressed) ) {
		Rect tmpRect = r;
		Light3DBorder bdr;
		bdr.setInverted( m_isPressed );
		bdr.paint( &tmpRect, context );
		if ( true == m_stateToggle ) {
			tmpRect.inflate( -2, -2 );
			Color* fill = GraphicsToolkit::getDefaultGraphicsToolkit()->getSystemColor( SYSCOLOR_WINDOW );
			Color oldColor = *(context->getColor());
			context->setColor( fill );
			context->rectangle( &tmpRect );
			context->fillPath();
			context->setColor( &oldColor );		
		}
	}
	
	Rect imgRect(0, 0, 0, 0 );
	if ( NULL != this->m_imageList ) {
		if (this->m_BtnImageIndex >= 0 ) {						
			switch ( m_captionAlignment ) {
				case BCA_RIGHT : {
					imgRect.m_top = __max( r.m_top, (r.getHeight()/2.0) - (m_imageList->getImageHeight()/2.0) );
					imgRect.m_bottom = __min( r.m_bottom, imgRect.m_top + m_imageList->getImageHeight() );

					imgRect.m_left = r.m_left + 2;
					imgRect.m_right = imgRect.m_left + __min( r.getWidth(), m_imageList->getImageWidth() );
				}
				break;

				case BCA_TOP : {
					imgRect.m_top += context->getTextHeight( m_caption ) + IMAGE_CAPTION_BUFFER;
					imgRect.m_bottom = __min( m_imageList->getImageHeight(), r.getHeight() );	

					imgRect.m_left = (r.getWidth()/2.0) - (m_imageList->getImageWidth()/2.0);
					imgRect.m_right = m_imageList->getImageWidth();
				}
				break;
				
				case BCA_LEFT : {
					imgRect.m_right = r.m_right;
					imgRect.m_left = __max( r.m_left, imgRect.m_right - m_imageList->getImageWidth() );
					imgRect.m_top += context->getTextHeight( m_caption ) + IMAGE_CAPTION_BUFFER;
					imgRect.m_bottom = __min( m_imageList->getImageHeight(), r.getHeight() );	
				}
				break;
				
				case BCA_BOTTOM : {
					imgRect.m_top = r.m_top;//context->getTextHeight( m_caption ) + IMAGE_CAPTION_BUFFER;
					imgRect.m_bottom = imgRect.m_top + ( __min( m_imageList->getImageHeight(), r.getHeight() ) );	

					imgRect.m_left = (r.getWidth()/2.0) - (m_imageList->getImageWidth()/2.0);
					imgRect.m_right = m_imageList->getImageWidth();
				}
				break;
			}	
			//imgRect.inflate( -2, -2 );
			if ( true == m_isPressed ) {
				imgRect.setRect( imgRect.m_left + 1.0, imgRect.m_top + 1.0, imgRect.m_right + 1.0, imgRect.m_bottom + 1.0 );
			}
			m_imageList->draw( context, m_BtnImageIndex, &imgRect );		
		}
	}

	if ( true == m_showCaption ) {
		Rect textRect = r;
		
		switch ( m_captionAlignment ) {
			case BCA_RIGHT : {
				textRect.m_top = __max( r.m_top, (r.getHeight()/2.0) - (context->getTextHeight( m_caption ) / 2.0) );
				textRect.m_bottom = __min( r.m_bottom, textRect.m_top + context->getTextHeight( m_caption ) );
				if ( (NULL != this->m_imageList) && (m_BtnImageIndex >= 0) ) {
					textRect.m_left = imgRect.m_right + IMAGE_CAPTION_BUFFER;
					textRect.m_right = r.m_right;	
				}
				else {
					textRect.m_left = __max( r.m_left, (r.getWidth() / 2.0) - (context->getTextWidth( m_caption )/2.0) );
					textRect.m_right = __min( r.m_right, textRect.m_left + context->getTextWidth( m_caption ) );
				}
			}
			break;

			case BCA_TOP : {
				textRect.m_left = __max( r.m_left, (r.getWidth() / 2.0) - (context->getTextWidth( m_caption )/2.0) );
				textRect.m_right = __min( r.m_right, textRect.m_left + context->getTextWidth( m_caption ) );
				if ( (NULL != this->m_imageList) && (m_BtnImageIndex >= 0) ) {
					textRect.m_top = r.m_top;
					textRect.m_bottom = imgRect.m_top;
				}
				else {
					textRect.m_top = __max( r.m_top, (r.getHeight()/2.0) - (context->getTextHeight( m_caption ) / 2.0) );
					textRect.m_bottom = __min( r.m_bottom, textRect.m_top + context->getTextHeight( m_caption ) );
				}
			}
			break;
			
			case BCA_LEFT : {
				textRect.m_top = __max( r.m_top, (r.getHeight()/2.0) - (context->getTextHeight( m_caption ) / 2.0) );
				textRect.m_bottom = __min( r.m_bottom, textRect.m_top + context->getTextHeight( m_caption ) );
				if ( (NULL != this->m_imageList) && (m_BtnImageIndex >= 0) ) {
					textRect.m_left = r.m_left;
					textRect.m_right = imgRect.m_left - IMAGE_CAPTION_BUFFER;	
				}
				else {
					textRect.m_left = __max( r.m_left, (r.getWidth() / 2.0) - (context->getTextWidth( m_caption )/2.0) );
					textRect.m_right = __min( r.m_right, textRect.m_left + context->getTextWidth( m_caption ) );
				}
			}
			break;
			
			case BCA_BOTTOM : {
				textRect.m_left = __max( r.m_left, (r.getWidth() / 2.0) - (context->getTextWidth( m_caption )/2.0) );
				textRect.m_right = __min( r.m_right, textRect.m_left + context->getTextWidth( m_caption ) );
				if ( (NULL != this->m_imageList) && (m_BtnImageIndex >= 0) ) {
					textRect.m_top = imgRect.m_bottom;
					textRect.m_bottom = r.m_bottom;
				}
				else {
					textRect.m_top = __max( r.m_top, (r.getHeight()/2.0) - (context->getTextHeight( m_caption ) / 2.0) );
					textRect.m_bottom = __min( r.m_bottom, textRect.m_top + context->getTextHeight( m_caption ) );
				}
			}
			break;
		}
		if ( true == m_isPressed ) {
			textRect.setRect( textRect.m_left + 1.0, textRect.m_top + 1.0, textRect.m_right + 1.0, textRect.m_bottom + 1.0 );
		}
		context->textBoundedBy( &textRect, m_caption, false ); 	
	}	
}

void ToolbarButton::click()
{
	ButtonEvent event( this, 0 );
	fireOnButtonClicked( &event );
}

void ToolbarButton::setCaption( const std::string& caption )
{
	m_caption = caption;
	if ( true == m_autoSizeForCaption ) {
		this->setBounds( this->getBounds() );	
	}
	this->repaint();
}

String ToolbarButton::getCaption()
{
	return m_caption;
}

double ToolbarButton::getPreferredHeight()
{
	return m_preferredHeight;
}

void ToolbarButton::setPreferredHeight( const double& preferredHeight )
{
	m_preferredHeight = preferredHeight;
}

double ToolbarButton::getPreferredWidth()
{
	return m_preferredWidth;
}	

void ToolbarButton::setPreferredWidth( const double& preferredWidth )
{
	m_preferredWidth = preferredWidth;
}

void ToolbarButton::mouseMove( MouseEvent* event )
{	
	CustomControl::mouseMove( event );	
	Point* pt = event->getPoint();	
	if ( false == this->m_stateToggle ) {
		m_isPressed = false;
		if ( true == event->hasLeftButton() ) {
			Rect r (0, 0, getWidth(), getHeight() );
			m_isPressed = r.containsPt( pt );
		}
	}
	this->setIsHighlighted( m_innerRect.containsPt( pt ) || m_stateToggle );
}

void ToolbarButton::setBounds( Rect* rect, const bool& anchorDeltasNeedUpdating )
{
	Rect tmpRect = *rect;
	if ( (true == m_autoSizeForCaption) && (true == m_showCaption) ) {
		bool needsResize = false;
		switch ( m_captionAlignment ) {
			case BCA_RIGHT : case BCA_LEFT : {
				double tmpW = 0.0;
				if ( (NULL != this->m_imageList) && (this->m_BtnImageIndex > -1) ) {
					tmpW = m_imageList->getImageWidth();
				}
				double w = getContext()->getTextWidth( this->m_caption );
				tmpW += (w + IMAGE_CAPTION_BUFFER + 5);
				if ( tmpRect.getWidth() < tmpW )  {
					double delta = tmpW - tmpRect.getWidth();
					tmpRect.m_right = tmpRect.m_left + tmpRect.getWidth() + delta;
					needsResize = true;
				}				
			}
			break;
			
			case BCA_TOP : case BCA_BOTTOM : {
				double tmpH = 0.0;
				if ( (NULL != this->m_imageList) && (this->m_BtnImageIndex > -1) ) {
					tmpH = m_imageList->getImageHeight();
				}
				double h = getContext()->getTextHeight( this->m_caption );
				tmpH += (h + IMAGE_CAPTION_BUFFER);
				if ( tmpRect.getHeight() < tmpH )  {
					double delta = tmpH - tmpRect.getHeight();
					tmpRect.m_bottom = tmpRect.m_top + tmpRect.getHeight() + delta;
					needsResize = true;					
				}				
			}
			break;
		}		
		CustomControl::setBounds( &tmpRect, anchorDeltasNeedUpdating );
		if ( true == needsResize ) {
			parentResize();
		}
	}
	else {
		CustomControl::setBounds( &tmpRect, anchorDeltasNeedUpdating );
	}
	
	m_innerRect.setRect( 0, 0, tmpRect.getWidth(), tmpRect.getHeight() );
	m_innerRect.inflate( -2, -2 );
}

void ToolbarButton::mouseDown( MouseEvent* event )
{
	CustomControl::mouseDown( event );
	this->keepMouseEvents();
	if ( true == m_stateToggle ) {		
		m_isPressed = !m_isPressed;
		this->setIsHighlighted( true );
	}
	else {
		m_isPressed = ( event->hasLeftButton() || event->hasRightButton() );
		Point pt = *(event->getPoint());
		this->setIsHighlighted( m_innerRect.containsPt( &pt ) );
	}	
}

void ToolbarButton::mouseClick(  MouseEvent* event )
{
	CustomControl::mouseClick( event );
}

void ToolbarButton::mouseUp( MouseEvent* event )
{
	CustomControl::mouseUp( event );
	
	this->releaseMouseEvents();
	Rect r( 0, 0, getWidth(), getHeight() );
	bool ptInBounds = r.containsPt( event->getPoint() );
	if ( true == m_stateToggle ) {
		if ( ! ptInBounds ) { //change the state
			m_isPressed = false;
		}
		this->setIsHighlighted( ptInBounds );
	}
	else {
		m_isPressed = !( event->hasLeftButton() || event->hasRightButton() );
		Point pt = *(event->getPoint());
		this->setIsHighlighted( (true == ptInBounds) && (true == m_innerRect.containsPt( &pt )) );
	}	
	
	if ( true == m_isPressed ) {
		click();
	}
}

void ToolbarButton::setIsHighlighted( const bool& highlighted )
{
	m_isHighlighted = highlighted;

	if ( NULL != ToolbarButton::highlightedToolbarButton ){
		if ( ToolbarButton::highlightedToolbarButton != this ) {
			ToolbarButton::highlightedToolbarButton->setIsHighlighted( false );
		}			
	}
	
	ToolbarButton::highlightedToolbarButton = this;

	repaint();
}

void ToolbarButton::setGroupID( const long& groupID )
{
	this->m_groupID = groupID;
	if ( m_groupID < 0 ) {
		TGroupIterator found = groupIDMap.find( m_groupID );
		if ( found != groupIDMap.end() ) {
			if ( found->second == this ) {
				groupIDMap.erase( found );
			}
		}
	}
	else {
		//check for old one
		TGroupIterator found = groupIDMap.find( m_groupID );
		if ( found != groupIDMap.end() ) {
			if ( found->second == this ) {
				groupIDMap.erase( found );
			}
		}
		TGroupPair groupPair( m_groupID, this );
		groupIDMap.insert( groupPair );
	}
}

void ToolbarButton::setStateToggle( const bool& stateToggle )
{
	m_stateToggle = stateToggle;
}

void ToolbarButton::setShowCaption( const bool& showCaption )
{
	this->m_showCaption = showCaption;
	this->repaint();
}

void ToolbarButton::setImageList( ImageList* imageList )
{
	m_imageList = imageList;
	this->repaint();
}

void ToolbarButton::setBtnImageIndex( const long& btnImageIndex )
{
	m_BtnImageIndex = btnImageIndex;
	repaint();
}

void ToolbarButton::setCaptionAlignment( const ButtonCaptionAlignment& captionAlignment )
{
	m_captionAlignment = captionAlignment;
	repaint();
}

void ToolbarButton::setAutoSizeCaption( const bool& autoSizeForCaption )
{
	m_autoSizeForCaption = autoSizeForCaption;
	if ( true == m_autoSizeForCaption ) {
		//resize the control by resetting the caption
		String tmp = this->getCaption();
		this->setCaption( tmp );
	}
}

void ToolbarButton::parentResize()
{
	Container* parent = dynamic_cast<Container*>( getParent() );//we should NEVER have a parent that is not a Container !
	if ( NULL != parent ) {
		parent->resizeChildren();		
	}
	else {
		//throw exception
	}
}

void ToolbarButton::setIsPressed( const bool& isPressed )
{
	if ( true == this->m_stateToggle ) {
		m_isPressed = isPressed;
		if ( true == m_isPressed ) {
			click();
		}
		repaint();
	}
}