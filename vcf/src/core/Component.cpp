/**
*Copyright (c) 2000-2001, Jim Crafton
*All rights reserved.
*Redistribution and use in source and binary forms, with or without
*modification, are permitted provided that the following conditions
*are met:
*	Redistributions of source code must retain the above copyright
*	notice, this list of conditions and the following disclaimer.
*
*	Redistributions in binary form must reproduce the above copyright
*	notice, this list of conditions and the following disclaimer in 
*	the documentation and/or other materials provided with the distribution.
*
*THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
*AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
*LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
*A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS
*OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
*EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
*PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
*PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
*LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
*SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*NB: This software will not save the world.
*/

/* Generated by Together */
#include "ApplicationKit.h"

#include <algorithm>

static long ComponentTagID = 0;

using namespace VCF;

Component::Component()
{	
	INIT_EVENT_HANDLER_LIST(ComponentCreated)
	INIT_EVENT_HANDLER_LIST(ComponentDeleted)

	m_componentState = CS_NORMAL;	
	m_tag = ComponentTagID;
	ComponentTagID++;
	m_componentContainer.initContainer( this->m_components );
}

Component::~Component()
{
	std::vector<Component*>::iterator componentIter = this->m_components.begin();
	while ( componentIter != m_components.end() ){
		Component* component = *componentIter;
		delete component;
		component = NULL;
		componentIter++;
	}
	m_components.clear();
}

String Component::getName()
{
	return this->m_name;
}

void Component::setName( const String& name )
{
	this->m_name = name;
}

void Component::loadFromStream( InputStream * stream )
{
	if ( NULL != stream ){
		Class* clazz = this->getClass();
		if ( NULL != clazz ){
			String propName = "";	
			String strVal = "";
			long count = 0;
			stream->read( count );
			while ( count > 0 ){
				stream->read( propName );
				Property* prop = clazz->getProperty( propName );
				if ( NULL != prop ){
					VariantData* val = prop->get();
					stream->read( strVal );
					val->setFromString( strVal );
				}
				count --;
			}
		}
	}
}

void Component::saveToStream( OutputStream * stream )
{
	if ( NULL != stream ){
		Class* clazz = this->getClass();
		if ( NULL != clazz ){
			Enumerator<Property*>* props = clazz->getProperties();
			long count = clazz->getPropertyCount();
			stream->write( count );
			while ( props->hasMoreElements() ){
				Property* prop = props->nextElement();
				if ( NULL != prop ){
					stream->write( prop->getName() );
					VariantData* val = prop->get();
					String strVal = "null";
					if ( NULL != val ){
						strVal = val->toString();
						stream->write( strVal );
					}
					else {
						stream->write( strVal );
					}
				}
			}
		}
	}
}

void Component::beforeDestroy( ComponentEvent* event )
{

}

void Component::processComponentEvent( ComponentEvent* componentEvent )
{
	if ( NULL != componentEvent ){
		unsigned long eventType = componentEvent->getType();

		switch ( eventType ){

			case COMPONENT_EVENT_CREATED:{
				this->afterCreate( componentEvent );
				fireOnComponentCreated( componentEvent );
			}
			break;

			case COMPONENT_EVENT_DELETED:{
				this->beforeDestroy( componentEvent );
				fireOnComponentDeleted( componentEvent );
			}
		}
	}
}

String Component::toString()
{
	String result = "";
	//ComponentDTD dtd;
	//result += dtd.toString() + "\n";
	result += "<object class=\"" + this->getClassName() + "\"> \n";
	Class* clazz = this->getClass();
	if ( NULL != clazz ){
		Enumerator<Property*>* props =  clazz->getProperties();		
		
		while ( props->hasMoreElements() ){
			Property* p = props->nextElement();
			result += "\t" + p->toString() + "\n";
		}
	}
	result += "</object>";
	return result;
}

ComponentState Component::getComponentState()
{
	return this->m_componentState;
}

void Component::setComponentState( const ComponentState& componentState )
{
	this->m_componentState = componentState;
	std::vector<Component*>::iterator it = this->m_components.begin();
	while ( it != m_components.end() ){
		Component* child = *it;
		child->setComponentState( m_componentState );
		it ++;
	}
	
	Container* container = dynamic_cast<Container*>(this);
	if ( NULL != container ){
		Enumerator<Control*>* controls = container->getChildren();
		if ( NULL != controls ){
			while ( true == controls->hasMoreElements() ){
				Control* control = controls->nextElement();
				control->setComponentState( m_componentState );
			}
		}
	}
}

void Component::addComponent( Component* component )
{
	m_components.push_back( component );
	std::vector<Component*>::iterator it = this->m_components.begin();
}

void Component::removeComponent( Component* component )
{
	std::vector<Component*>::iterator found  = std::find( m_components.begin(), m_components.end(), component );
	if ( found != m_components.end() ){
		m_components.erase( found );
	}
}

Enumerator<Component*>* Component::getComponents()
{
	return m_componentContainer.getEnumerator();
}

unsigned long Component::getComponentCount()
{
	return m_components.size();
}

Component* Component::findComponent( const String& componentName ){
	Component* result = NULL;
	//this is very slow !! for the moment !
	std::vector<Component*>::iterator it = this->m_components.begin();
	while ( it != m_components.end() ){
		Component* child = *it;
		if ( child->getName() == componentName ){
			result = child;
			break;
		}
		it ++;
	}

	return result;
}

/**
*this is a recursive funtion to try and bind a variable name with a particular 
*component. This is potentially a fairly expensize operation, because we have to 
*recursively search through all the components of the starting component, and 
*then through all of it's child controls if the component is a Control Container.
*/
bool Component::bindVariable( Component** variablePtr, const String& variableName )
{	
	*variablePtr = NULL;
	
	bool result = (variableName == getName());
	if ( true == result ) {
		*variablePtr = this;
	}
	if ( false == result ) {
		/**
		*search components first
		*if that fails then try controls - if we are a container
		*/		
		Enumerator<Component*>* components = this->getComponents();
		while ( true == components->hasMoreElements() ) {
			Component* component = components->nextElement();
			if ( variableName == component->getName() ) {
				*variablePtr = component;
				result = true;
			}
			else {
				result = component->bindVariable( variablePtr, variableName );
			}
			if ( true == result ) {
				break;
			}
		}
		
		if ( false == result ) {
			Container* container = dynamic_cast<Container*>(this);
			if ( NULL != container ){
				//need to do a recursive search until we find a match or run out of
				//components to look for
				Enumerator<Control*>* controls = container->getChildren();
				while ( true == controls->hasMoreElements() ) {
					Control* control = controls->nextElement();
					if ( variableName == control->getName() ) {
						result = true;
						*variablePtr = control;
					}
					else {
						result = control->bindVariable( variablePtr, variableName );
					}
					if ( true == result ) {
						break;
					}
				}
			}
		}
	}
	return result;
}

bool Component::registerComponent( const String& componentClassName, const String& category )
{	
	bool result = false;
	ClassRegistry* classRegistry = ClassRegistry::getClassRegistry();
	Class* componentClass = classRegistry->getClass( componentClassName );
	if ( NULL != componentClass ){
		std::map<String,std::vector<Class*>*>::iterator found = registeredComponentMap->find( category );
		std::vector<Class*>* categoryList = NULL;
		if ( found == registeredComponentMap->end() ){
			categoryList = new std::vector<Class*>();
			registeredCategory->push_back( category );
		}
		else {
			categoryList = found->second;
		}
		if ( NULL != categoryList ){
			categoryList->push_back( componentClass );
			(*Component::registeredComponentMap)[category] = categoryList;			
			result = true;
		}		
	}

	return result;
}

Enumerator<Class*>* Component::getComponentClassesForCategory( const String& category )
{
	Enumerator<Class*>* result = NULL;
	//registeredCompContainer
	std::map<String,std::vector<Class*>*>::iterator found = registeredComponentMap->find( category );
	if ( found != registeredComponentMap->end() ){
		std::vector<Class*>* categoryList = found->second;
		if ( NULL != categoryList ){
			registeredCompContainer->initContainer( *categoryList );
			result = registeredCompContainer->getEnumerator();
		}
	}
	return result;
}

Enumerator<String>* Component::getRegisteredComponentCategories()
{
	registeredCategoryContainer->initContainer( *registeredCategory );
	return registeredCategoryContainer->getEnumerator();
}

void Component::initComponentRegistrar()
{
	registeredComponentMap = new std::map<String,std::vector<Class*>*>();
	registeredCategory = new std::vector<String>();
	registeredCategoryContainer = new EnumeratorContainer<std::vector<String>,String>();
	registeredCompContainer = new EnumeratorContainer<std::vector<Class*>,Class*>();
}

void Component::clearRegistedComponents()
{
	std::map<String,std::vector<Class*>*>::iterator it = registeredComponentMap->begin();
	while ( it != registeredComponentMap->end() ){
		std::vector<Class*>* compList = it->second;
		delete compList;
		compList = NULL;
		it++;
	}
	registeredComponentMap->clear();

	registeredCategory->clear();

	delete registeredCategoryContainer;
	registeredCategoryContainer = NULL;

	delete registeredCompContainer;
	registeredCompContainer = NULL;

	delete registeredComponentMap;
	registeredComponentMap = NULL;

	delete registeredCategory;
	registeredCategory = NULL;
}


/**
*ComponentDTD methods
*/

String ComponentDTD::toString()
{
	String result = "";	
	result += "<!--what follows is the DTD for Framework UI Objects-->\n";
	result += "<!DOCTYPE object [ \n";
	result += "<!ELEMENT object ((property*) | children)> \n";
	result += "<!ELEMENT children (object*)> \n";
	result += "<!ATTLIST object	class	CDATA 	#REQUIRED \n";
	result += "\t\t\t classID CDATA #IMPLIED> \n";
	result += "<!ELEMENT property EMPTY>\n";
	result += "<!ELEMENT objectProperty (property*)>\n";
	result += "<!ATTLIST property \n";
	result += "\t\t\t name CDATA #REQUIRED \n";
	result += "\t\t\t value CDATA #REQUIRED>\n";
	result += "]>\n";
	result += "<!--end of UI.dtd -->\n";
	return result;
}

