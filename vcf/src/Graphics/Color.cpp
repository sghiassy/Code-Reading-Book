/**
*Copyright (c) 2000-2001, Jim Crafton
*All rights reserved.
*Redistribution and use in source and binary forms, with or without
*modification, are permitted provided that the following conditions
*are met:
*	Redistributions of source code must retain the above copyright
*	notice, this list of conditions and the following disclaimer.
*
*	Redistributions in binary form must reproduce the above copyright
*	notice, this list of conditions and the following disclaimer in 
*	the documentation and/or other materials provided with the distribution.
*
*THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
*AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
*LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
*A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS
*OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
*EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
*PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
*PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
*LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
*SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*NB: This software will not save the world.
*/

/* Generated by Together */
#include "GraphicsKit.h"


using namespace VCF;



Color::Color()
{
	m_r = 0.0;	
	m_g = 0.0;
	m_b = 0.0;
}

Color::Color( const Color& color )
{
	this->m_b = color.m_b;
	this->m_g = color.m_g;
	this->m_r = color.m_r;
}

Color::Color(const float & r, const float & g, const float & b)
{
	this->m_b = b;
	this->m_g = g;
	this->m_r = r;
}

Color::Color(const double & h, const double & s, const double & v)
{
	
}

Color::Color(const double & c, const double & m, const double & y, const double & k)
{

}

Color::Color(const unsigned char & r, const unsigned char & g, const unsigned char & b)
{
	m_r = ((double)r) / 255.0; 
	m_g = ((double)g) / 255.0; 
	m_b = ((double)b) / 255.0; 
}

Color::Color(const unsigned long & color)
{	
#ifdef WIN32 //windows stores its color format in the following scheme 0x00BBGGRR
	m_r = ((unsigned char*)&color)[0] / 255.0;	
	m_g = ((unsigned char*)&color)[1] / 255.0;
	m_b = ((unsigned char*)&color)[2] / 255.0;
#endif
}



void Color::getHSV(double & h, double & s, double & v)
{

}

void Color::getHLS(double & h, double & l, double & s)
{

}

void Color::getCMYK(double & c, double & m, double & y, double & k)
{

}

void Color::getRGB(unsigned char & r, unsigned char & g, unsigned char & b)
{
	r = (unsigned char)(m_r * 255);
	g = (unsigned char)(m_g * 255);
	b = (unsigned char)(m_b * 255);
}

void Color::getRGB(double & r, double & g, double & b)
{
	r = this->m_r;
	g = this->m_g;
	b = this->m_b;
}

unsigned long Color::getRGB()   
{	
	unsigned long rgb = 0;
#ifdef WIN32 //windows stores its color format in the following scheme ox00BBGGRR
	((unsigned char*)(&rgb))[0] = (unsigned char)(m_r * 255);
	((unsigned char*)(&rgb))[1] = (unsigned char)(m_g * 255);
	((unsigned char*)(&rgb))[2] = (unsigned char)(m_b * 255);

#endif
	return rgb;
}

void Color::getLab()
{

}

void Color::getYUV()
{

}


void Color::setHSV( const double & h, const double & s, const double & v)
{

}

void Color::setHLS( const double & h, const double & l, const double & s)
{

}

void Color::setCMYK( const double & c, const double & m, const double & y, const double & k)
{

}

void Color::setRGB( const unsigned char & r, const unsigned char & g, const unsigned char & b)
{
	m_r = ((double)r) / 255.0; 
	m_g = ((double)g) / 255.0; 
	m_b = ((double)b) / 255.0; 
}

void Color::setRGB( const double & r, const double & g, const double & b)
{
	this->m_b = b;
	this->m_g = g;
	this->m_r = r;
}

void Color::setRGB( const unsigned long& rgb )
{
#ifdef WIN32 //windows stores its color format in the following scheme 0xBBGGRR
	m_r = ((unsigned char*)&rgb)[0] / 255.0;	
	m_g = ((unsigned char*)&rgb)[1] / 255.0;
	m_b = ((unsigned char*)&rgb)[2] / 255.0;
#endif
}

void Color::setLab()
{

}

void Color::setYUV()
{

}


void Color::brighter()
{

}


void Color::darker()
{

}

double Color::getRed()
{
	return m_r;
}

double Color::getGreen()
{
	return m_g;
}

double Color::getBlue()
{
	return m_b;
}

void Color::copy( Object* source )
{
	if ( NULL != source ){
		Color* color = dynamic_cast<Color*>(source );
		if ( NULL != color ){
			m_r = color->getRed();
			m_g = color->getGreen();
			m_b = color->getBlue();
		}
	}
}

Color* Color::getColor( const String& colorName )
{
	return GraphicsToolkit::getDefaultGraphicsToolkit()->getColorFromColormap( colorName );
}

void Color::setRed( const double& red )
{
	m_r = red;
}

void Color::setGreen( const double& green )
{
	m_g = green;
}

void Color::setBlue( const double& blue )
{
	m_b = blue;
}