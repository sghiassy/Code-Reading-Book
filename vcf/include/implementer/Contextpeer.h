//ContextPeer.h

/* Generated by Together */


#ifndef CONTEXTPEER_H
#define CONTEXTPEER_H

namespace VCF{


class Font;

class Point;

class StrokeState;

class FontState;

class FillState;

class Image;

class GraphicsContext;

class GRAPHICSKIT_API ContextPeer {
public:
	virtual ~ContextPeer(){};

	virtual void setContext( GraphicsContext* context ) = 0;

	virtual GraphicsContext* getContext() = 0;	

	virtual FontState* getCurrentFontState() = 0;

    virtual void setCurrentFontState( FontState * state ) = 0;
    
	virtual void setCurrentStrokeState( StrokeState * state ) = 0;
    
	virtual void setCurrentFillState( FillState * state ) = 0;

	virtual StrokeState* getCurrentStrokeState() = 0;
    
	virtual FillState* getCurrentFillState() = 0;
	
	virtual long getContextID() = 0;

	virtual void setContextID( const long& contextID ) = 0;

	virtual void drawImage( const double & x, const double & y, Image* image ) = 0;

	virtual void drawImageWithinBounds( Rect* bounds, Image* image ) = 0;

	virtual void drawPartialImage( const double& x, const double& y, Rect* imageBounds, Image* image ) = 0;

	virtual void textAt( const double & x, const double & y, const String & text ) = 0;
    
	virtual void textBoundedBy( Rect* bounds, const String& text, const bool& wordWrap ) = 0;

	virtual void rectangle( const double & x1, const double & y1, 
		                    const double & x2, const double & y2 ) = 0;
    
	virtual double getTextWidth( const String& text ) = 0;

	virtual double getTextHeight( const String& text ) = 0;

	virtual void circle( const double & x, const double & y, const double & radius ) = 0;
    
	virtual void ellipse( const double & x1, const double & y1, 
		                  const double & x2, const double & y2, const double & angle ) = 0;	

    virtual void polyline( std::vector<Point*> & pts ) = 0;
    
	virtual void curve( const double & x1, const double & y1, const double & x2, const double & y2,
                        const double & x3, const double & y3, const double & x4, const double & y4 ) = 0;
    virtual void lineTo( const double & x, const double & y ) = 0;
    
	virtual void moveTo( const double & x, const double & y ) = 0;

    /**
     * Starts a new "path". A path is defined as a collection of points, 
     * from any successive commands like moveTo(), lineTo() etc, until a endPathOPeration() is called. 
     */
    virtual void fillPath() = 0;

    virtual void strokePath() = 0;    

	virtual void setOrigin( const double& x, const double& y ) = 0;

 	virtual Point* getOrigin() = 0;
	
	virtual void copyContext( const double& x, const double& y, ContextPeer* context ) = 0;

	/**
	*is this context Peer in memory or does it associated with a 
	*component ?
	*@return bool true if the context is on memory, otherwise false
	*/
	virtual bool isMemoryContext() = 0;

	/**
	*returns whether or not the XOR Mode is turned on.
	*@return bool if the return is true then the 
	*XOR mode is on, which means that colors are alternated 
	*at the pixel level. Thus a line drawn once, and then
	*a second time at the same coordinates will erase itself
	*/
	virtual bool isXORModeOn() = 0;

	/**
	*Turns the XOR mode on or off.
	*@param bool XORModeOn, if true then turns the XORMode on
	*otherwise if it's false it turns it off.
	*/
	virtual void setXORModeOn( const bool& XORModeOn ) = 0;

	/**
	*this is used to determine how to 
	*align text when the windowing systems
	*draws it. Currently the choices are 2:
	*either it is aligned to the top, or in other 
	*words the coordinates specified represent the 
	*top, left position to start rendering the text,
	*or aligned to the baseline, in which the top, 
	*left coordinates represent the baseline point of 
	*origin. The latter setting is useful when 
	*drawing text whith different font styles
	*/
	virtual void setTextAlignment( const bool& alignTobaseline ) = 0;

	virtual bool isTextAlignedToBaseline() = 0;
};

};


#endif //CONTEXTPEER_H