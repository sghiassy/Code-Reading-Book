/**
*Copyright (c) 2000-2001, Jim Crafton
*All rights reserved.
*Redistribution and use in source and binary forms, with or without
*modification, are permitted provided that the following conditions
*are met:
*	Redistributions of source code must retain the above copyright
*	notice, this list of conditions and the following disclaimer.
*
*	Redistributions in binary form must reproduce the above copyright
*	notice, this list of conditions and the following disclaimer in 
*	the documentation and/or other materials provided with the distribution.
*
*THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
*AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
*LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
*A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS
*OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
*EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
*PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
*PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
*LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
*SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*NB: This software will not save the world.
*/

/* Generated by Together */


#ifndef TABLECONTROL_H
#define TABLECONTROL_H


namespace VCF{

#define DEFAULT_ROW_HEIGHT			20
#define DEFAULT_COLUMN_WIDTH		80
#define TABLECELL_HANDLER			"TableCellHandler"
#define TABLECONTROL_CLASSID		"AC704858-753B-46a7-815B-72C09C884164"

class TableControl;

class TableModel;
class TableModelEvent;
class TableCellItem;
class ItemEvent;
class TableItemEditor;

class APPKIT_API TableControl : public CustomControl, public AbstractContainer{
public:
	BEGIN_CLASSINFO(TableControl, "VCF::TableControl", "VCF::CustomControl", TABLECONTROL_CLASSID );
	END_CLASSINFO(TableControl);

	TableControl( TableModel* model=NULL );

	virtual ~TableControl();

    virtual void paint( GraphicsContext * context );

	void init();

	uint32 getDefaultRowHeight();

	void setDefaultRowHeight( const uint32& defaultRowHeight );

	uint32 getDefaultColumnWidth();

	void setDefaultColumnWidth( const uint32& defaultColumnWidth );

	void setFixedColumn( const bool& isFixed, const uint32& col );

	void setFixedRow( const bool& isFixed, const uint32& row );
	
	void setColumnWidth( const uint32& column, const uint32& width );

	TableModel* getTableModel();

	void setTableModel( TableModel* model );

	void setColumnCount( const uint32& colCount );

	void setRowCount( const uint32& rowCount );

	TableCellItem* getSelectedItem(){
		return m_selectedCellItem;
	}

	void setSelectedItem( TableCellItem* selectedCellItem ){
		m_selectedCellItem = selectedCellItem;
	}

	virtual void mouseDown( MouseEvent* event );

	virtual void mouseMove( MouseEvent* event );

	virtual void mouseUp( MouseEvent* event );

	virtual void mouseDblClick(  MouseEvent* event );

	void OnMouseDblClick( MouseEvent* event );

	virtual void setBounds( Rect* rect, const bool& anchorDeltasNeedUpdating=true ) throw( InvalidPeer );
	
	void setAutoResizeColumns( const bool& autoResizeColumns );

	bool getAutoResizeColumns(){
		return m_autoResizeColumns;
	}

protected:
	void onTableModelChanged( TableModelEvent* event );
	void onTableCellItemSelected( ItemEvent* event );
	void onTableModelEmptied( ModelEvent* e );
	void onEditingControlKeyPressed( KeyboardEvent* event );

	void finishEditing();

private:
	std::vector<uint32> m_columnWidths;
	std::vector<uint32> m_rowHeights;
	TableModel* m_model;
	uint32 m_defaultColumnWidth;
	uint32 m_defaultRowHeight;
	TableCellItem* m_selectedCellItem;	
	Control* m_currentEditingControl;
	TableItemEditor* m_currentItemEditor;
	bool m_autoResizeColumns;
	void resetColumnWidths();
	bool m_columnResizing;
	Point m_resizeDragPt;
	uint32 m_dragColumnWidth;

	Rect getBoundsForItem( TableCellItem* item );
};

};
#endif //TABLECONTROL_H