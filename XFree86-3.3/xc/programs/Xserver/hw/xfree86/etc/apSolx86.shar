#!/bin/sh
# $XFree86: xc/programs/Xserver/hw/xfree86/etc/apSolx86.shar,v 3.4 1996/12/23 06:47:07 dawes Exp $
# This is a shell archive (produced by shar 3.49)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 09/25/1994 14:29 UTC by davidh@barite
# Source directory /usr10/davidh/aperture
#
# $XConsortium: apSolx86.shar /main/4 1996/02/21 17:47:22 kaleb $
#
# existing files will NOT be overwritten unless -c is specified
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#   1342 -rw-r--r-- aperture/Makefile
#   4042 -rw-r--r-- aperture/aperture.h
#     95 -rw-r--r-- aperture/devlink.tab
#   2914 -rw-r--r-- aperture/README
#  20528 -rw-r--r-- aperture/aperture.c
#    518 -rw-r--r-- aperture/aperture.conf
#   3530 -rw-r--r-- aperture/aptest.c
#   2174 -rw-r--r-- aperture/DISCLAIMER
#
# ============= aperture/Makefile ==============
if test ! -d 'aperture'; then
    echo 'x - creating directory aperture'
    mkdir 'aperture'
fi
if test -f 'aperture/Makefile' -a X"$1" != X"-c"; then
	echo 'x - skipping aperture/Makefile (File already exists)'
else
echo 'x - extracting aperture/Makefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'aperture/Makefile' &&
#
#   File: makefile for aperture Framebuffer Driver
# Author: Doug Anson (danson@lgc.com)
#   Date: 2/15/94
# Modified: David Holland (davidh@use.com)
#   Date: 2/23/94
#   - Changed name, and debugging structure
#
# $Id
#
# Debug flags may be set to the following values:
#
# APERTURE_DEBUG = 1 -- basic log reporting (mininal)
# APERTURE_DEBUG = 2 -- more log reporting (mmap results)
# APERTURE_DEBUG = 3 -- verbose log reporting (kernel entry points)
#
X
#
# GNU gcc compiler (2.4.5 or 2.5.8)
CC=gcc
CFLGS=-fno-builtin
X
#
# Proworks compiler (untested!)
#CC= /opt/SUNWspro/bin/cc 
#CFLGS=-Xa
X
#
# location of lint program (untested!)
LINT= /usr/opt/SUNWspro/bin/lint
X
#
# Debug error reporting 
#DEBUG_FLG=
#DEBUG_FLG=-DAPERTURE_DEBUG=1
#DEBUG_FLG=-DAPERTURE_DEBUG=2
DEBUG_FLG=-DAPERTURE_DEBUG=3
X
#
# Files and object declarations
KERNEL_FLGS=-D_KERNEL -DSUNDDI -I.
CFLAGS= $(CFLGS) $(KERNEL_FLGS) $(DEBUG_FLG)
CFILES= aperture.c
HEADERS= aperture.h
OBJS= aperture.o
DRIVER= aperture
APTEST= aptest
APTESTOBJ= aptest.o
X
# 
# Make rules
all:	aperture aptest
X
aperture: $(OBJS)
X	ld -r -o aperture aperture.o
X
install: aperture aptest
X	cp aperture aperture.conf /kernel/drv
X
aptest: $(APTESTOBJ)
X	$(CC) -o $(APTEST) $(APTESTOBJ)
X
clean:
X	rm -f *% *.BAK $(OBJS) $(APTESTOBJ) $(APTEST) $(DRIVER) core
X
lint:
X	$(LINT) -D_KERNEL -x -u $(CFILES)
SHAR_EOF
chmod 0644 aperture/Makefile ||
echo 'restore of aperture/Makefile failed'
Wc_c="`wc -c < 'aperture/Makefile'`"
test 1342 -eq "$Wc_c" ||
	echo 'aperture/Makefile: original size 1342, current size' "$Wc_c"
fi
# ============= aperture/aperture.h ==============
if test -f 'aperture/aperture.h' -a X"$1" != X"-c"; then
	echo 'x - skipping aperture/aperture.h (File already exists)'
else
echo 'x - extracting aperture/aperture.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'aperture/aperture.h' &&
/*
X * Copyright 1994  	Doug Anson, danson@lgc.com & David Holland, davidh@use.com
X *
X * File:   aperture.h
X * Author: Doug Anson
X * Date:   1/31/94
X *
X * Modified: David Holland (davidh@use.com)
X * Log:		 Modified for new name		2/23/9
X *
X * Purpose: This header is the master header for the Solaris 2.1 x86
X *          framebuffer mmap driver. Portions of this driver are taken
X *          from mmapio.h 1.4 copyright 93/06/03 Sun  Microsystems, Inc.
X *
X * Disclamer:
X *
X * This code is based largely upon the sample device drivers provided
X * by Sun Microsystems Inc.
X * 
X * Original copyright notice:
X * @(#)mmapio.h 1.4 copyright 93/06/03 Sun Microsystems, Inc.
X *
X * Our copyright notice:
X * Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of Doug Anson, and David Holland be used in
X * advertising or publicity pertaining to distribution of the software 
X * Doug Anson, and David Holland make no * representations about the 
X * suitability of this software for any purpose.
X * It is provided "as is" without express or implied warranty.
X *
X * Original disclamer from Sun Microsystems, Inc.:
X * This is a package of sample device drivers for Solaris 2.x (SunOS
X * 5.x).  You may use, modify and distribute these drivers and/or binaries
X * derived from them. However please note that:
X * 
X * These examples are provided with no warranties of any kind, including
X * without limitation accuracy and usefulness, and Sun expressly disclaims
X * all implied warranties of merchantability, fitness for a particular
X * purpose and non-infringement. In no event shall Sun be liable for any
X * damages, including without limitation, direct, special, indirect, or
X * consequential damages arising out of, or relating to, use of these
X * examples by customer or any third party. Sun is under no obligation to
X * provide support to customer for this software.
X * 
X * Our disclaimer:
X * DOUG ANSON, AND DAVID HOLLAND DISCLAIMS ALL WARRIENTS WITH REGARD TO THIS 
X * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, AND FITNESS, 
X * IN NO EVENT SHALL DOUG ANSON, OR DAVID HOLLAND BE LIABLE FOR ANY SPECIAL, 
X * INDIRECT, OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM 
X * USAGE OF THIS SOFTWARE.
X */
X
/*
X * linear framebuffer aperture driver header file
X * 
X * $Id
X */
X
#ifndef APERTURE_H
#define APERTURE_H
X
/*
X * Framebuffer identification definitions 
X */
#define APERTURE_NAME 		"aperture"
#define DEV_BANNER_STRING	"SVGA Framebuffer Driver v0.99"
#define DEV_IDENT_STRING	APERTURE_NAME	
X
/*
X * driver.conf(4) "reg" property definition for aperture driver: 
X * FORMAT:	reg=AP_REGNUM,AP_ADDR,AP_SIZE
X */
#define AP_REGNUM	0		/* register number is 1st number in "reg" prop */
#define AP_ADDR		1		/* fb base address is 2nd number in "reg" prop */
#define AP_SIZE		2		/* fb length value is 3rd number in "reg" prop */
#define AP_MAX		3		/* number of values in "reg" property		   */
X
/*
X * How big a chunk of register we map with each ddi_map_regs(9F)
X */
#define AP_MEM_CHUNK			sizeof(int)
X
/*
X * Error value for mmap(2) failure status 
X */
#define AP_MEM_FAILURE	-1
X
/*
X * Main memory map structure for the Framebuffer mmap driver
X */
struct mmap 
{
X	u_int			 regnum;		/* registers number			   	   */
X	volatile caddr_t regbase;		/* base address of device to mmap  */
X	off_t		     regsize;		/* length of region to mmap(2)	   */
X	off_t			 reglength;		/* map length for ddi_map_regs(9F) */
X	volatile caddr_t kaddr;			/* kernel address of mapped device */
X	off_t			 off;			/* offset from mmap(2) call		   */
X	volatile off_t   mapaddr;		/* base address of mmap(2) region  */
X	kmutex_t		 map_lock;		/* device map mutex lock		   */
X	dev_info_t	     *dip;			/* device information pointer	   */
};
typedef struct mmap Mmap;
X
#endif /* APERTURE_H */
SHAR_EOF
chmod 0644 aperture/aperture.h ||
echo 'restore of aperture/aperture.h failed'
Wc_c="`wc -c < 'aperture/aperture.h'`"
test 4042 -eq "$Wc_c" ||
	echo 'aperture/aperture.h: original size 4042, current size' "$Wc_c"
fi
# ============= aperture/devlink.tab ==============
if test -f 'aperture/devlink.tab' -a X"$1" != X"-c"; then
	echo 'x - skipping aperture/devlink.tab (File already exists)'
else
echo 'x - extracting aperture/devlink.tab (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'aperture/devlink.tab' &&
# The following entry is for the SVGA framebuffer driver
type=ddi_pseudo;name=aperture	fbs/\M0
SHAR_EOF
chmod 0644 aperture/devlink.tab ||
echo 'restore of aperture/devlink.tab failed'
Wc_c="`wc -c < 'aperture/devlink.tab'`"
test 95 -eq "$Wc_c" ||
	echo 'aperture/devlink.tab: original size 95, current size' "$Wc_c"
fi
# ============= aperture/README ==============
if test -f 'aperture/README' -a X"$1" != X"-c"; then
	echo 'x - skipping aperture/README (File already exists)'
else
echo 'x - extracting aperture/README (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'aperture/README' &&
Framebuffer apperture driver.
X
(Note, see the DISCLAIMER file before using this driver!
X  - Sorry, we've gotta cover ourselves)
X
This driver was written to help work around one particular limitation in the
x86 /dev/mem driver.
X
1) No Solaris x86 device we've found allows access to memory regions that 
X   exist above the amount of RAM in the machine.  So one could not 
X   access the linear frame buffer of a Mach32 VLB board that decodes
X   is memory aperture at the 124Megabyte mark.
X
This driver attempts to work around some of those problems. All it simply
does is allow a user to mmap() any physical address less than 128Megs
back into user address space. 
X
It is the corroborative work of Doug Anson (danson@lgc.com), and 
David Holland (davidh@use.com).
X
Many thanks to the XFree86[tm] Alpha, and Beta teams, for without 
all their hard work, there wouldn't be any need for this driver.
X
Installation instructions:
X
1) Check the Makefile, for appropriate CC, and CFLAGS defintions.
X   Compiling with APERTURE_DEBUG defined (via -DAPERTURE_DEBUG=?) means 
X   the driver will generate reams of debugging output.  You'll probably 
X   want to leave this off, or set to zero..
X
2) type 'make'.  The driver and test program should compile with out any
X   problems.  There also should not be any warning messages.
X
3) Become 'root'.
X
4) type 'make install' and run 'add_drv /kernel/drv/aperture'.
X   The screen should look something like this:
X
X	# make install
X	cp aperture aperture.conf /kernel/drv
X	# add_drv /kernel/drv/aperture
X
X   This installs the driver in the system. 
X
5) While as root modify the file /etc/devlink.tab, adding these lines:
X
# The following entry is for the SVGA framebuffer driver
type=ddi_pseudo;name=aperture	fbs/\M0
X
X   Add that line exactly as shown. You may also simply add the 
X   contents of the devlink.tab file supplied to /etc/devlink.tab.
X   It contains the lines as well.  (Yes, that is a tab between
X   aperture, and fbs, not spaces - very important)
X
6) Perform a reconfiguration boot of the system.
X
X	# touch /reconfigure
X	# init 6
X
7) Login as root and run the aptest program. It tests that the 
X   mmap driver is working properly, by mmaping the main bios
X   into user address space.  If you happen to have AMI bios the
X   output will look something like so:
X
# ./aptest
NOTICE: BIOS mapped [0xf0000 ,size=4096) to addr=0x8000b000...
0123AAAAMMMMIIII05/05/91(C)1990 American Megatrends Inc., All Rights Reserved
DONE displaying memory contents (80 bytes)
UNMAPPING [0xf0000 ,size=4096) to addr=0x8000b000... and closing...DONE.
Exiting successful...
#
X
X
8) Nope, there are not any man pages, I don't know nroff.  As for programming
X   suggestions, take a look at aptest.c a working example is obviously
X   in there.
X
Bug reports, questions, suggestions, etc can be sent to 
X
Doug Anson
danson@lgc.com
X
X or
X
David Holland
davidh@use.com
X
Flames can be sent to 
/dev/null
SHAR_EOF
chmod 0644 aperture/README ||
echo 'restore of aperture/README failed'
Wc_c="`wc -c < 'aperture/README'`"
test 2914 -eq "$Wc_c" ||
	echo 'aperture/README: original size 2914, current size' "$Wc_c"
fi
# ============= aperture/aperture.c ==============
if test -f 'aperture/aperture.c' -a X"$1" != X"-c"; then
	echo 'x - skipping aperture/aperture.c (File already exists)'
else
echo 'x - extracting aperture/aperture.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'aperture/aperture.c' &&
/*
X * Copyright 1994  	Doug Anson, danson@lgc.com & David Holland, davidh@use.com
X *
X * File:   aperture.c
X * Author: Doug Anson (danson@lgc.com)
X * Date:   1/31/94
X * 
X * Modified: David Holland (davidh@use.com)
X * Date:     2/23/94
X * Changes: Changed general name of driver
X * 			Debugging flags
X * 			Removed a few extraneous erorr messages.
X * 		
X *
X * Purpose: This file is the master device file for the Solaris 2.1 x86
X *          framebuffer aperture driver. Portions of this driver are taken
X *          from mmap.c 1.4 copyright 93/06/03 Sun  Microsystems, Inc.
X *          (Sample memory mapped driver for Solaris 2.0/Sun OS 5.0)
X *
X *      	This driver allows accelerated SVGA graphics cards that are
X *			attached vi 32-bit paths (VESA/EISA/MC) and that have 
X *			linear framebuffer capabilities to have their framebuffer
X *			memory mapped into the user process space.
X *
X * Disclamer:
X *
X * This code is based largely upon the sample device drivers provided
X * by Sun Microsystems Inc.
X * 
X * Original copyright notice:
X * @(#)mmap.c     1.3 copyright 93/06/03 Sun Microsystems, Inc.
X *
X * Our copyright notice:
X * Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of Doug Anson, and David Holland be used in
X * advertising or publicity pertaining to distribution of the software 
X * Doug Anson, and David Holland make no * representations about the 
X * suitability of this software for any purpose.
X * It is provided "as is" without express or implied warranty.
X *
X * Original disclamer from Sun Microsystems, Inc.:
X * This is a package of sample device drivers for Solaris 2.x (SunOS
X * 5.x).  You may use, modify and distribute these drivers and/or binaries
X * derived from them. However please note that:
X * 
X * These examples are provided with no warranties of any kind, including
X * without limitation accuracy and usefulness, and Sun expressly disclaims
X * all implied warranties of merchantability, fitness for a particular
X * purpose and non-infringement. In no event shall Sun be liable for any
X * damages, including without limitation, direct, special, indirect, or
X * consequential damages arising out of, or relating to, use of these
X * examples by customer or any third party. Sun is under no obligation to
X * provide support to customer for this software.
X * 
X * Our disclaimer:
X * DOUG ANSON, AND DAVID HOLLAND DISCLAIMS ALL WARRIENTS WITH REGARD TO THIS 
X * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, AND FITNESS, 
X * IN NO EVENT SHALL DOUG ANSON, OR DAVID HOLLAND BE LIABLE FOR ANY SPECIAL, 
X * INDIRECT, OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM 
X * USAGE OF THIS SOFTWARE.
X */
X
/*
X * linear framebuffer aperture driver
X * 
X * $Id
X */
X
#include <sys/types.h>
#include <sys/param.h>
#include <sys/errno.h>
#include <sys/file.h>
#include <sys/conf.h>
#include <sys/uio.h>
#include <sys/map.h>
#include <sys/debug.h>
#include <sys/modctl.h>
#include <sys/kmem.h>
#include <sys/cmn_err.h>
#include <sys/open.h>
#include <sys/stat.h>
#include <sys/ddi.h>
#include <sys/sunddi.h>
X
#include "aperture.h"
X
/* opaque handle top of state structs */
static	void *state_head = NULL;
X
/* 
X * Solaris DDI/DKI driver entry points
X */
#if defined(__STDC__)
static	int	aperture_getinfo(dev_info_t *, ddi_info_cmd_t, void *,void **);
static	int	aperture_identify(dev_info_t *dip);
static  int aperture_probe(dev_info_t *dip);
static	int	aperture_attach(dev_info_t *, ddi_attach_cmd_t);
static	int	aperture_open(dev_t *, int, int, cred_t *);
static	int	aperture_close(dev_t, int, int, cred_t *);
static	int	aperture_detach(dev_info_t *, ddi_detach_cmd_t);
static	int	aperture_mmap(dev_t, off_t, int);
#else
static  int	aperture_getinfo();
static  int	aperture_identify();
static  int	aperture_probe();
static  int	aperture_attach();
static  int	aperture_open();
static  int	aperture_close();
static  int	aperture_detach();
static  int	aperture_mmap();
#endif /* __STDC__ */
X
/*
X * Solaris DDI/DKI module linkeage structure declarations
X */
static struct cb_ops	aperture_cb_ops = 
{
X	aperture_open,			/* XXopen routine						*/
X	aperture_close,			/* XXclose routine						*/
X	nodev,					/* XXstrategy routine					*/
X	nodev,					/* XXprint routine	    				*/
X	nodev,					/* XXdump routine	    				*/
X	nodev,					/* XXread routine	    				*/
X	nodev,					/* XXwrite routine 						*/
X	nodev,					/* XXioctl routine 						*/
X	nodev,					/* XXdevmap routine						*/
X	aperture_mmap,			/* XXmmap routine						*/
X	ddi_segmap,				/* XXsegmap routine						*/
X	nochpoll,				/* XXchpoll routine						*/
X	ddi_prop_op,			/* XXprop_op routine					*/	
X	(struct streamtab *)0,	/* not a STREAMS driver				 	*/
X	D_NEW | D_MP,			/* safe for multi-thread/multi-processor*/
};
X
static struct dev_ops aperture_ops = 
{
X	DEVO_REV,				/* DEVO_REV indicated by manual		*/
X	0,						/* device reference count	    	*/
X	aperture_getinfo,		/* devo_getinfo routine				*/
X	aperture_identify,		/* devo_identiry routine			*/
X	aperture_probe,			/* device probe for non-self-id 	*/
X	aperture_attach,		/* devo_attach routine				*/
X	aperture_detach,		/* devo_detach routine				*/
X	nodev,					/* device reset routine				*/
X	&aperture_cb_ops,		/* cb_ops structure pointer			*/
X	(struct bus_ops *)0,	/* bus operations					*/
};
X
extern	struct	mod_ops mod_driverops;
static	struct modldrv modldrv = 
{
X	&mod_driverops,					/* mod_ops structure pointer 	*/
X	DEV_BANNER_STRING,				/* device banner string			*/
X	&aperture_ops,					/* dev_ops structure pointer 	*/
};
X
static	struct modlinkage modlinkage = 
{
X	MODREV_1,			/* as indicated indicated by manual 	 		*/
X	(void *)&modldrv,	/* module driver structure pointer				*/
X	NULL,				/* termination of list of linkage structures 	*/
};
X
/*
X * Function: _init()
X * Purpose:  Solaris DDI/DKI _init(9E) entry point
X * Author:   Doug Anson
X * Calls:     
X * Log:		DMA -- Origional Version
X * 		DWH - Removed extra cmn_err() calls 	2/23/94
X * 		DWH - Changed debugging 		2/23/94
X */
#if defined(__STDC__)
int _init(void)
#else
int _init()
#endif /* __STDC__ */
{
X	register int	error;
X
#if APERTURE_DEBUG >= 3
X
X        /* enterance announcement */
X        cmn_err(CE_CONT,"%s: entering _init(aperture)\n", DEV_IDENT_STRING);
X
#endif
X
X	if ((error = ddi_soft_state_init(&state_head, sizeof (Mmap), 1)) != 0)
X	{
X		/* failed to get state structure */
X		return (error);
X	}
X
X	if ((error = mod_install(&modlinkage)) != 0)
X		ddi_soft_state_fini(&state_head);
X
X	return (error);
}
X
/*
X * Function: _info()
X * Purpose:  Solaris DDI/DKI _info(9E) entry point
X * Author:   Doug Anson
X * Calls:     
X * Modified: David Holland (davidh@use.com)
X * Log:      DMA -- Origional Version
X * 			 DWH - Changed debugging 	2/23/94
X */
#if defined(__STDC__)
int _info(struct modinfo *modinfop)
#else
int _info(modinfop)
struct modinfo *modinfop;
#endif /* __STDC__ */
{
X
#if APERTURE_DEBUG >= 3
X
X	/* entrance announcement */
X	cmn_err(CE_CONT,"%s: entering _info(aperture)\n", DEV_IDENT_STRING);
X
#endif /* APERTURE_DEBUG >= 3 */
X
X	return (mod_info(&modlinkage, modinfop));
}
X
/*
X * Function: _fini()
X * Purpose:  Solaris DDI/DKI _fini(9E) entry point
X * Author:   Doug Anson
X * Calls:     
X * Modified: David Holland (davidh@use.com)
X * Log:      DMA -- Origional Version
X * 			 DWH - Changed debugging
X */
#if defined(__STDC__)
int _fini(void)
#else
int _fini()
#endif /* __STDC__ */
{
X	int status;
X
#if APERTURE_DEBUG >= 3
X
/* entrance announcement */
cmn_err(CE_CONT,"%s: entering _fini(aperture)\n", DEV_IDENT_STRING);
X
#endif /* APERTURE_DEBUG >= 3*/
X
X	if ((status = mod_remove(&modlinkage)) != 0)
X		return (status);
X
X	ddi_soft_state_fini(&state_head);
X
X	return (status);
}
X
/*
X * Function: aperture_getinfo()
X * Purpose:  This function provides the getinfo(9E) functionality 
X * Author:   Doug Anson
X * Calls:     
X * Modified: David Holland (davidh@use.com)
X * Log:      DMA -- Origional Version
X * 			 DWH - Changed function name/variables/debugging	2/23/94
X */
#if defined(__STDC__)
static int aperture_getinfo(dev_info_t *dip, ddi_info_cmd_t infocmd, 
X						  void *arg, void **result)
#else
static int aperture_getinfo(dip,infocmd,arg,result)
dev_info_t     *dip;
ddi_info_cmd_t infocmd;
void           *arg;
void           **result;
#endif /* __STDC__ */
{
X	register int 	error;
X	register Mmap	*aperture_p = NULL;
X
#if APERTURE_DEBUG >= 3
X
X        /* enterance announcement */
X        cmn_err(CE_CONT,"%s: entering aperture_getinfo()\n", DEV_IDENT_STRING);
X
#endif
X
X	switch (infocmd) 
X	{
X	    case DDI_INFO_DEVT2DEVINFO:
X			aperture_p = (Mmap *)ddi_get_soft_state(state_head, getminor((dev_t)arg));
X			if (aperture_p == NULL) 
X			{
X				/* could not get state structure */
X				*result = NULL;
X				error = DDI_FAILURE;
X			} 
X			else 
X			{
X				/* got state structure */
X				*result = aperture_p->dip;
X				error = DDI_SUCCESS;
X			}
X			break;
X		case DDI_INFO_DEVT2INSTANCE:
X			*result = (void *)getminor((dev_t)arg);
X			error = DDI_SUCCESS;
X			break;
X		default:
X			*result = NULL;
X			error = DDI_FAILURE;
X			break;
X	}
X	return (error);
}
X
/*
X * Function: aperture_identify()
X * Purpose:  This function implements the identify(9E) functionality
X * Author:   Doug Anson
X * Calls:     
X * Modified: David Holland (davidh@use.com)
X * Log:      DMA -- Origional Version
X * 			 DWH - Changed function name/debugging/variables	2/23/94
X */
#if defined(__STDC__)
static int aperture_identify(dev_info_t *dip)
#else
static int aperture_identify(dip)
dev_info_t *dip;
#endif /* __STDC__ */
{
#if APERTURE_DEBUG >= 3
X
X        /* entrance announcement */
X        cmn_err(CE_CONT,"%s: entering aperture_identify()\n", DEV_IDENT_STRING);
X
#endif 
X
X	/* check the driver name and respond */
X	if (strcmp(ddi_get_name(dip), APERTURE_NAME) == 0)
X		return (DDI_IDENTIFIED); 		/* device driver is identified */
X	else
X		return (DDI_NOT_IDENTIFIED);	/* device driver not identified */
}
X
/*
X * Function: aperture_probe()
X * Purpose:  This function implements the probe(9E) functionality.
X *		     Currently this function returns a "dont care" result
X *			 as nothing is probed.
X * Author:   Doug Anson
X * Calls:     
X * Modfied:	 David Holland (davidh@use.com)
X * Log:      DMA -- Origional Version
X * 			 DWH - changed function name/variables/debugging	2/23/94
X */
#if defined(__STDC__)
static int aperture_probe(dev_info_t *dip)
#else
static int aperture_probe(dip)
dev_info_t *dip;
#endif /* __STDC__ */
{
X
#if APERTURE_DEBUG >= 3
X
X        /* enterance announcement */
X        cmn_err(CE_CONT,"%s: entering aperture_probe()\n", DEV_IDENT_STRING);
X
#endif
X
X	/* return success as we really aren't probing for anything */
X	return (DDI_PROBE_SUCCESS);
}
X
/*
X * Function: aperture_attach()
X * Purpose:  This function implements the attach(9E) functionality
X * Author:   Doug Anson
X * Calls:     
X * Modified: David Holland (davidh@use.com)
X * Log:      DMA -- Origional Version
X * 			 DWH - changed function name/variables/debugging	2/23/94
X */
#if defined(__STDC__)
static int aperture_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
#else
static int aperture_attach(dip,cmd)
dev_info_t       *dip;
ddi_attach_cmd_t cmd;
#endif /* __STDC__ */
{
X	register Mmap  *aperture_p = NULL;
X	int			   buf[AP_MAX];
X	int			   length;
X	int			   instance;
X
#if APERTURE_DEBUG >= 3
X
X        /* entrance announcement */
X        cmn_err(CE_CONT,"%s: entering aperture_attach()\n", DEV_IDENT_STRING);
X
#endif
X
X	/* only continue if doing a DDI_ATTACH */
X	if (cmd == DDI_ATTACH)
X	{
X		/* get and initialize our state structure */
X		instance = ddi_get_instance(dip);
X		if (ddi_soft_state_zalloc(state_head, instance) != DDI_SUCCESS)
X		{
X			/* could not allocate state structure */
X			return (DDI_FAILURE);
X		}
X
X		/* get the state structure */
X		aperture_p = (Mmap *)ddi_get_soft_state(state_head, instance);
X
X		if (aperture_p == NULL)
X		{
X			/* failed to get the soft state */
X			return (DDI_FAILURE);
X		}
X
X		/* initialize the mutex driver (ATOMIC) */
X		mutex_init(&aperture_p->map_lock, "apperture mmap lock", MUTEX_DRIVER, 0);
X
X		/* ENTER the critical region */
X		mutex_enter(&aperture_p->map_lock);
X		
X		/* get the "reg" property from the .conf file */
X		length = sizeof(buf);
X		if (ddi_getlongprop_buf(DDI_DEV_T_ANY, dip, DDI_PROP_DONTPASS, "reg", (caddr_t)buf, &length) != DDI_PROP_SUCCESS)
X		{
X			/* could not get the framebuffer properties */
X			return (DDI_FAILURE);
X		}
X
X		/* remember our register configuration */
X        aperture_p->regnum  = (u_int)buf[AP_REGNUM];
X        aperture_p->regbase = (caddr_t)buf[AP_ADDR];
X        aperture_p->regsize = (off_t)buf[AP_SIZE];
X
X		/* initialize the mmap state info */
X		aperture_p->reglength = (off_t)AP_MEM_CHUNK;
X		aperture_p->kaddr	 = (caddr_t)0;
X        aperture_p->off     = (off_t)0;
X        aperture_p->mapaddr = AP_MEM_FAILURE;
X
X		/* initialize internal accounting */
X        aperture_p->dip     = dip;
X
X		/* EXIT the critical region */
X		mutex_exit(&aperture_p->map_lock);
X
X		/* create the device node */
X		/* DDI_PSEUDO, CLONE_DEV */
X		if (ddi_create_minor_node(dip, ddi_get_name(dip), S_IFCHR, instance, NULL, (int)NULL) == DDI_FAILURE) 
X		{
X			/* failed to make the device leaf or in error state */
X			mutex_destroy(&aperture_p->map_lock);
X			ddi_soft_state_free(state_head, instance);
X			return (DDI_FAILURE);
X		}
X
X		/* device driver attached successfully */
X		ddi_report_dev(aperture_p->dip);
X		return (DDI_SUCCESS);
X	}
X	else
X	{
X		/* command not DDI_ATTACH -- return failure */
X		return (DDI_FAILURE);
X	}
}
X
/*
X * Function: aperture_detach()
X * Purpose:  This function implements the detach(9E) functionality
X * Author:   Doug Anson
X * Calls:     
X * Modified: David Holland (davidh@use.com)
X * Log:      DMA -- Origional Version
X * 			 DWH - changed function name/variables/debugging	2/23/94
X */
#if defined(__STDC__)
static int aperture_detach(dev_info_t *dip, ddi_detach_cmd_t cmd)
#else
static int aperture_detach(dip,cmd)
dev_info_t       *dip;
ddi_detach_cmd_t cmd;
#endif /* __STDC__ */
{
X	register Mmap  	*aperture_p = NULL;	
X	int		       	instance;
X
#if APERTURE_DEBUG >= 3
X
X	/* entrance announcement */
X	cmn_err(CE_CONT,"%s: entering aperture_detach()\n", DEV_IDENT_STRING);
X
#endif
X
X	/* check the parameter list */
X	if (cmd != DDI_DETACH)
X	{
X		return (DDI_FAILURE);
X	}
X
X	/* get the instance info and state structure */
X	instance = ddi_get_instance(dip);
X	aperture_p = (Mmap *)ddi_get_soft_state(state_head, instance);
X	if (aperture_p == NULL)
X	{
X		/* failed to get the soft state */
X		return (DDI_FAILURE);
X	}
X
X	/* clean up the driver */
X	mutex_destroy(&aperture_p->map_lock);
X	ddi_remove_minor_node(dip, NULL);
X	ddi_soft_state_free(state_head, instance);
X
X    /* device driver detached successfully */
X	return (DDI_SUCCESS);
}
X
/*
X * Function: aperture_open()
X * Purpose:  This function is called in response to the open(2) system call
X * Author:   Doug Anson
X * Calls:     
X * Modified: David Holland (davidh@use.com)
X * Log:      DMA -- Origional Version
X * 			 DWH - Changed function name/variables/debugging
X */
#if defined(__STDC__)
static	int aperture_open(dev_t *dev, int openflags, int otyp, cred_t *credp)
#else
static	int aperture_open(dev, openflags, otyp, credp)
dev_t  *dev;
int    openflags;
int    otyp;
cred_t *credp;
#endif /* __STDC__ */
{
X	register Mmap	*aperture_p = NULL;
X
#if APERTURE_DEBUG >= 3
X
X	/* entrance announcement */
X	cmn_err(CE_CONT,"%s: entering aperture_open()\n", DEV_IDENT_STRING);
X
#endif
X
X	/* get the state structure */
X	aperture_p = (Mmap *)ddi_get_soft_state(state_head, getminor(*dev));
X	if (aperture_p == NULL)
X	{
X		/* failed to get the soft state */
X		return (ENXIO);
X	}
X
X	/* check the parameter list for correctness */
X	if (otyp != OTYP_CHR)
X	{
X		/* invalid parameter list */
X		return (EINVAL);
X	}
X
X	return (0);
}
X
/*
X * Function: aperture_close()
X * Purpose:  This function is called after the last process that has 
X * 		     the device open calls close(2)
X * Author:   Doug Anson
X * Calls:     
X * Modified: David Holland (davidh@use.com)
X * Log:      DMA -- Origional Version
X * 			 DWH - changed function name/variables/debugging	2/23/94
X */
#if defined(__STDC__)
static	int aperture_close(dev_t dev, int closeflags, int otyp, cred_t *credp)
#else
static	int aperture_close(dev, closeflags, otyp, credp)
dev_t  dev;
int    closeflags;
int    otyp;
cred_t *credp;
#endif /* __STDC__ */
{
X	register Mmap	*aperture_p = NULL;
X
#if APERTURE_DEBUG >= 3
X
X        /* enterance announcement */
X        cmn_err(CE_CONT,"%s: entering aperture_close()\n", DEV_IDENT_STRING);
X
#endif 
X
X	/* get the state structure */
X    aperture_p = (Mmap *)ddi_get_soft_state(state_head, getminor(dev));
X    if (aperture_p == NULL)
X	{
X		/* failed to get the soft state */
X        return (ENXIO);
X	}
X
X	/* check the paramter list for correctness */
X    if (otyp != OTYP_CHR)
X	{
X		/* invalid parameter */
X        return (EINVAL);
X	}
X
X	/* do nothing but return successful */
X    return (0);
}
X
/*
X * Function: aperture_mmap()
X * Purpose:  This function gets called when the user process tries to mmap 
X *			 the framebuffer device using mmap(2).
X * Author:   Doug Anson
X * Calls:     
X * Modified: David Holland (davidh@use.com)
X * Log:      DMA -- Origional Version
X * 			 DWH - changed function name/variables/debugging	2/23/94
X */
#if defined(__STDC__)
static int aperture_mmap(dev_t dev, off_t off, int prot)
#else
static int aperture_mmap(dev, off, prot)
dev_t dev;
off_t off;
int   prot;
#endif /* __STDC__ */
{
X	register Mmap	*aperture_p = NULL;
X
#if APERTURE_DEBUG >= 3
X
X        /* enterance announcement */
X        cmn_err(CE_CONT,"%s: entering aperture_mmap()\n", DEV_IDENT_STRING);
X
#endif
X
X	/* get the state structure */
X	aperture_p = (Mmap *)ddi_get_soft_state(state_head, getminor(dev));
X	if (aperture_p == NULL)
X	{
X		/* failed to get the soft state */
X		return (AP_MEM_FAILURE);
X	}
X
X	/* check that we dont mmap out of bounds */
X	if (off > aperture_p->regsize)
X	{
X		/* offset is out of range for register length */
X		return (AP_MEM_FAILURE);
X	}
X
X	/* check that READ/WRITE only priv only */
X	if (!((prot & PROT_READ) || (prot & PROT_WRITE)))
X	{
X		/* invalid prot parameter in mmap(2) call */
X        return (AP_MEM_FAILURE);
X	} 
X
X	/* ENTER the critical region */
X	mutex_enter(&aperture_p->map_lock);
X
X	/* map the registers  CRITICAL REGION ASSIGNMENT */
X
X	aperture_p->off = off;
X    if (ddi_map_regs(aperture_p->dip, aperture_p->regnum, (caddr_t *)&(aperture_p->kaddr), 
X		aperture_p->off, aperture_p->reglength) == DDI_FAILURE)
X	{
X
#if APERTURE_DEBUG >= 2
X
X		/* report error */
X		cmn_err(CE_CONT, "%s: ERROR: mmap failed (map regs). kaddr=0x%x off=0x%x\n", 
X			DEV_IDENT_STRING,aperture_p->kaddr,aperture_p->off);
X
#endif
X
X		aperture_p->mapaddr = (off_t)AP_MEM_FAILURE;
X	}
X	else
X	{
X		/* fill in our state structure  CRITICAL REGION ASSIGNMENT */
X	   	aperture_p->mapaddr  = (off_t)hat_getkpfnum((caddr_t)aperture_p->kaddr); 
X		if ((u_int)aperture_p->mapaddr == (u_int)AP_MEM_FAILURE)
X		{
X
#if APERTURE_DEBUG >= 2
X
X			/* report error */
X			cmn_err(CE_CONT, "%s: ERROR: mmap failed (kpf). kaddr=0x%x off=0x%x\n", 
X				DEV_IDENT_STRING,aperture_p->kaddr,aperture_p->off);
#endif 
X
X		}
X
X	    /* now unmap the region  CRITICAL REGION ASSIGNMENT */
X
X       	 ddi_unmap_regs(aperture_p->dip, aperture_p->regnum, (caddr_t *)&(aperture_p->kaddr), 
X			aperture_p->off, aperture_p->reglength);
X
#if APERTURE_DEBUG >= 2
X  		/* report register mmaping status */
X		if (aperture_p->mapaddr != AP_MEM_FAILURE)
X		{
X			/* mmap successful */
X   			cmn_err(CE_CONT,"%s: mmap [off=0x%x,length=0x%x) successful\n", 
X				DEV_IDENT_STRING,aperture_p->off,aperture_p->regsize);
X
X    		cmn_err(CE_CONT,"%s: configuration:\n",DEV_IDENT_STRING);
X    		cmn_err(CE_CONT,"    REG(%d): regbase=0x%x regsize=0x%x\n", 
X				aperture_p->regnum, aperture_p->regbase, aperture_p->regsize);
X
X    		cmn_err(CE_CONT,"    kaddr=0x%x mmap off=0x%x mmap addr=0x%x\n", 
X				aperture_p->kaddr, aperture_p->off, aperture_p->mapaddr);
X		}
X		else
X		{
X			/* error in mmap routine */
X			cmn_err(CE_CONT,"%s: mmap not established due to errors", DEV_IDENT_STRING);
X		}
#endif
X
X	}
X
X    /* EXIT the critical region */
X    mutex_exit(&aperture_p->map_lock);
X
X	/* return the page frame number (PFN) */
X
#if APERTURE_DEBUG >= 3
X
X	/* report exit - determining where the long delay is... */
X	cmn_err(CE_CONT, "%s: _mmap routine exiting\n", DEV_IDENT_STRING);
X
#endif
X	
X	return ((int)(aperture_p->mapaddr));
}
SHAR_EOF
chmod 0644 aperture/aperture.c ||
echo 'restore of aperture/aperture.c failed'
Wc_c="`wc -c < 'aperture/aperture.c'`"
test 20528 -eq "$Wc_c" ||
	echo 'aperture/aperture.c: original size 20528, current size' "$Wc_c"
fi
# ============= aperture/aperture.conf ==============
if test -f 'aperture/aperture.conf' -a X"$1" != X"-c"; then
	echo 'x - skipping aperture/aperture.conf (File already exists)'
else
echo 'x - extracting aperture/aperture.conf (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'aperture/aperture.conf' &&
#
# Copyright 1994	Doug Anson, danson@lgc.com & David Holland, davidh@use.com
#
# File:   aperture.conf
# Author: Doug Anson (danson@lgc.com)
# 
# Modified: David Holland (davidh@use.com)
# Log:		Change comments		2/23/94
# Log:		Change defaults/comments	9/25/94
#
# Purpose: 	This conf file is used by the aperture Framebuffer aperture
# 			driver. Do NOT! change the first two numbers of of 
# 			the 'reg' property. They should be 0, and 0x0, 
#			respectivly.
#
name="aperture" class="sysbus" reg=0,0x0,0x7fffffff;
SHAR_EOF
chmod 0644 aperture/aperture.conf ||
echo 'restore of aperture/aperture.conf failed'
Wc_c="`wc -c < 'aperture/aperture.conf'`"
test 518 -eq "$Wc_c" ||
	echo 'aperture/aperture.conf: original size 518, current size' "$Wc_c"
fi
# ============= aperture/aptest.c ==============
if test -f 'aperture/aptest.c' -a X"$1" != X"-c"; then
	echo 'x - skipping aperture/aptest.c (File already exists)'
else
echo 'x - extracting aperture/aptest.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'aperture/aptest.c' &&
/* 
X * Copyright 1994  	Doug Anson, danson@lgc.com & David Holland, davidh@use.com
X *
X * Author: Doug Anson (danson@lgc.com)
X * Date  : 2/21/94
X * Modifed: David Holland (davidh@use.com)
X * Log:
X * 		DWH - Changed names/added comments	2/23/94
X * 		DWH - Removed annoying delays.		2/23/94
X * 
X * This program test the fb aperture driver by 'cheating'
X * it uses the aperture driver to access/read the main
X * system BIOS header
X * 
X * Copyright notice:
X * Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of Doug Anson, and David Holland be used in
X * advertising or publicity pertaining to distribution of the software 
X * Doug Anson, and David Holland make no * representations about the 
X * suitability of this software for any purpose.
X * It is provided "as is" without express or implied warranty.
X *
X * Disclaimer:
X * DOUG ANSON, AND DAVID HOLLAND DISCLAIMS ALL WARRIENTS WITH REGARD TO THIS 
X * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, AND FITNESS, 
X * IN NO EVENT SHALL DOUG ANSON, OR DAVID HOLLAND BE LIABLE FOR ANY SPECIAL, 
X * INDIRECT, OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM 
X * USAGE OF THIS SOFTWARE.
X */
X
/*
X * linear framebuffer aperture driver test program
X */
X
/* 
X * $Id
X */
X
X
#include <stdio.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>
X
#if !defined(sun)
extern void exit(int);
extern caddr_t mmap();
extern int close();
extern int munmap();
#endif
X
/* framebuffer access defines */
#define AP_DEV		"/dev/fbs/aperture"	/* framebuffer apperture device		*/
#define PADDR		0xf0000				/* offset from fbmem base     		*/
#define BUF_LENGTH  0x1000				/* length in bytes -- ignored 		*/
X
/* debug testing defines */
#define START_INDEX	0		/* display starting index(>=0)*/
#define STOP_INDEX	80		/* display stopping index	  */
#define INCR		1		/* display increment		  */
X
/* main program */
int main(int argc,char **argv)
{
X	caddr_t	addr = (caddr_t)0;
X	int		fb_dev;
X	long	start = START_INDEX;
X	long	stop = STOP_INDEX;
X	int		i;
X
X	/* open the framebuffer device */
X	fb_dev = open (AP_DEV,O_RDWR);
X	if (fb_dev < 0)
X	{
X		/* failed to open framebuffer driver */
X		printf("ERROR: failed to open %s\n",AP_DEV);
X		perror("ERROR: open()");
X		exit(1);
X	} 
X
X	/* memory map the framebuffer */
X	addr = (caddr_t)mmap((caddr_t)0,BUF_LENGTH,PROT_READ|PROT_WRITE,MAP_SHARED,
X			             fb_dev,(off_t)PADDR);
X	if (addr == (caddr_t)-1)
X	{
X		/* failed to memory map framebuffer driver */
X		printf("ERROR: failed to mmap [0x%x ,size=%d bytes)\n",
X			   PADDR,BUF_LENGTH);
X		perror("ERROR: mmap()");
X		close(fb_dev);
X		exit(1);
X	}
X	else
X	{
X		/* frame buffer mapped */
X		close(fb_dev);
X		printf("NOTICE: BIOS mapped [0x%x ,size=%d) to addr=0x%x...\n",
X			   PADDR,BUF_LENGTH,(int)addr);
X
X		/* display the buffer */
X    	for(i=start;i<stop;i=i+INCR)
X			printf("%c",addr[i]);
X        	/* printf("addr[%d]=%c\n",i,addr[i]);
X			 */
X		printf("\nDONE displaying memory contents (%d bytes)\n",stop);
X
X		/* unmap and close */
X		printf("UNMAPPING [0x%x ,size=%d) to addr=0x%x... and closing...",
X               PADDR,BUF_LENGTH,(int)addr);
X		munmap(addr,BUF_LENGTH);
X		printf("DONE.\n");
X		printf("Exiting successful...\n");
X		exit(0);
X	}
X	return 1;
}
SHAR_EOF
chmod 0644 aperture/aptest.c ||
echo 'restore of aperture/aptest.c failed'
Wc_c="`wc -c < 'aperture/aptest.c'`"
test 3530 -eq "$Wc_c" ||
	echo 'aperture/aptest.c: original size 3530, current size' "$Wc_c"
fi
# ============= aperture/DISCLAIMER ==============
if test -f 'aperture/DISCLAIMER' -a X"$1" != X"-c"; then
	echo 'x - skipping aperture/DISCLAIMER (File already exists)'
else
echo 'x - extracting aperture/DISCLAIMER (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'aperture/DISCLAIMER' &&
/*
X * Copyright 1994 Doug Anson (danson@lgc.com) & David Holland (davidh@use.com)
X *
X * This code is based largely upon the sample device drivers provided
X * by Sun Microsystems Inc.
X * 
X * Original copyright notice:
X * @(#)mmap.c     1.3 copyright 93/06/03 Sun Microsystems, Inc.
X *
X * Our copyright notice:
X * Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of Doug Anson, and David Holland be used in
X * advertising or publicity pertaining to distribution of the software 
X * Doug Anson, and David Holland make no * representations about the 
X * suitability of this software for any purpose.
X * It is provided "as is" without express or implied warranty.
X *
X * Original disclamer from Sun Microsystems, Inc.:
X * This is a package of sample device drivers for Solaris 2.x (SunOS
X * 5.x).  You may use, modify and distribute these drivers and/or binaries
X * derived from them. However please note that:
X * 
X * These examples are provided with no warranties of any kind, including
X * without limitation accuracy and usefulness, and Sun expressly disclaims
X * all implied warranties of merchantability, fitness for a particular
X * purpose and non-infringement. In no event shall Sun be liable for any
X * damages, including without limitation, direct, special, indirect, or
X * consequential damages arising out of, or relating to, use of these
X * examples by customer or any third party. Sun is under no obligation to
X * provide support to customer for this software.
X * 
X * Our disclaimer:
X * DOUG ANSON, AND DAVID HOLLAND DISCLAIMS ALL WARRIENTS WITH REGARD TO THIS 
X * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, AND FITNESS, 
X * IN NO EVENT SHALL DOUG ANSON, OR DAVID HOLLAND BE LIABLE FOR ANY SPECIAL, 
X * INDIRECT, OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM 
X * USAGE OF THIS SOFTWARE.
X */
X
/*
X * linear framebuffer aperture driver
X * 
X * $Id
X */
SHAR_EOF
chmod 0644 aperture/DISCLAIMER ||
echo 'restore of aperture/DISCLAIMER failed'
Wc_c="`wc -c < 'aperture/DISCLAIMER'`"
test 2174 -eq "$Wc_c" ||
	echo 'aperture/DISCLAIMER: original size 2174, current size' "$Wc_c"
fi
exit 0
