<!DOCTYPE linuxdoc PUBLIC "-//XFree86//DTD linuxdoc//EN">

<article>

<title> How to add an (S)VGA driver to XFree86
<author> Copyright (c) 1993, 1994 David E. Wexelblat
  <tt/&lt;dwex@XFree86.org&gt;/
<date> Issue 1.3 - May 29, 1994

<toc>

<sect> Introduction <p>
Adding support for a new SVGA chipset to XFree86 is a challenging project 
for someone who wants to learn more about hardware-level programming.  It 
can be fraught with hazards (in particular, crashing the machine is all too 
common).  But in the end, when the server comes up and functions, it is
immensely satisfying.

Adding support for an SVGA chipset does not change any of the basic 
functioning of the server.  It is still a dumb 8-bit PseudoColor server or 
1-bit StaticGray server.  Adding support for new hardware (e.g. accelerated 
chips) is a major undertaking, and is not anywhere near formalized enough yet 
that it can be documented.

Nonetheless, the driver-level programming here is a good introduction.  And 
can well be the first step for adding support for an accelerated chipset, as 
many are SVGA-supersets.  Writing an SVGA-level driver for the chipset can 
provide a stable development platform for making use of new features (in fact,
this has been done for the S3, Cirrus, and WD accelerated chipsets, for 
internal use as the accelerated servers are developed for XFree86 2.0).

Now let's get down to it.  In addition to this documentation, a stub driver has 
been provided.  This should provide you a complete framework for your new 
driver.  Don't let the size of this document persuade you that this is an
overly difficult task.  A lot of work has been put into making this document
as close to complete as possible; hence it should, in theory, be possible to
use this as a cookbook, and come out with a working driver when you reach the
end.  I do advise that you read it all the way through before starting.

<sect> Getting Started <p>
The first step in developing a new driver is to get the documentation for 
your chipset.  I've included a list of vendor contact information that I have 
collected so far (it's far from complete, so if you have any that isn't on 
the list, please send it to me).  You need to obtain the databook for the 
chipset.  Make sure that the person you speak to is aware that you intend to 
do register-level programming (so they don't send you the EE-style datasheet).
Ask for any example code, or developer's kits, etc.  I've learned that at the 
SVGA level, in general, a databook that lists and describes the registers is 
the most you can hope to find.

If you are not familiar with VGA register-level programming, you should get 
(and read!) a copy of Richard Ferraro's bible (see references below).  The 
best way to understand what is happening in the server is to study the 
workings of the monochrome server's ``generic'' server, and compare it with 
the documentation in Ferraro's book (be aware that there are a few errors 
in the book).  You can find the generic-VGA-register handling functions in 
the file ``vgaHW.c''.

Once you understand what's happening in the generic server, you should study 
one or more of the existing SVGA drivers.  Obtain the databook for a supported
SVGA chipset, and study the documentation along with the code.  When you have 
a good understanding of what that driver does over and above the generic VGA, 
you will know what information you need to obtain from the databook for the 
new chipset.  Once you have this information, you are ready to begin work on 
your new driver.

<sect> Directory Tree Structure <p>
Here is an outline of the directory tree structure for the source tree.
Only directories/files that are relevant to writing a driver are presented.
The structure for the Link Kit is presented below.

<descrip>
<tag>xc/config/cf/</tag>
	<descrip>
	<tag>site.def</tag>
		Local configuration customization
	<tag>xf86site.def</tag>
		XFree86 local configuration customization
	</descrip>

<tag>xc/programs/Xserver/hw/xfree86/</tag>
	The server source
	<descrip>
	<tag>common/</tag>
			Files common to all of the server (XF86Config
				parser, I/O device handlers, etc)
		<descrip>
		<tag>xf86.h</tag>
			Contains the `ScrnInfoRec' data structure
		<tag>xf86_Option.h</tag>
			Contains option flags
		<tag>compiler.h</tag>
			Contains in-line assembler macros and
				utility functions
		</descrip>
	<tag>os-support/</tag>		OS-support layer 
		<descrip>
		<tag>assyntax.h</tag>
			Contains macro-ized assembler mnemonics
		<tag>xf86_OSlib.h</tag>
			OS-support includes, defines, and prototypes
		</descrip>
	<tag>LinkKit/</tag>
		<descrip>
		<tag>site.def.LK</tag>
			Template for Link Kit site.def
		</descrip>
	<tag>vga256/</tag>			256-color VGA server directories
		<descrip>
		<tag>vga/</tag>
				The generic VGA handling code
			<descrip>
			<tag>vga.h</tag>
				Contains the `vgaVideoChipRec' and `vgaHWRec'
				data structures
			<tag>vgaHW.c</tag>
				Contains the generic-VGA-register handling
				functions <bf>vgaHWInit()</bf>,
				<bf>vgaHWSave()</bf> and 
				<bf>vgaHWRestore()</bf>.
			</descrip>
		<tag>drivers/</tag>	Contains the SVGA driver subdirectories.
				Each contains an Imakefile, a .c file for
				the driver, and a .s file for the bank-
				switching functions.
		</descrip>
	<tag>vga2/</tag>
				The monochrome vga server directories.  Most of
				the files are linked from vga256, and the
				differences handled by conditional compilation.
		<descrip>
		<tag>drivers/</tag>
				The SVGA driver subdirectories.  The `generic'
				VGA driver is also located here.
		</descrip>
	<tag>vga16/</tag>
				The 16-color vga server directories.  Most of
				the files are linked from vga256, and the
				differences handled by conditional compilation.
		<descrip>
		<tag>drivers/</tag>	The SVGA driver subdirectories.
		</descrip>
	<tag>VGADriverDoc/</tag>		This documentation and the stub driver.
	</descrip>
</descrip>
The Link Kit is usually installed in /usr/X11R6/lib/Server.
The Link Kit
contains everything that is needed to relink the server.  It is possible
to write a new driver and build a new server without having even the server
source installed.
<descrip>
<tag>Server/</tag>
	<descrip>
	<tag>site.def</tag>
		Local configuration customization
	<tag>include/</tag>
		All of the include files listed under the
		`common' directory above
	<tag>drivers/</tag>
		All of the SVGA drivers
		<descrip>
		<tag>vga2/</tag> The SVGA driver subdirectories.
		<tag>vga16/</tag> The SVGA driver subdirectories.
		<tag>vga256/</tag> The SVGA driver subdirectories.
		</descrip>
	<tag>VGADriverDoc/</tag>		The directory with this documentation and
				the stub driver.  `vgaHW.c' is also copied
				here, for reference (it is not built as
				part of the Link Kit).
	</descrip>
</descrip>
	
<sect> Setting Up The Build Information <p>
  This section describes the peripheral configuration and build steps that
must be performed to set up for your new driver.  The steps are the same
whether you are building from the source tree of from the Link Kit; only
the locations of the files is different.  Here are the configuration steps
that must be followed:

<enum>
<item>	 Choose the name for your driver subdirectory and data structures.
	   Since the current driver scheme allows (in fact, encourages)
	   putting drivers for multiple related chipsets in a single driver,
	   it is usually best to use the vendor name, rather than a chipset
	   version.  The fact that older XFree86 drivers do not follow this
	   convention should not deter you from using it now - most of that
	   code was developed before the driver interface had been made
	   flexible and extensible.

	   For this documentation, we'll use chips from the SuperDuper Chips
	   vendor.  Hence, we'll use `sdc' for the name of the driver.

<item>	 Decide whether your driver will support the color server, the
	   monochrome server, or both.  For this documentation, we will
	   assume that both the color and monochrome servers will be
	   supported.  If you intend to support only the color server, the
	   steps for the monochrome server can be ignored.  If you intend
	   to support only the monochrome server, the steps for the color
	   server listed should be performed for the monochrome server,
	   and the monochrome steps ignored.  Most of the existing drivers
	   support only the color or both servers; the ``generic'' driver is
	   the only driver (currently) that supports just the monochrome
	   server.

<item>	 Create your driver directories:

	 <itemize>
	 <item>If you are working in the source tree, create the
		  following directories:

<verb>
   xc/programs/Xserver/hw/xfree86/vga256/drivers/sdc
   xc/programs/Xserver/hw/xfree86/vga16/drivers/sdc
   xc/programs/Xserver/hw/xfree86/vga2/drivers/sdc
</verb>

	<item>If you are working in the Link Kit, create the
		  following directories:
			
<verb>
   /usr/X11R6/lib/Server/drivers/vga256/sdc
   /usr/X11R6/lib/Server/drivers/vga16/sdc
   /usr/X11R6/lib/Server/drivers/vga2/sdc
</verb>
	 </itemize>

<item>	 Set up the Imakefile parameters to cause your driver to be
	   built:

	 <itemize>
	 <item>If you are working in the source tree:
		   <enum>
		   <item>Edit the file xc/config/cf/xfree86.cf,
			   and add 
			   `sdc' to the list for the definitions for 
			   `XF86Vga256Drivers', `XF86Vga16Drivers' and
			   `XF86Vga2Drivers'.
			   You should put `sdc' just before `generic' in the
			   list (i.e. second last), to ensure that none of the
			   other driver's probe functions incorrectly detect
			   the `sdc' chipset .
		   <item>Edit the file xc/config/cf/xf86site.def,
			   and add
			   the same entries in this file (this is just a
			   comment that shows the default values).
		   <item>Edit the site.def.LK file in
			   xc/programs/Xserver/hw/xfree86/LinkKit/,
			   and add the same entries in this file.  This is
			   the prototype `site.def' file that will be
			   installed in the Link Kit.
		   </enum>
		
	<item>If you are working in the Link Kit, edit the file
		  /usr/X11R6/lib/Server/site.def, and add `sdc' to
		  the `XF86Vga256Drivers', `XF86Vga16Drivers' and
		  `XF86Vga2Drivers' definitions as described in (a) above.
	 </itemize>
<item>	 Now copy the prototype files into your new directories:
	 <itemize>
	 <item>If you are working in the source tree, copy the `stub' 
		  files as follows (directories are below xc/programs/Xserver):
		<descrip>
		<tag>Imakefile.stub =&gt;</tag>
		    hw/xfree86/vga256/drivers/sdc/Imakefile
	 	<tag>stub_driver.c =&gt;</tag>
	  	    hw/xfree86/vga256/drivers/sdc/sdc_driver.c
		<tag>stub_bank.s =&gt;</tag>
	  	    hw/xfree86/vga256/drivers/sdc/sdc_bank.s
		<tag>Imakefile.stub =&gt;</tag>
		    hw/xfree86/vga16/drivers/sdc/Imakefile
		      (then edit this Imakefile and make the changes
		       described in the comments).
		<tag>Imakefile.stub =&gt;</tag>
		    hw/xfree86/vga2/drivers/sdc/Imakefile
		      (then edit this Imakefile and make the changes
		       described in the comments).
		</descrip>
	  <item>If you are working in the Link Kit, copy the `stub' files
		  as follows:
		<descrip>
		<tag>Imakefile.stub =&gt; </tag>
		  /usr/X11R6/lib/Server/drivers/vga256/sdc/Imakefile
		<tag>stub_driver.c =&gt; </tag>
		  /usr/X11R6/lib/Server/drivers/vga256/sdc/sdc_driver.c
		<tag>stub_bank.s =&gt; </tag>
		  /usr/X11R6/lib/Server/drivers/vga256/sdc/sdc_bank.s
		<tag>Imakefile.stub =&gt; </tag>
		  /usr/X11R6/lib/Server/drivers/vga16/sdc/Imakefile
		     (then edit this Imakefile and make the changes
		      described in the comments).
		<tag>Imakefile.stub =&gt; </tag>
		  /usr/X11R6/lib/Server/drivers/vga2/sdc/Imakefile
		     (then edit this Imakefile and make the changes
		      described in the comments).
		</descrip>
	 </itemize>
<item>	 Edit each of the files you've just copied, and replace `stub'
	   with `sdc' and `STUB' with `SDC' wherever they appear.
</enum>
That's all the prep work needed.  Now it's time to work on the actual driver.
				
<sect> The Bank-Switching Functions <p>
The normal VGA memory map is 64k starting at address 0xA0000.  To access
more than 64k of memory, SuperVGA chipsets implement ``bank switching'' - 
the high-order address bits are used to select the bank of memory in which
operations will take place.  The size and number of these banks varies,
and will be spelled out in the chipset documentation.  A chipset will
have zero, one or two bank registers.  Likely the ONLY case of zero bank
registers is a generic VGA, and hence is not a concern.

Note that some of the newer chipsets (e.g. Trident 8900CL, Cirrus) allow
for a linear mapping of the video memory.  While using such a scheme would
improve the performance of the server, it is not currently supported.  Hence
there is no way to use such features for a new chipset.

Most SVGA chipsets have two bank registers.  This is the most desirable 
structure (if any banking structure can be called ``desirable''), because 
data can be moved from one area of the screen to another with a simple 
`mov' instruction.  There are two forms of dual-banking - one where the 
two bank operations define a read-only bank and a write-only bank, and
one with two read/write windows.  With the first form, the entire SVGA
memory window is used for both read a write operations, and the two
bank registers determine which bank is actually used (e.g. ET3000, ET4000).
With the second form, the SVGA memory window is split into two read/write
banks, with each bank pointer being used to control one window.  In
this case, one window is used for read operations and the other for write
operations (e.g. PVGA1/Western Digital, Cirrus).

A chipset that has a single bank register uses that one bank for both
read and write access.  This is problematic, because copying information
from one part of the screen to another requires that the data be read in,
stored, and then written out.  Fortunately, the server is able to handle
both one-bank and two-bank chipsets; the determination of behavior is
defined by an entry in the driver data structure described below.

A driver requires that three assembly-language functions be written, in
the file `<tt>sdc_bank.s</tt>'.
These functions set the read bank - <bf>SDCSetRead()</bf>,
the write bank - <bf>SDCSetWrite()</bf>, and set both banks -
<bf>SDCSetReadWrite()</bf>.
For a chipset with only one bank, all three will be declared as entry points
to the same function (see the ``tvga8900'' driver for an example).

The functions are fairly simple - the bank number is passed to the function
in register &percnt;al.  The function will shift, bitmask, etc - whatever is 
required to put the bank number into the correct form - and then write
it to the correct I/O port.  For chipsets where the two banks are read-only
HERE
and write-only, the <bf>SetReadWrite()</bf> function will have to do this twice - once 
for each bank.  For chipsets with two independent read/write windows, the
<bf>SetReadWrite()</bf> function should use the same bank as the <bf>SetWrite()</bf> function.

A special note - these functions MUST be written in the macroized assembler
format defined in the header file ``assyntax.h''.  This will ensure that
the correct assembler code will be generated, regardless of OS.  This
macroized format currently supports USL, GNU, and Intel assembler formats.

That's all there is to the banking functions.  Usually the chipset reference
will give examples of this code; if not, it is not difficult to figure out,
especially using the other drivers as examples.

<sect> The Driver Itself <p>
  Now it's time to get down to the real work - writing the major driver
functions in the files sdc_driver.c.  First, an overview of what the
responsibilities of the driver are:

<enum>
<item>	   Provide a chipset-descriptor data structure to the server.  This
	   data structure contains pointers to the driver functions and
	   some data-structure initialization as well.
<item>	   Provide a driver-local data structure to hold the contents of
	   the chipset registers.  This data structure will contain a 
	   generic part and a driver-specific part.  It is used to save the
	   initial chipset state, and is initialized by the driver to put
	   the chipset into different modes.
<item>	   Provide an identification function that the server will call to
	   list the chipsets that the driver is capable of supporting.
<item>	   Provide a probe function that will identify this chipset as
	   different from all others, and return a positive response if
	   the chipset this driver supports is installed, and a negative
	   response otherwise.
<item>	   Provide a function to select dot-clocks available on the board.
<item>	   Provide functions to save, restore, and initialize the driver-
	   local data structure.
<item>	   Provide a function to set the starting address for display in
	   the video memory.  This implements the virtual-screen for the
	   server.
<item>	   Perhaps provide a function for use during VT-switching.
<item>	   Perhaps provide a function to check if each mode is suitable for
	   the chipset being used.
</enum>

Before stepping through the driver file in detail, here are some important
issues:

<enum>
<item>	   If your driver supports both the color and monochrome servers,
	   you should take care of both cases in the same file.  Most things
	   are the same - you can differentiate between the two with the
	   MONOVGA <tt>&num;define</tt>.  If the 16 color server is supported,
	   code specific to it can be enabled with the XF86VGA16
	   <tt>&num;define</tt>.  In most cases  it is sufficient to put
	   the following near the top of the stub_driver.c file:

<verb>
   #ifdef XF86VGA16
   #define MONOVGA
   #endif
</verb>

<item>	   The color server uses the SVGA's 8-bit packed-pixel mode.  The
	   monochrome and vga16 servers uses the VGA's 16-color mode
	   (4 bit-planes).  Only one plane is enabled for the monochrome
	   server.
<item>	   It is possible for you to define your monochrome driver so that
	   no bank-switching is done.  This is not particularly desirable,
	   as it yields only 64k of viewing area.
</enum>
Keeping these things in mind, you need to find the registers from your
SVGA chipset that control the desired features.  In particular, registers
that control:
<enum>
<item>	   Clock select bits.  The two low-order bits are part of the
	   standard Miscellaneous Output Register; most SVGA chipsets
	   will include 1 or 2 more bits, allowing the use of 8 or 16
	   discrete clocks.
<item>	   Bank selection.  The SVGA chipset will have one or two registers
	   that control read/write bank selection.
<item>	   CRTC extensions.  The standard VGA registers don't have enough
	   bits to address large displays.  So the SVGA chipsets have
	   extension bits.
<item>	   Interlaced mode.  Standard VGA does not support interlaced
	   displays.  So the SVGA chipset will have a bit somewhere to
	   control interlaced mode.  Some chipsets require additional
	   registers to be set up to control interlaced mode
<item>	   Starting address.  The standard VGA only has 16 bits in which
	   to specify the starting address for the display.  This restricts
	   the screen size usable by the virtual screen feature.  The SVGA
	   chipset will usually provide one or more extension bits.
<item>	   Lock registers.  Many SVGA chipset prevent modification of
	   extended registers unless the registers are first ``unlocked''.
	   You will need to disable protection of any registers you will
	   need for other purposes.
<item>	   Any other facilities.  Some chipset may, for example, require
	   that certain bits be set before you can access extended VGA
	   memory (beyond the IBM-standard 256k).  Or other facilities;
	   read through all of the extended register descriptions and see
	   if anything important leaps out at you.
</enum>

If you are fortunate, the chipset vendor will include in the databook some
tables of register settings for various BIOS modes.  You can learn a lot
about what manipulations you must do by looking at the various BIOS modes.

<sect1> Multiple Chipsets And Options <p>
It is possible, and in fact desirable, to have a single driver support
multiple chipsets from the same vendor.  If there are multiple supported
chipsets, then you would have a series of &num;define's for them, and a
variable `SDCchipset', which would be used throughout the driver when
distinctions must be made.  See the Trident and PVGA1/WD drivers for
examples (the Tseng ET3000 and ET4000 are counter-examples - these were
implemented before the driver interface allowed for multiple chipsets, so
this example should NOT be followed).  Note that you should only distinguish
versions when your driver needs to do things differently for them.  For
example, suppose the SDC driver supports the SDC-1a, SDC-1b, and SDC-2
chipsets.  The -1a and -1b are essentially the same, but different from the
-2 chipset.  Your driver should support the -1 and -2 chipsets, and not
distinguish between the -1a and -1b.  This will simplify things for the
end user.

In cases where you want to give the user control of driver behavior, or
there are things that cannot be determined without user intervention, you
should use ``option'' flags.  Say that board vendors that use the SDC 
chipsets have the option of providing 8 or 16 clocks.  There's no way you 
can determine this from the chipset probe, so you provide an option flag to 
let the user select the behavior from the XF86Config file.  The option flags
are defined in the file ``xf86_option.h''.  You should look to see if there is 
already a flag that can be reused.  If so, use it in your driver.  If not, 
add a new &num;define, and define the string->symbol mapping in the table in 
that file.  To see how option flags are used, look at the ET4000, 
PVGA1/WD, and Trident drivers.

<sect1> Data Structures <p>
Once you have an understanding of what is needed from the above description,
it is time to fill in the driver data structures.  First we will deal with
the `vgaSDCRec' structure.  This data structure is the driver-local structure
that holds the SVGA state information.  The first entry in this data structure
is ALWAYS `vgaHWRec std'.  This piece holds the generic VGA portion of the
information.  After that, you will have one `unsigned char' field for each
register that will be manipulated by your driver.  That's all there is to
this data structure.

Next you must initialize the `SDC' structure (type `vgaVideoChipRec').  This
is the global structure that identifies your driver to the server.  Its name
MUST be `SDC', in all caps - i.e. it must match the directory name for your
driver.  This is required so that the Link Kit reconfiguration can identify
all of the requisite directories and global data structures.

The first section of this structure simply holds pointers to the driver
functions.

Next, you must initialize the information about how your chipset does
bank switching.  The following fields must be filled in:
<enum>
<item>	   ChipMapSize - the amount of memory that must be mapped into
	   the server's address space.  This is almost always 64k (from
	   0xA0000 to 0xAFFFF).  Some chipsets use a 128k map (from
	   0xA0000 to 0xBFFFF).  If your chipset gives an option, use the
	   64k window, as a 128k window rules out using a Hercules or
	   Monochrome Display Adapter card with the SVGA.
<item>	   ChipSegmentSize - the size of each bank within the ChipMapSize
	   window.  This is usually also 64k, however, some chipsets split
	   the mapped window into a read portion and a write portion (for
	   example the PVGA1/Western Digital chipsets).
<item>	   ChipSegmentShift - the number of bits by which an address will
	   be shifted right to mask of the bank number.  This is log-base-2
	   of ChipSegmentSize.
<item>	   ChipSegmentMask - a bitmask used to mask off the address within
	   a given bank.  This is (ChipSegmentSize-1).
<item>	   ChipReadBottom,ChipReadTop - the addresses within the mapped
	   window in which read operations can be done.  Usually 0, and 
	   64k, respectively, except for those chipset that have separate
	   read and write windows.
<item>	   ChipWriteBottom,ChipWriteTop - same as above, for write operations.
<item>	   ChipUse2Banks - a boolean value for whether this chipset has one
	   or two bank registers.  This is used to set up the screen-to-screen
	   operations properly.
</enum>
There are three more fields that must be filled in:
<enum>
<item>	   ChipInterlaceType - this is either VGA_NO_DIVIDE_VERT or
	   VGA_DIVIDE_VERT.  Some chipsets require that the vertical timing
	   numbers be divided in half for interlaced modes.  Setting this
	   flag will take care of that.
<item>	   ChipOptionFlags - this should always be `{0,}' in the data
	   structure initialization.  This is a bitfield that contains
	   the Option flags that are valid for this driver.  The appropriate 
	   bits are initialized at the end of the Probe function.
<item>	   ChipRounding - this gets set to the multiple by which the
	   virtual width of the display must be rounded for the 256-color
	   server.  This value is usually 8, but may be 4 or 16 for some
	   chipsets.
</enum>

<sect1> The Ident() function <p>
The <bf>Ident()</bf> function is a very simple function.  The server will call
this function repeatedly, until a NULL is returned, when printing out the
list of configured drivers.  The <bf>Ident()</bf> function should return a chipset
name for a supported chipset.  The function is passed a number which
increments from 0 on each iteration.

<sect1> The ClockSelect() function <p>
The <bf>ClockSelect()</bf> function is used during clock probing (i.e. when no
`Clocks' line is specified in the XF86Config file) to select the dot-clock
indicated by the number passed in the parameter.  The function should
set the chipset's clock-select bits according to the passed-in number.
Two dummy values will be passed in as well (CLK_REG_SAVE, CLK_SAVE_RESTORE).
When CLK_REG_SAVE is passed, the function should save away copies of
any registers that will be modified during clock selection.  When
CLK_REG_RESTORE is passed, the function should restore these registers.
This ensure that the clock-probing cannot corrupt registers.

This function should return FALSE if the passed-in index value is invalid
or if the clock can't be set for some reason.

<sect1> The Probe() function <p>
The <bf>Probe()</bf> function is perhaps the most important, and perhaps the
least intuitive function in the driver.  The Probe function is required
to identify the chipset independent of all other chipsets.  If the user
has specified a `<tt>Chipset</tt>' line in the XF86Config file, this is a simple
string comparison check.  Otherwise, you must use some other technique
to figure out what chipset is installed.  If you are lucky, the chipset
will have an identification mechanism (ident/version registers, etc), and
this will be documented in the databook.  Otherwise, you will have to
determine some scheme, using the reference materials listed below.

The identification is often done by looking for particular patterns in
register, or for the existence of certain extended registers.  Or with
some boards/chipsets, the requisite information can be obtained by reading
the BIOS for certain signature strings.  The best advise is to study the
existing probe functions, and use the reference documentation.  You
must be certain that your probe is non-destructive - if you modify a
register, it must be saved before, and restored after.

Once the chipset is successfully identified, the <bf>Probe()</bf> function must
do some other initializations:
<enum>
<item>	   If the user has not specified the `<tt>VideoRam</tt>' parameter in the
	   XF86Config file, the amount of installed memory must be determined.
<item>	   If the user has not specified the `<tt>Clocks</tt>' parameter in the
	   XF86Config file, the values for the available dot-clocks must
	   be determined.  This is done by calling the <bf>vgaGetClocks()</bf>
	   function, and passing it the number of clocks available and
	   a pointer to the <bf>ClockSelect()</bf> function.
<item>	   It is recommended that the `maxClock' field of the server's
	   `vga256InfoRec' structure be filled in with the maximum
	   dot-clock rate allowed for this chipset (specified in KHz).
	   If this is not filled in a probe time, a default (currently
	   90MHz) will be used.
<item>	   The `chipset' field of the server's `vga256InfoRec' structure
	   must be initialized to the name of the installed chipset.
<item>	   If the driver will be used with the monochrome server, the
	   `bankedMono' field of the server's `vga256InfoRec' structure
	   must be set to indicate whether the monochrome driver supports
	   banking.
<item>	   If any option flags are used by this driver, the `ChipOptionFlags' 
	   structure in the `vgaVideoChipRec' must be initialized with the 
	   allowed option flags using the <bf>OFLG_SET()</bf> macro.
</enum>

<sect1> The EnterLeave() function <p>
The <bf>EnterLeave()</bf> function is called whenever the virtual console on which
the server runs is entered or left (for OSs without virtual consoles, the
function is called when the server starts and again when it exits).  The
purpose of this function is to enable and disable I/O permissions (for
OSs where such is required), and to unlock and relock access to ``protected''
registers that the driver must manipulate.  It is a fairly trivial function,
and can be implemented by following the comments in the stub driver.

<sect1> The Restore() function <p>
The <bf>Restore()</bf> function is used for restoring a saved video state.  Note
that `restore' is a bit of a misnomer - this function is used to both
restore a saved state and to install a new one created by the server.  The
<bf>Restore()</bf> function must complete the following actions:
<enum>
<item>	   Ensure that Bank 0 is selected, and that any other state
	   information required prior to writing out a new state has been
	   set up.
<item>	   Call <bf>vgaHWRestore()</bf> to restore the generic VGA portion of the
	   state information.  This function is in the vgaHW.c file.
<item>	   Restore the chipset-specific portion of the state information.
	   This may be done by simply writing out the register, or by
	   doing a read/modify/write cycle if only certain bits are to
	   be modified.  Be sure to note the comment in the sample driver
	   about how to handle clock-select bits.
</enum>
<sect1> The Save() function <p>
The <bf>Save()</bf> function is used to extract the initial video state information
when the server starts.  The <bf>Save()</bf> function must complete the following
actions:
<enum>
<item>	   Ensure that Bank 0 is selected.
<item>	   Call <bf>vgaHWSave()</bf> to extract the generic VGA portion of the state
	   information.  This function is in the vgaHW.c file.
<item>	   Extract the chipset-specific portion of the state information.
</enum>
<sect1> The Init() function <p>
  The <bf>Init()</bf> function is the second most important function in the driver
(after the <bf>Probe()</bf> function).  It is used to initialize a data structure
for each of the defined display modes in the server.  This function is
required to initialize the entire `vgaSDCRec' data structure with the
information needed to put the SVGA chipset into the required state.  The
generic VGA portion of the structure is initialized with a call to 
<bf>vgaHWInit()</bf> (also located in vgaHW.c).

Once the generic portion is initialized, the <bf>Init()</bf> function can override
any of the generic register initialization, if necessary.  All of the other
fields are filled in with the correct initialization.  The information
about the particular mode being initialized is passed in the `mode'
parameter, a pointer to a `DisplayModeRec' structure.  This can be
dereferenced to determine the needed parameters.

If you only know how to initialize certain bits of the register, do that
here, and make sure that the <bf>Restore()</bf> function does a read/modify/write
to only manipulate those bits.  Again, refer to the existing drivers
for examples of what happens in this function.

<sect1> The Adjust() function <p>
The <bf>Adjust()</bf> function is another fairly basic function.  It is called
whenever the server needs to adjust the start of the displayed part of
the video memory, due to scrolling of the virtual screen or when changing
the displayed resolution.  All it does is set the starting address on the
chipset to match the specified coordinate.  Follow the comments in the 
stub driver for details on how to implement it.

<sect1> The ValidMode() function <p>
The <bf>ValidMode()</bf> function is required.  It is used to check
for any chipset-dependent reasons why a graphics mode might not be valid.  It
gets called by higher levels of the code after the Probe() stage.  In
many cases no special checking will be required and this function will
simply return TRUE always.

<sect1> The SaveScreen() function <p>
The <bf>SaveScreen()</bf> function is not needed by most chipsets.  This function
would only be required if the extended registers that your driver needs
will be modified when a synchronous reset is performed on the SVGA chipset
(your databook should tell you this).  If you do NOT need this function,
simply don't define it, and put `NoopDDA' in its place in the vgaVideoChipRec
structure initialization (NoopDDA is a generic-use empty function).

If you DO need this function, it is fairly simple to do.  It will be
called twice - once before the reset, and again after.  It will be passed
a parameter of SS_START in the former case, and SS_FINISH in the latter.
All that needs to be done is to save any registers that will be affected
by the reset into static variables on the SS_START call, and then restore
them on the SS_FINISH call.

<sect1> The GetMode() function <p>
The <bf>GetMode()</bf> function is not used as of XFree86 1.3; its place in the
vgaVideoChipRec should be initialized to `NoopDDA'.

At some point in the future, this function will be used to enable the server
and/or a standalone program using the server's driver libraries to do 
interactive video mode adjustments.  This function will read the SVGA
registers and fill in a DisplayModeRec structure with the current video
mode.

<sect1> The FbInit() function <p>
The <bf>FbInit()</bf> function is required for drivers with accelerated graphics
support.  It is used to replace default cfb.banked functions with
accelerated chip-specific versions.  vga256LowlevFuncs is a struct containing
a list of functions which can be replaced.  This struct defined in
vga256.h.  Examples of <bf>FbInit()</bf> functions can be found in the et4000,
pvga1 and cirrus drivers.

If you do NOT need this function, simply don't define it, and put `NoopDDA'
in its place in the vgaVideoChipRec structure initialization.

<sect> Building The New Server <p>
As in the setup work, the steps for building the server depend whether
you are working in the source tree or in the Link Kit.  Here are the
steps for the initial build after installing your new driver files:
<itemize>
	<item>If you are working in the source tree, follow these steps:

		Go to xc/programs/Xserver, and enter
	        `<tt>make Makefile</tt>', then
		`<tt>make Makefiles depend all</tt>'

	<item>If you are working in the Link Kit, follow these steps:

	<enum>
	<item>Go to /usr/X11R6/lib/Server, and enter
	       `<tt>./mkmf</tt>'
	<item>In the same directory, enter `<tt>make</tt>'
	</enum>
</itemize>
To rebuild the server after the initial build (e.g. after making changes
to your driver):

<itemize>
<item>	If you are working in the source tree, follow these steps:
		
	<enum>
	<item>	Go to the appropriate drivers/ directory (e.g.,
	   xc/programs/Xserver/hw/xfree86/vga256/drivers),
	   and enter `<tt>make</tt>'.
	<item>	Go to xc/programs/Xserver, and enter
	   `<tt>make loadXF86_SVGA</tt>' (to link the color server),
	   `<tt>make loadXF86_VGA16</tt>' (to link the 16 color server) or
	   `<tt>make loadXF86_Mono</tt>' (to link the mono server).
	</enum>

<item>	If you are working in the Link Kit, follow these steps:

	<enum>
	<item>	Go to the appropriate driver directory, and enter
	   `<tt>make</tt>'.
	<item>	Go to /usr/X11R6/lib/server, and enter 
	   `<tt>make loadXF86_SVGA</tt>' (to link the color server) or 
	   `<tt>make loadXF86_VGA16</tt>' (to link the 16 color server) or 
	   `<tt>make loadXF86_Mono</tt>' (to link the mono server).
	</enum>
</itemize>

<sect> Debugging <p>
Debugging a new driver can be a painful experience, unfortunately.  It
is likely that incorrect programming of the SVGA chipset can lock up your
machine.  More likely, however, is that the display will be lost, potentially
requiring a reboot to correct.  It is HIGHLY recommended that the server
be run from an attached terminal or a network login.  This is the only
rational way in which a debugger can be used on the server.  Attempting
to use multiple VTs for debugging is basically a waste of time.

Because of the potential for locking up the machine, it is a VERY good idea
to remember to do a `sync' or two before starting the server.  In addition,
any unnecessary filesystems should be unmounted while the debugging session
is going on (to avoid having to run unnecessary fsck's).

By default the server is built without debugging symbols.  The server can
grow VERY large with debugging enabled.  It is very simple to rebuild
your driver for debugging, though.  Do the following:

<enum>
	<item>Go to the driver directory.
	<item>Edit the Makefile.  Look for the SECOND definition of 
	   `<tt>CDEBUGFLAGS</tt>'.  Change this definition to 
		
	<verb>
		CDEBUGFLAGS = -g -DNO_INLINE
	</verb>

	   (this will enable debugging symbols and disable inlining of
	   functions, which can make single-stepping a nightmare).
	<item>Remove the `sdc_driver.o' file.
	<item>Now follow the steps above for rebuilding the server.

	(Alternatively, instead of editing the Makefile, you can simply
	do `<tt>make CDEBUGFLAGS="-g -DNO_INLINE"</tt>' after removing the
	old .o file, then rebuild the server as described above).
</enum>

This will give you a server with which you can set breakpoints in the driver
functions and single-step them.  If you are working in the source tree,
and just learning about SVGA programming, it may be useful to rebuild 
vgaHW.c with debugging as well.

<sect> Advice <p>
I cannot stress this enough - study all available references, and the
existing code, until you understand what is happening.  Do this BEFORE you
begin writing a driver.  This will save you a massive amount of headache.
Try to find a driver for a chipset that is similar to yours, if possible.
Use this as an example, and perhaps derive your driver from it.

Do not let the gloom-and-doom in the debugging section  discourage you.  
While you will probably have problems initially (I still do), careful, 
deliberate debugging steps can bear fruit very quickly.  It is likely 
that, given a good understanding of the chipset, a driver can be written 
and debugged in a day or two.  For someone just learning about this kind 
of programming, a week is more reasonable.

<sect> Advanced Topics <p>
Newer chipsets are getting into two advanced areas: programmable clock
generators, and accelerated capabilities (BitBlt, line drawing, HW cursor).
These are new areas, and the formal interfaces to them are not yet defined.
It is advised that you contact the XFree86 team and get involved with the
development/beta-testing team if you need to be working in these areas.

<sect> References <p>
<itemize>
<item>Programmer's Guide to the EGA and VGA Cards, 3rd ed. <newline>
   Richard Ferraro <newline>
   Addison-Wesley, 1994 <newline>
   ISBN 0-201-62490-7 <newline>
   (This is the bible of SVGA programming - it has a few errors, so watch out.
   The third edition also covers several accelerated video cards.)

<item>vgadoc4.zip <newline>
   Finn Thoegersen <newline>
   (This is a collection of SVGA and other chipset documentation.  It is
   available on most MS-DOS/Windows related FTP archives, including wuarchive.
   It is DOS/BIOS oriented, but is still extremely useful, especially for
   developing probe functions.)
</itemize>

<sect> Vendor Contact Information <p>
<descrip>
<tag/ATI Technologies (VGA-Wonder, Mach8, Mach32)
     33 Commerce Valley Drive East/
Thornhill, Ontario <newline>
Canada L3T 7N6 <newline>
(905) 882-2600 (sales) <newline>
(905) 882-2626 (tech support) <newline>
(905) 764-9404 (BBS) <newline>
(905) 882-0546 (fax) <newline>

<tag/Chips &amp; Technologies/
???

<tag/Cirrus Logic (SVGA, Accelerators - CL-GD5426)/
3100 West Warren Ave. <newline>
Fremont, CA  94538 <newline>
(510) 623-8300 (N. CA, USA) <newline>
(49) 8152-40084 (Germany) <newline>
(44) 0727-872424 (UK) <newline>

<tag/Genoa Systems (GVGA)/
75 E. Trimble Road <newline>
San Jose, CA 95131 <newline>
(408) 432-9090 (sales) <newline>
(408) 432-8324 (tech support) <newline>

<tag/Headland Technologies, Inc (Video-7 VGA 1024i, VRAM II)/
46221 Landing Parkway <newline>
Fremont, CA  94538 <newline>
(415) 623-7857 <newline>

<tag/Oak Technology, Inc (OTI-067,OTI-077)/
139 Kifer Ct. <newline>
Sunnyvale, CA 94086 <newline>
(408) 737-0888 <newline>
(408) 737-3838 (fax)

<tag>S3 (911, 924, 801/805, 928, 864, 868, 964, 968, 764, 765)</tag>
(408) 980-5400

<tag/Trident Microsystems Inc (8800, 8900, 9000)/
205 Ravendale Dr <newline>
Mountainside, CA 94043 <newline>
(415) 691-9211

<tag/Tseng Labs Inc,/
6 Terry Drive <newline>
Newtown, PA  18940 <newline>
(215) 968-0502

<tag/Weitek (Power9000, 5186)/
1060 E. Arques Ave, <newline>
Sunnyvale, CA  94086 <newline>
(408) 738-5765 

<tag/Western Digital/
(714) 932-4900
</descrip>

<verb>
$XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/VGADriv.sgml,v 3.13 1997/01/25 03:22:16 dawes Exp $





$XConsortium: VGADriv.sgml /main/9 1996/10/28 05:13:22 kaleb $
</verb>

</article>
