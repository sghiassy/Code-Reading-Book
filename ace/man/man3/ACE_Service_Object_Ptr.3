.TH ACE_Service_Object_Ptr 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_Service_Object_Ptr \- This is a smart pointer that holds onto the associated  * until the current scope is left, at which point the object's <fini> hook is called and the service_object_ gets deleted. 
.SH SYNOPSIS
.br
.PP
\fC#include <Service_Object.h>\fR
.PP
.SS Public Methods

.in +1c
.ti -1c
.RI "\fBACE_Service_Object_Ptr\fR (\fBACE_Service_Object\fR *so)"
.br
.RI "\fIAcquire ownership of the <so>.\fR"
.ti -1c
.RI "\fB~ACE_Service_Object_Ptr\fR (void)"
.br
.RI "\fIRelease the held  by calling its <fini> hook.\fR"
.ti -1c
.RI "\fBACE_Service_Object\fR* \fBoperator->\fR ()"
.br
.RI "\fISmart pointer to access the underlying .\fR"
.in -1c
.SS Private Attributes

.in +1c
.ti -1c
.RI "\fBACE_Service_Object\fR* \fBservice_object_\fR"
.br
.RI "\fIHolds the service object until we're done.\fR"
.in -1c
.SH DETAILED DESCRIPTION
.PP 
This is a smart pointer that holds onto the associated  * until the current scope is left, at which point the object's <fini> hook is called and the service_object_ gets deleted.
.PP
.PP
 This class is similar to the Standard C++ Library class . It is used in conjunction with statically linked , as shown in the ./netsvcs/server/main.cpp example. 
.PP
.SH CONSTRUCTOR & DESTRUCTOR DOCUMENTATION
.PP 
.SS ACE_Service_Object_Ptr::ACE_Service_Object_Ptr (\fBACE_Service_Object\fR * so)
.PP
Acquire ownership of the <so>.
.PP
.SS ACE_Service_Object_Ptr::~ACE_Service_Object_Ptr (void)
.PP
Release the held  by calling its <fini> hook.
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS \fBACE_Service_Object\fR * ACE_Service_Object_Ptr::operator-> (void)
.PP
Smart pointer to access the underlying .
.PP
.SH MEMBER DATA DOCUMENTATION
.PP 
.SS \fBACE_Service_Object\fR * ACE_Service_Object_Ptr::service_object_\fC [private]\fR
.PP
Holds the service object until we're done.
.PP


.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.