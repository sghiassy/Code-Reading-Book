.TH ACE_Atomic_Op 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_Atomic_Op \- Transparently parameterizes synchronization into basic arithmetic operations. 
.SH SYNOPSIS
.br
.PP
\fC#include <Synch_T.h>\fR
.PP
.SS Public Methods

.in +1c
.ti -1c
.RI "\fBACE_Atomic_Op\fR (void)"
.br
.RI "\fIInitialize <value_> to 0.\fR"
.ti -1c
.RI "\fBACE_Atomic_Op\fR (const TYPE &c)"
.br
.RI "\fIInitialize <value_> to c.\fR"
.ti -1c
.RI "TYPE \fBoperator++\fR (void)"
.br
.RI "\fIAtomically pre-increment <value_>.\fR"
.ti -1c
.RI "TYPE \fBoperator++\fR (int)"
.br
.RI "\fIAtomically post-increment <value_>.\fR"
.ti -1c
.RI "TYPE \fBoperator+=\fR (const TYPE &i)"
.br
.RI "\fIAtomically increment <value_> by i.\fR"
.ti -1c
.RI "TYPE \fBoperator--\fR (void)"
.br
.RI "\fIAtomically pre-decrement <value_>.\fR"
.ti -1c
.RI "TYPE \fBoperator--\fR (int)"
.br
.RI "\fIAtomically post-decrement <value_>.\fR"
.ti -1c
.RI "TYPE \fBoperator-=\fR (const TYPE &i)"
.br
.RI "\fIAtomically decrement <value_> by i.\fR"
.ti -1c
.RI "int \fBoperator==\fR (const TYPE &i) const"
.br
.RI "\fIAtomically compare <value_> with i.\fR"
.ti -1c
.RI "int \fBoperator!=\fR (const TYPE &i) const"
.br
.RI "\fIAtomically compare <value_> with i.\fR"
.ti -1c
.RI "int \fBoperator>=\fR (const TYPE &i) const"
.br
.RI "\fIAtomically check if <value_> greater than or equal to i.\fR"
.ti -1c
.RI "int \fBoperator>\fR (const TYPE &rhs) const"
.br
.RI "\fIAtomically check if <value_> greater than i.\fR"
.ti -1c
.RI "int \fBoperator<=\fR (const TYPE &rhs) const"
.br
.RI "\fIAtomically check if <value_> less than or equal to i.\fR"
.ti -1c
.RI "int \fBoperator<\fR (const TYPE &rhs) const"
.br
.RI "\fIAtomically check if <value_> less than i.\fR"
.ti -1c
.RI "void \fBoperator=\fR (const TYPE &i)"
.br
.RI "\fIAtomically assign i to <value_>.\fR"
.ti -1c
.RI "void \fBoperator=\fR (const ACE_Atomic_Op<ACE_LOCK, TYPE> &rhs)"
.br
.RI "\fIAtomically assign <rhs> to <value_>.\fR"
.ti -1c
.RI "TYPE \fBvalue\fR (void) const"
.br
.RI "\fIExplicitly return <value_>.\fR"
.ti -1c
.RI "void \fBdump\fR (void) const"
.br
.RI "\fIDump the state of an object.\fR"
.ti -1c
.RI "\fBACE_Atomic_Op\fR (const ACE_Atomic_Op<ACE_LOCK, TYPE> &)"
.br
.RI "\fIManage copying...\fR"
.ti -1c
.RI "ACE_LOCK& \fBmutex\fR (void)"
.br
.ti -1c
.RI "TYPE& \fBvalue_i\fR (void)"
.br
.in -1c
.SS Private Attributes

.in +1c
.ti -1c
.RI "ACE_LOCK \fBmutex_\fR"
.br
.RI "\fIType of synchronization mechanism.\fR"
.ti -1c
.RI "TYPE \fBvalue_\fR"
.br
.RI "\fICurrent object decorated by the atomic op.\fR"
.in -1c
.SH DETAILED DESCRIPTION
.PP 

.SS template<class ACE_LOCK, class TYPE>  template class ACE_Atomic_Op
Transparently parameterizes synchronization into basic arithmetic operations.
.PP
.PP
 This class is described in an article in the July/August 1994 issue of the C++ Report magazine. It implements a templatized version of the Decorator pattern from the GoF book. 
.PP
.SH CONSTRUCTOR & DESTRUCTOR DOCUMENTATION
.PP 
.SS template<classACE_LOCK, classTYPE> ACE_Atomic_Op<ACE_LOCK, TYPE>::ACE_Atomic_Op<ACE_LOCK, TYPE> (void)
.PP
Initialize <value_> to 0.
.PP
.SS template<classACE_LOCK, classTYPE> ACE_Atomic_Op<ACE_LOCK, TYPE>::ACE_Atomic_Op<ACE_LOCK, TYPE> (const TYPE & c)
.PP
Initialize <value_> to c.
.PP
.SS template<classACE_LOCK, classTYPE> ACE_Atomic_Op<ACE_LOCK, TYPE>::ACE_Atomic_Op<ACE_LOCK, TYPE> (const ACE_Atomic_Op< ACE_LOCK,TYPE >&)
.PP
Manage copying...
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS template<classACE_LOCK, classTYPE> void ACE_Atomic_Op<ACE_LOCK, TYPE>::dump (void) const
.PP
Dump the state of an object.
.PP
.SS template<classACE_LOCK, classTYPE> ACE_LOCK & ACE_Atomic_Op<ACE_LOCK, TYPE>::mutex (void)
.PP
Returns a reference to the underlying . This makes it possible to acquire the lock explicitly, which can be useful in some cases if you instantiate the  with an  or . NOTE: the right name would be lock_, but HP/C++ will choke on that! 
.SS template<classACE_LOCK, classTYPE> int ACE_Atomic_Op<ACE_LOCK, TYPE>::operator!= (const TYPE & i) const
.PP
Atomically compare <value_> with i.
.PP
.SS template<classACE_LOCK, classTYPE> TYPE ACE_Atomic_Op<ACE_LOCK, TYPE>::operator++ (int)
.PP
Atomically post-increment <value_>.
.PP
.SS template<classACE_LOCK, classTYPE> TYPE ACE_Atomic_Op<ACE_LOCK, TYPE>::operator++ (void)
.PP
Atomically pre-increment <value_>.
.PP
.SS template<classACE_LOCK, classTYPE> TYPE ACE_Atomic_Op<ACE_LOCK, TYPE>::operator+= (const TYPE & i)
.PP
Atomically increment <value_> by i.
.PP
.SS template<classACE_LOCK, classTYPE> TYPE ACE_Atomic_Op<ACE_LOCK, TYPE>::operator-- (int)
.PP
Atomically post-decrement <value_>.
.PP
.SS template<classACE_LOCK, classTYPE> TYPE ACE_Atomic_Op<ACE_LOCK, TYPE>::operator-- (void)
.PP
Atomically pre-decrement <value_>.
.PP
.SS template<classACE_LOCK, classTYPE> TYPE ACE_Atomic_Op<ACE_LOCK, TYPE>::operator-= (const TYPE & i)
.PP
Atomically decrement <value_> by i.
.PP
.SS template<classACE_LOCK, classTYPE> int ACE_Atomic_Op<ACE_LOCK, TYPE>::operator< (const TYPE & rhs) const
.PP
Atomically check if <value_> less than i.
.PP
.SS template<classACE_LOCK, classTYPE> int ACE_Atomic_Op<ACE_LOCK, TYPE>::operator<= (const TYPE & rhs) const
.PP
Atomically check if <value_> less than or equal to i.
.PP
.SS template<classACE_LOCK, classTYPE> void ACE_Atomic_Op<ACE_LOCK, TYPE>::operator= (const ACE_Atomic_Op< ACE_LOCK,TYPE >& rhs)
.PP
Atomically assign <rhs> to <value_>.
.PP
.SS template<classACE_LOCK, classTYPE> void ACE_Atomic_Op<ACE_LOCK, TYPE>::operator= (const TYPE & i)
.PP
Atomically assign i to <value_>.
.PP
.SS template<classACE_LOCK, classTYPE> int ACE_Atomic_Op<ACE_LOCK, TYPE>::operator== (const TYPE & i) const
.PP
Atomically compare <value_> with i.
.PP
.SS template<classACE_LOCK, classTYPE> int ACE_Atomic_Op<ACE_LOCK, TYPE>::operator> (const TYPE & rhs) const
.PP
Atomically check if <value_> greater than i.
.PP
.SS template<classACE_LOCK, classTYPE> int ACE_Atomic_Op<ACE_LOCK, TYPE>::operator>= (const TYPE & i) const
.PP
Atomically check if <value_> greater than or equal to i.
.PP
.SS template<classACE_LOCK, classTYPE> TYPE ACE_Atomic_Op<ACE_LOCK, TYPE>::value (void) const
.PP
Explicitly return <value_>.
.PP
.SS template<classACE_LOCK, classTYPE> TYPE & ACE_Atomic_Op<ACE_LOCK, TYPE>::value_i (void)
.PP
Explicitly return <value_> (by reference). This gives the user full, unrestricted access to the underlying value. This method will usually be used in conjunction with explicit access to the lock. Use with care ;-) 
.SH MEMBER DATA DOCUMENTATION
.PP 
.SS template<classACE_LOCK, classTYPE> ACE_LOCK ACE_Atomic_Op<ACE_LOCK, TYPE>::mutex_\fC [private]\fR
.PP
Type of synchronization mechanism.
.PP
.SS template<classACE_LOCK, classTYPE> TYPE ACE_Atomic_Op<ACE_LOCK, TYPE>::value_\fC [private]\fR
.PP
Current object decorated by the atomic op.
.PP


.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.