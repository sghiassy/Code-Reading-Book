.TH ACE_INET_Addr 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_INET_Addr \- Defines a C++ wrapper facade for the Internet domain address family format. 
.SH SYNOPSIS
.br
.PP
\fC#include <INET_Addr.h>\fR
.PP
Inherits \fBACE_Addr\fR.
.PP
.SS Public Methods

.in +1c
.ti -1c
.RI "\fBACE_INET_Addr\fR (void)"
.br
.RI "\fIDefault constructor.\fR"
.ti -1c
.RI "\fBACE_INET_Addr\fR (const ACE_INET_Addr &)"
.br
.RI "\fICopy constructor.\fR"
.ti -1c
.RI "\fBACE_INET_Addr\fR (const sockaddr_in *, int len)"
.br
.RI "\fICreates an  from a sockaddr_in structure.\fR"
.ti -1c
.RI "\fBACE_INET_Addr\fR (u_short port_number, const char host_name[])"
.br
.RI "\fICreates an  from a <port_number> and the remote <host_name>. The port number is assumed to be in host byte order. To set a port already in network byte order, please 
.PP
\fBSee also: \fR
.in +1c
 \fBset\fR().\fR"
.ti -1c
.RI "ACE_EXPLICIT \fBACE_INET_Addr\fR (const char address[])"
.br
.ti -1c
.RI "\fBACE_INET_Addr\fR (u_short port_number, ACE_UINT32 ip_addr = INADDR_ANY)"
.br
.ti -1c
.RI "\fBACE_INET_Addr\fR (const char port_name[], const char host_name[], const char protocol[] = "tcp")"
.br
.RI "\fIUses <getservbyname> to create an  from a <port_name>, the remote <host_name>, and the <protocol>.\fR"
.ti -1c
.RI "\fBACE_INET_Addr\fR (const char port_name[], ACE_UINT32 ip_addr, const char protocol[] = "tcp")"
.br
.ti -1c
.RI "\fBACE_INET_Addr\fR (u_short port_number, const wchar_t host_name[])"
.br
.ti -1c
.RI "ACE_EXPLICIT \fBACE_INET_Addr\fR (const wchar_t address[])"
.br
.ti -1c
.RI "\fBACE_INET_Addr\fR (const wchar_t port_name[], const wchar_t host_name[], const wchar_t protocol[] = ACE_TEXT_WIDE ("tcp"))"
.br
.ti -1c
.RI "\fBACE_INET_Addr\fR (const wchar_t port_name[], ACE_UINT32 ip_addr, const wchar_t protocol[] = ACE_TEXT_WIDE ("tcp"))"
.br
.ti -1c
.RI "\fB~ACE_INET_Addr\fR (void)"
.br
.RI "\fIDefault dtor.\fR"
.ti -1c
.RI "int \fBset\fR (const ACE_INET_Addr &)"
.br
.RI "\fIInitializes from another .\fR"
.ti -1c
.RI "int \fBset\fR (u_short port_number, const char host_name[], int encode = 1)"
.br
.ti -1c
.RI "int \fBset\fR (u_short port_number, ACE_UINT32 ip_addr = INADDR_ANY, int encode = 1)"
.br
.ti -1c
.RI "int \fBset\fR (const char port_name[], const char host_name[], const char protocol[] = "tcp")"
.br
.RI "\fIUses <getservbyname> to initialize an  from a <port_name>, the remote <host_name>, and the <protocol>.\fR"
.ti -1c
.RI "int \fBset\fR (const char port_name[], ACE_UINT32 ip_addr, const char protocol[] = "tcp")"
.br
.ti -1c
.RI "int \fBset\fR (const char addr[])"
.br
.ti -1c
.RI "int \fBset\fR (const sockaddr_in *, int len)"
.br
.RI "\fICreates an  from a sockaddr_in structure.\fR"
.ti -1c
.RI "int \fBset\fR (u_short port_number, const wchar_t host_name[], int encode = 1)"
.br
.ti -1c
.RI "int \fBset\fR (const wchar_t port_name[], const wchar_t host_name[], const wchar_t protocol[] = ACE_TEXT_WIDE ("tcp"))"
.br
.ti -1c
.RI "int \fBset\fR (const wchar_t port_name[], ACE_UINT32 ip_addr, const wchar_t protocol[] = ACE_TEXT_WIDE ("tcp"))"
.br
.ti -1c
.RI "int \fBset\fR (const wchar_t addr[])"
.br
.ti -1c
.RI "virtual void* \fBget_addr\fR (void) const"
.br
.RI "\fIReturn a pointer to the underlying network address.\fR"
.ti -1c
.RI "virtual void \fBset_addr\fR (void *, int len)"
.br
.RI "\fISet a pointer to the address.\fR"
.ti -1c
.RI "virtual int \fBaddr_to_string\fR (\fBACE_TCHAR\fR buffer[], size_t size, int ipaddr_format = 1) const"
.br
.ti -1c
.RI "virtual int \fBstring_to_addr\fR (const char address[])"
.br
.ti -1c
.RI "void \fBset_port_number\fR (u_short, int encode = 1)"
.br
.ti -1c
.RI "u_short \fBget_port_number\fR (void) const"
.br
.RI "\fIReturn the port number, converting it into host byte-order.\fR"
.ti -1c
.RI "int \fBget_host_name\fR (char hostname[], size_t hostnamelen) const"
.br
.ti -1c
.RI "int \fBget_host_name\fR (wchar_t hostname[], size_t hostnamelen) const"
.br
.ti -1c
.RI "const char* \fBget_host_name\fR (void) const"
.br
.ti -1c
.RI "const char* \fBget_host_addr\fR (void) const"
.br
.RI "\fIReturn the "dotted decimal" Internet address.\fR"
.ti -1c
.RI "ACE_UINT32 \fBget_ip_address\fR (void) const"
.br
.RI "\fIReturn the 4-byte IP address, converting it into host byte order.\fR"
.ti -1c
.RI "int \fBoperator<\fR (const ACE_INET_Addr &rhs) const"
.br
.ti -1c
.RI "int \fBoperator==\fR (const ACE_INET_Addr &SAP) const"
.br
.RI "\fICompare two addresses for equality. The addresses are considered equal if they contain the same IP address and port number.\fR"
.ti -1c
.RI "int \fBoperator!=\fR (const ACE_INET_Addr &SAP) const"
.br
.RI "\fICompare two addresses for inequality.\fR"
.ti -1c
.RI "virtual u_long \fBhash\fR (void) const"
.br
.RI "\fIComputes and returns hash value.\fR"
.ti -1c
.RI "void \fBdump\fR (void) const"
.br
.RI "\fIDump the state of an object.\fR"
.in -1c
.SS Public Attributes

.in +1c
.ti -1c
.RI "\fBACE_ALLOC_HOOK_DECLARE\fR"
.br
.RI "\fIDeclare the dynamic allocation hooks.\fR"
.in -1c
.SS Private Methods

.in +1c
.ti -1c
.RI "int \fBget_host_name_i\fR (char hostname[], size_t hostnamelen) const"
.br
.RI "\fIInsure that 
.TP
 hostname is properly null-terminated.\fR"
.in -1c
.SS Private Attributes

.in +1c
.ti -1c
.RI "sockaddr_in \fBinet_addr_\fR"
.br
.RI "\fIUnderlying representation.\fR"
.in -1c
.SH DETAILED DESCRIPTION
.PP 
Defines a C++ wrapper facade for the Internet domain address family format.
.PP
.SH CONSTRUCTOR & DESTRUCTOR DOCUMENTATION
.PP 
.SS ACE_INET_Addr::ACE_INET_Addr (void)
.PP
Default constructor.
.PP
.SS ACE_INET_Addr::ACE_INET_Addr (const ACE_INET_Addr &)
.PP
Copy constructor.
.PP
.SS ACE_INET_Addr::ACE_INET_Addr (const sockaddr_in *, int len)
.PP
Creates an  from a sockaddr_in structure.
.PP
.SS ACE_INET_Addr::ACE_INET_Addr (u_short port_number, const char host_name[])
.PP
Creates an  from a <port_number> and the remote <host_name>. The port number is assumed to be in host byte order. To set a port already in network byte order, please 
.PP
\fBSee also: \fR
.in +1c
 \fBset\fR().
.PP
.SS ACE_EXPLICIT ACE_INET_Addr::ACE_INET_Addr (const char address[])
.PP
Initializes an  from the , which can be "ip-number:port-number" (e.g., "tango.cs.wustl.edu:1234" or "128.252.166.57:1234"). If there is no ':' in the  it is assumed to be a port number, with the IP address being INADDR_ANY. 
.SS ACE_INET_Addr::ACE_INET_Addr (u_short port_number, ACE_UINT32 ip_addr = INADDR_ANY)
.PP
Creates an  from a <port_number> and an Internet <ip_addr>. This method assumes that <port_number> and <ip_addr> are in host byte order. If you have addressing information in network byte order, 
.PP
\fBSee also: \fR
.in +1c
 \fBset\fR(). 
.SS ACE_INET_Addr::ACE_INET_Addr (const char port_name[], const char host_name[], const char protocol[] = "tcp")
.PP
Uses <getservbyname> to create an  from a <port_name>, the remote <host_name>, and the <protocol>.
.PP
.SS ACE_INET_Addr::ACE_INET_Addr (const char port_name[], ACE_UINT32 ip_addr, const char protocol[] = "tcp")
.PP
Uses <getservbyname> to create an  from a <port_name>, an Internet <ip_addr>, and the <protocol>. This method assumes that <ip_addr> is in host byte order. 
.SS ACE_INET_Addr::ACE_INET_Addr (u_short port_number, const wchar_t host_name[])
.PP
.SS ACE_EXPLICIT ACE_INET_Addr::ACE_INET_Addr (const wchar_t address[])
.PP
.SS ACE_INET_Addr::ACE_INET_Addr (const wchar_t port_name[], const wchar_t host_name[], const wchar_t protocol[] = ACE_TEXT_WIDE ("tcp"))
.PP
.SS ACE_INET_Addr::ACE_INET_Addr (const wchar_t port_name[], ACE_UINT32 ip_addr, const wchar_t protocol[] = ACE_TEXT_WIDE ("tcp"))
.PP
.SS ACE_INET_Addr::~ACE_INET_Addr (void)
.PP
Default dtor.
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS int ACE_INET_Addr::addr_to_string (\fBACE_TCHAR\fR buffer[], size_t size, int ipaddr_format = 1) const\fC [virtual]\fR
.PP
Transform the current  address into string format. If <ipaddr_format> is non-0 this produces "ip-number:port-number" (e.g., "128.252.166.57:1234"), whereas if <ipaddr_format> is 0 this produces "ip-name:port-number" (e.g., "tango.cs.wustl.edu:1234"). Returns -1 if the <size> of the <buffer> is too small, else 0. 
.SS void ACE_INET_Addr::dump (void) const
.PP
Dump the state of an object.
.PP
Reimplemented from \fBACE_Addr\fR.
.SS void * ACE_INET_Addr::get_addr (void) const\fC [virtual]\fR
.PP
Return a pointer to the underlying network address.
.PP
Reimplemented from \fBACE_Addr\fR.
.SS const char * ACE_INET_Addr::get_host_addr (void) const
.PP
Return the "dotted decimal" Internet address.
.PP
.SS const char * ACE_INET_Addr::get_host_name (void) const
.PP
Return the character representation of the hostname (this version is non-reentrant since it returns a pointer to a static data area). 
.SS int ACE_INET_Addr::get_host_name (wchar_t hostname[], size_t hostnamelen) const
.PP
.SS int ACE_INET_Addr::get_host_name (char hostname[], size_t hostnamelen) const
.PP
Return the character representation of the name of the host, storing it in the <hostname> (which is assumed to be <hostnamelen> bytes long). This version is reentrant. If <hostnamelen> is greater than 0 then <hostname> will be NUL-terminated even if -1 is returned. 
.SS int ACE_INET_Addr::get_host_name_i (char hostname[], size_t hostnamelen) const\fC [private]\fR
.PP
Insure that 
.TP
 hostname is properly null-terminated.
.PP
.SS ACE_UINT32 ACE_INET_Addr::get_ip_address (void) const
.PP
Return the 4-byte IP address, converting it into host byte order.
.PP
.SS u_short ACE_INET_Addr::get_port_number (void) const
.PP
Return the port number, converting it into host byte-order.
.PP
.SS u_long ACE_INET_Addr::hash (void) const\fC [virtual]\fR
.PP
Computes and returns hash value.
.PP
Reimplemented from \fBACE_Addr\fR.
.SS int ACE_INET_Addr::operator!= (const ACE_INET_Addr & SAP) const
.PP
Compare two addresses for inequality.
.PP
.SS int ACE_INET_Addr::operator< (const ACE_INET_Addr & rhs) const
.PP
Returns true if <this> is less than <rhs>. In this context, "less than" is defined in terms of IP address and TCP port number. This operator makes it possible to use s in STL maps. 
.SS int ACE_INET_Addr::operator== (const ACE_INET_Addr & SAP) const
.PP
Compare two addresses for equality. The addresses are considered equal if they contain the same IP address and port number.
.PP
.SS int ACE_INET_Addr::set (const wchar_t addr[])
.PP
.SS int ACE_INET_Addr::set (const wchar_t port_name[], ACE_UINT32 ip_addr, const wchar_t protocol[] = ACE_TEXT_WIDE ("tcp"))
.PP
.SS int ACE_INET_Addr::set (const wchar_t port_name[], const wchar_t host_name[], const wchar_t protocol[] = ACE_TEXT_WIDE ("tcp"))
.PP
.SS int ACE_INET_Addr::set (u_short port_number, const wchar_t host_name[], int encode = 1)
.PP
.SS int ACE_INET_Addr::set (const sockaddr_in *, int len)
.PP
Creates an  from a sockaddr_in structure.
.PP
.SS int ACE_INET_Addr::set (const char addr[])
.PP
Initializes an  from the , which can be "ip-number:port-number" (e.g., "tango.cs.wustl.edu:1234" or "128.252.166.57:1234"). If there is no ':' in the  it is assumed to be a port number, with the IP address being INADDR_ANY. 
.SS int ACE_INET_Addr::set (const char port_name[], ACE_UINT32 ip_addr, const char protocol[] = "tcp")
.PP
Uses <getservbyname> to initialize an  from a <port_name>, an <ip_addr>, and the <protocol>. This assumes that <ip_addr> is already in network byte order. 
.SS int ACE_INET_Addr::set (const char port_name[], const char host_name[], const char protocol[] = "tcp")
.PP
Uses <getservbyname> to initialize an  from a <port_name>, the remote <host_name>, and the <protocol>.
.PP
.SS int ACE_INET_Addr::set (u_short port_number, ACE_UINT32 ip_addr = INADDR_ANY, int encode = 1)
.PP
Initializes an  from a 
.PP
\fBParameters: \fR
.in +1c
.TP
\fB\fIport_number\fR\fR and an Internet 
.TP
\fB\fIip_addr.\fR\fR If 
.TP
\fB\fIencode\fR\fR is non-zero then the port number and IP address are converted into network byte order, otherwise they are assumed to be in network byte order already and are passed straight through. 
.SS int ACE_INET_Addr::set (u_short port_number, const char host_name[], int encode = 1)
.PP
Initializes an  from a <port_number> and the remote <host_name>. If <encode> is non-zero then <port_number> is converted into network byte order, otherwise it is assumed to be in network byte order already and are passed straight through. 
.SS int ACE_INET_Addr::set (const ACE_INET_Addr &)
.PP
Initializes from another .
.PP
.SS void ACE_INET_Addr::set_addr (void * addr, int len)\fC [virtual]\fR
.PP
Set a pointer to the address.
.PP
Reimplemented from \fBACE_Addr\fR.
.SS void ACE_INET_Addr::set_port_number (u_short, int encode = 1)
.PP
Sets the port number without affecting the host name. If <encode> is enabled then <port_number> is converted into network byte order, otherwise it is assumed to be in network byte order already and are passed straight through. 
.SS int ACE_INET_Addr::string_to_addr (const char address[])\fC [virtual]\fR
.PP
Initializes an  from the , which can be "ip-addr:port-number" (e.g., "tango.cs.wustl.edu:1234"), "ip-addr:port-name" (e.g., "tango.cs.wustl.edu:telnet"), "ip-number:port-number" (e.g., "128.252.166.57:1234"), or "ip-number:port-name" (e.g., "128.252.166.57:telnet"). If there is no ':' in the  it is assumed to be a port number, with the IP address being INADDR_ANY. 
.SH MEMBER DATA DOCUMENTATION
.PP 
.SS ACE_INET_Addr::ACE_ALLOC_HOOK_DECLARE
.PP
Declare the dynamic allocation hooks.
.PP
Reimplemented from \fBACE_Addr\fR.
.SS sockaddr_in ACE_INET_Addr::inet_addr_\fC [private]\fR
.PP
Underlying representation.
.PP


.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.