.TH ACE_Double_Linked_List_Reverse_Iterator 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_Double_Linked_List_Reverse_Iterator \- Implements a reverse iterator for a double linked list ADT. 
.SH SYNOPSIS
.br
.PP
\fC#include <Containers_T.h>\fR
.PP
Inherits \fBACE_Double_Linked_List_Iterator_Base< T >\fR.
.PP
Inherited by \fBACE_DLList_Reverse_Iterator\fR.
.PP
.SS Public Methods

.in +1c
.ti -1c
.RI "\fBACE_Double_Linked_List_Reverse_Iterator\fR (\fBACE_Double_Linked_List\fR<T> &)"
.br
.ti -1c
.RI "void \fBreset\fR (\fBACE_Double_Linked_List\fR<T> &)"
.br
.ti -1c
.RI "int \fBfirst\fR (void)"
.br
.RI "\fIMove to the first element in the list. Returns 0 if the list is empty, else 1.\fR"
.ti -1c
.RI "int \fBadvance\fR (void)"
.br
.RI "\fIMove forward by one element in the list. Returns 0 when all the items in the list have been seen, else 1.\fR"
.ti -1c
.RI "T* \fBadvance_and_remove\fR (int dont_remove)"
.br
.ti -1c
.RI "ACE_Double_Linked_List_Reverse_Iterator<T>& \fBoperator++\fR (void)"
.br
.RI "\fIPrefix advance.\fR"
.ti -1c
.RI "ACE_Double_Linked_List_Reverse_Iterator<T> \fBoperator++\fR (int)"
.br
.RI "\fIPostfix advance.\fR"
.ti -1c
.RI "ACE_Double_Linked_List_Reverse_Iterator<T>& \fBoperator--\fR (void)"
.br
.RI "\fIPrefix reverse.\fR"
.ti -1c
.RI "ACE_Double_Linked_List_Reverse_Iterator<T> \fBoperator--\fR (int)"
.br
.RI "\fIPostfix reverse.\fR"
.ti -1c
.RI "void \fBdump\fR (void) const"
.br
.RI "\fIDump the state of an object.\fR"
.in -1c
.SS Public Attributes

.in +1c
.ti -1c
.RI "\fBACE_ALLOC_HOOK_DECLARE\fR"
.br
.RI "\fIDeclare the dynamic allocation hooks.\fR"
.in -1c
.SH DETAILED DESCRIPTION
.PP 

.SS template<class T>  template class ACE_Double_Linked_List_Reverse_Iterator
Implements a reverse iterator for a double linked list ADT.
.PP
.PP
 Iterate backwards over the double-linked list. This class provide an interface that let users access the internal element addresses directly, which seems to break the encapsulation. Notice <class T> must delcare \fBACE_Double_Linked_List\fR<T>, \fBACE_Double_Linked_List_Iterator_Base\fR <T> and \fBACE_Double_Linked_List_Iterator\fR as friend classes and class T should also have data members T* next_ and T* prev_. 
.PP
.SH CONSTRUCTOR & DESTRUCTOR DOCUMENTATION
.PP 
.SS template<classT> ACE_Double_Linked_List_Reverse_Iterator<T>::ACE_Double_Linked_List_Reverse_Iterator<T> (\fBACE_Double_Linked_List\fR< T >&)
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS template<classT> int ACE_Double_Linked_List_Reverse_Iterator<T>::advance (void)
.PP
Move forward by one element in the list. Returns 0 when all the items in the list have been seen, else 1.
.PP
Reimplemented in \fBACE_DLList_Reverse_Iterator\fR.
.SS template<classT> T * ACE_Double_Linked_List_Reverse_Iterator<T>::advance_and_remove (int dont_remove)
.PP
Advance the iterator while removing the original item from the list. Return a pointer points to the original (removed) item. If <dont_remove> equals 0, this function behaves like  but return 0 (NULL) instead. 
.SS template<classT> void ACE_Double_Linked_List_Reverse_Iterator<T>::dump (void) const
.PP
Dump the state of an object.
.PP
Reimplemented in \fBACE_DLList_Reverse_Iterator\fR.
.SS template<classT> int ACE_Double_Linked_List_Reverse_Iterator<T>::first (void)
.PP
Move to the first element in the list. Returns 0 if the list is empty, else 1.
.PP
.SS template<classT> ACE_Double_Linked_List_Reverse_Iterator< T > ACE_Double_Linked_List_Reverse_Iterator<T>::operator++ (int)
.PP
Postfix advance.
.PP
.SS template<classT> ACE_Double_Linked_List_Reverse_Iterator< T >& ACE_Double_Linked_List_Reverse_Iterator<T>::operator++ (void)
.PP
Prefix advance.
.PP
.SS template<classT> ACE_Double_Linked_List_Reverse_Iterator< T > ACE_Double_Linked_List_Reverse_Iterator<T>::operator-- (int)
.PP
Postfix reverse.
.PP
.SS template<classT> ACE_Double_Linked_List_Reverse_Iterator< T >& ACE_Double_Linked_List_Reverse_Iterator<T>::operator-- (void)
.PP
Prefix reverse.
.PP
.SS template<classT> void ACE_Double_Linked_List_Reverse_Iterator<T>::reset (\fBACE_Double_Linked_List\fR< T >&)
.PP
Retasks the iterator to iterate over a new Double_Linked_List. This allows clients to reuse an iterator without incurring the constructor overhead. If you do use this, be aware that if there are more than one reference to this iterator, the other "clients" may be very bothered when their iterator changes. @ Here be dragons. Comments? 
.PP
Reimplemented from \fBACE_Double_Linked_List_Iterator_Base\fR.
.SH MEMBER DATA DOCUMENTATION
.PP 
.SS template<classT> ACE_Double_Linked_List_Reverse_Iterator<T>::ACE_ALLOC_HOOK_DECLARE
.PP
Declare the dynamic allocation hooks.
.PP
Reimplemented from \fBACE_Double_Linked_List_Iterator_Base\fR.

.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.