.TH ACE_Locked_Data_Block 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_Locked_Data_Block \- A Data_Block with a concrete locking strategy. 
.SH SYNOPSIS
.br
.PP
\fC#include <Message_Block_T.h>\fR
.PP
Inherits \fBACE_Data_Block\fR.
.PP
.SS Public Methods

.in +1c
.ti -1c
.RI "\fBACE_Locked_Data_Block\fR (void)"
.br
.RI "\fIDefault "do-nothing" constructor.\fR"
.ti -1c
.RI "\fBACE_Locked_Data_Block\fR (size_t size, \fBACE_Message_Block::ACE_Message_Type\fR msg_type, const char *msg_data, \fBACE_Allocator\fR *allocator_strategy, \fBACE_Message_Block::Message_Flags\fR flags, \fBACE_Allocator\fR *data_block_allocator)"
.br
.RI "\fIInitialize.\fR"
.ti -1c
.RI "virtual \fB~ACE_Locked_Data_Block\fR (void)"
.br
.RI "\fIDelete all the resources held in the message.\fR"
.ti -1c
.RI "virtual \fBACE_Data_Block\fR* \fBclone_nocopy\fR (\fBACE_Message_Block::Message_Flags\fR mask = 0) const"
.br
.in -1c
.SS Private Methods

.in +1c
.ti -1c
.RI "ACE_Locked_Data_Block<ACE_LOCK>& \fBoperator=\fR (const ACE_Locked_Data_Block<ACE_LOCK> &)"
.br
.ti -1c
.RI "\fBACE_Locked_Data_Block\fR (const ACE_Locked_Data_Block<ACE_LOCK> &)"
.br
.in -1c
.SS Private Attributes

.in +1c
.ti -1c
.RI "ACE_LOCK \fBlock_\fR"
.br
.RI "\fIThe lock.\fR"
.in -1c
.SH DETAILED DESCRIPTION
.PP 

.SS template<class ACE_LOCK>  template class ACE_Locked_Data_Block
A Data_Block with a concrete locking strategy.
.PP
.PP
 Data_Blocks can be parametric on the kind of lock they use; in many cases the lifetime of the lock is tied to the lifetime of the Data_Block itself. But since Data_Blocks are reference counted it is hard for users to control the lock lifetime. This class is parametric over the kind of lock used. 
.PP
.SH CONSTRUCTOR & DESTRUCTOR DOCUMENTATION
.PP 
.SS template<classACE_LOCK> ACE_Locked_Data_Block<ACE_LOCK>::ACE_Locked_Data_Block<ACE_LOCK> (void)
.PP
Default "do-nothing" constructor.
.PP
.SS template<classACE_LOCK> ACE_Locked_Data_Block<ACE_LOCK>::ACE_Locked_Data_Block<ACE_LOCK> (size_t size, \fBACE_Message_Block::ACE_Message_Type\fR msg_type, const char * msg_data, \fBACE_Allocator\fR * allocator_strategy, \fBACE_Message_Block::Message_Flags\fR flags, \fBACE_Allocator\fR * data_block_allocator)
.PP
Initialize.
.PP
.SS template<classACE_LOCK> ACE_Locked_Data_Block<ACE_LOCK>::~ACE_Locked_Data_Block<ACE_LOCK> (void)\fC [virtual]\fR
.PP
Delete all the resources held in the message.
.PP
.SS template<classACE_LOCK> ACE_Locked_Data_Block<ACE_LOCK>::ACE_Locked_Data_Block<ACE_LOCK> (const ACE_Locked_Data_Block< ACE_LOCK >&)\fC [private]\fR
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS template<classACE_LOCK> \fBACE_Data_Block\fR * ACE_Locked_Data_Block<ACE_LOCK>::clone_nocopy (\fBACE_Message_Block::Message_Flags\fR mask = 0) const\fC [virtual]\fR
.PP
Return an exact "deep copy" of the message, the dynamic type is ACE_Locked_Data_Block<> See the documentation in \fBMessage_Block.h\fR for details. 
.PP
Reimplemented from \fBACE_Data_Block\fR.
.SS template<classACE_LOCK> ACE_Locked_Data_Block<ACE_LOCK>& ACE_Locked_Data_Block<ACE_LOCK>::operator= (const ACE_Locked_Data_Block< ACE_LOCK >&)\fC [private]\fR
.PP
.SH MEMBER DATA DOCUMENTATION
.PP 
.SS template<classACE_LOCK> ACE_LOCK ACE_Locked_Data_Block<ACE_LOCK>::lock_\fC [private]\fR
.PP
The lock.
.PP


.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.