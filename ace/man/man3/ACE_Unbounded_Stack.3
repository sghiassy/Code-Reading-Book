.TH ACE_Unbounded_Stack 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_Unbounded_Stack \- Implement a generic LIFO abstract data type. 
.SH SYNOPSIS
.br
.PP
\fC#include <Containers_T.h>\fR
.PP
.SS Public Types

.in +1c
.ti -1c
.RI "typedef \fBACE_Unbounded_Stack_Iterator\fR<T> \fBITERATOR\fR"
.br
.in -1c
.SS Public Methods

.in +1c
.ti -1c
.RI "\fBACE_Unbounded_Stack\fR (\fBACE_Allocator\fR *alloc = 0)"
.br
.RI "\fIInitialize a new stack so that it is empty. Use user defined allocation strategy if specified.\fR"
.ti -1c
.RI "\fBACE_Unbounded_Stack\fR (const ACE_Unbounded_Stack<T> &s)"
.br
.RI "\fIThe copy constructor (performs initialization).\fR"
.ti -1c
.RI "void \fBoperator=\fR (const ACE_Unbounded_Stack<T> &s)"
.br
.RI "\fIAssignment operator(performs assignment).\fR"
.ti -1c
.RI "\fB~ACE_Unbounded_Stack\fR (void)"
.br
.RI "\fIPerform actions needed when stack goes out of scope.\fR"
.ti -1c
.RI "int \fBpush\fR (const T &new_item)"
.br
.ti -1c
.RI "int \fBpop\fR (T &item)"
.br
.ti -1c
.RI "int \fBtop\fR (T &item) const"
.br
.ti -1c
.RI "int \fBis_empty\fR (void) const"
.br
.RI "\fIReturns 1 if the container is empty, otherwise returns 0.\fR"
.ti -1c
.RI "int \fBis_full\fR (void) const"
.br
.RI "\fIReturns 1 if the container is full, otherwise returns 0.\fR"
.ti -1c
.RI "int \fBinsert\fR (const T &new_item)"
.br
.ti -1c
.RI "int \fBremove\fR (const T &item)"
.br
.RI "\fIRemove <item> from the Stack. Returns 0 if it removes the item, -1 if it can't find the item, and -1 if a failure occurs.\fR"
.ti -1c
.RI "int \fBfind\fR (const T &item) const"
.br
.RI "\fIFinds if <item> occurs the set. Returns 0 if finds, else -1.\fR"
.ti -1c
.RI "size_t \fBsize\fR (void) const"
.br
.RI "\fIThe number of items in the stack.\fR"
.ti -1c
.RI "void \fBdump\fR (void) const"
.br
.RI "\fIDump the state of an object.\fR"
.in -1c
.SS Public Attributes

.in +1c
.ti -1c
.RI "\fBACE_ALLOC_HOOK_DECLARE\fR"
.br
.RI "\fIDeclare the dynamic allocation hooks.\fR"
.in -1c
.SS Private Methods

.in +1c
.ti -1c
.RI "void \fBdelete_all_nodes\fR (void)"
.br
.RI "\fIDelete all the nodes in the stack.\fR"
.ti -1c
.RI "void \fBcopy_all_nodes\fR (const ACE_Unbounded_Stack<T> &s)"
.br
.RI "\fICopy all nodes from <s> to <this>.\fR"
.in -1c
.SS Private Attributes

.in +1c
.ti -1c
.RI "\fBACE_Node\fR<T>* \fBhead_\fR"
.br
.RI "\fIHead of the linked list of Nodes.\fR"
.ti -1c
.RI "size_t \fBcur_size_\fR"
.br
.RI "\fICurrent size of the stack.\fR"
.ti -1c
.RI "\fBACE_Allocator\fR* \fBallocator_\fR"
.br
.RI "\fIAllocation strategy of the stack.\fR"
.in -1c
.SS Friends

.in +1c
.ti -1c
.RI "class \fBACE_Unbounded_Stack_Iterator< T >\fR"
.br
.in -1c
.SH DETAILED DESCRIPTION
.PP 

.SS template<class T>  template class ACE_Unbounded_Stack
Implement a generic LIFO abstract data type.
.PP
.PP
 This implementation of an unbounded Stack uses a linked list. If you use the <insert> or <remove> methods you should keep in mind that duplicate entries aren't allowed. In general, therefore, you should avoid the use of these methods since they aren't really part of the ADT stack. 
.PP
.SH MEMBER TYPEDEF DOCUMENTATION
.PP 
.SS template<classT> typedef \fBACE_Unbounded_Stack_Iterator\fR<T> ACE_Unbounded_Stack<T>::ITERATOR
.PP
.SH CONSTRUCTOR & DESTRUCTOR DOCUMENTATION
.PP 
.SS template<classT> ACE_Unbounded_Stack<T>::ACE_Unbounded_Stack<T> (\fBACE_Allocator\fR * alloc = 0)
.PP
Initialize a new stack so that it is empty. Use user defined allocation strategy if specified.
.PP
.SS template<classT> ACE_Unbounded_Stack<T>::ACE_Unbounded_Stack<T> (const ACE_Unbounded_Stack< T >& s)
.PP
The copy constructor (performs initialization).
.PP
.SS template<classT> ACE_Unbounded_Stack<T>::~ACE_Unbounded_Stack<T> (void)
.PP
Perform actions needed when stack goes out of scope.
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS template<classT> void ACE_Unbounded_Stack<T>::copy_all_nodes (const ACE_Unbounded_Stack< T >& s)\fC [private]\fR
.PP
Copy all nodes from <s> to <this>.
.PP
.SS template<classT> void ACE_Unbounded_Stack<T>::delete_all_nodes (void)\fC [private]\fR
.PP
Delete all the nodes in the stack.
.PP
.SS template<classT> void ACE_Unbounded_Stack<T>::dump (void) const
.PP
Dump the state of an object.
.PP
.SS template<classT> int ACE_Unbounded_Stack<T>::find (const T & item) const
.PP
Finds if <item> occurs the set. Returns 0 if finds, else -1.
.PP
.SS template<classT> int ACE_Unbounded_Stack<T>::insert (const T & new_item)
.PP
Insert <new_item> into the Stack at the head (but doesn't allow duplicates). Returns -1 if failures occur, 1 if item is already present (i.e., no duplicates are allowed), else 0. 
.SS template<classT> int ACE_Unbounded_Stack<T>::is_empty (void) const
.PP
Returns 1 if the container is empty, otherwise returns 0.
.PP
.SS template<classT> int ACE_Unbounded_Stack<T>::is_full (void) const
.PP
Returns 1 if the container is full, otherwise returns 0.
.PP
.SS template<classT> void ACE_Unbounded_Stack<T>::operator= (const ACE_Unbounded_Stack< T >& s)
.PP
Assignment operator(performs assignment).
.PP
.SS template<classT> int ACE_Unbounded_Stack<T>::pop (T & item)
.PP
Remove and return the top stack item. Returns -1 if the stack is already empty, 0 if the stack is not already empty, and -1 if failure occurs. 
.SS template<classT> int ACE_Unbounded_Stack<T>::push (const T & new_item)
.PP
Place a new item on top of the stack. Returns -1 if the stack is already full, 0 if the stack is not already full, and -1 if failure occurs. 
.SS template<classT> int ACE_Unbounded_Stack<T>::remove (const T & item)
.PP
Remove <item> from the Stack. Returns 0 if it removes the item, -1 if it can't find the item, and -1 if a failure occurs.
.PP
.SS template<classT> size_t ACE_Unbounded_Stack<T>::size (void) const
.PP
The number of items in the stack.
.PP
.SS template<classT> int ACE_Unbounded_Stack<T>::top (T & item) const
.PP
Return top stack item without removing it. Returns -1 if the stack is already empty, 0 if the stack is not already empty, and -1 if failure occurs. 
.SH FRIENDS AND RELATED FUNCTION DOCUMENTATION
.PP 
.SS template<classT> class \fBACE_Unbounded_Stack_Iterator\fR\fC [friend]\fR
.PP
.SH MEMBER DATA DOCUMENTATION
.PP 
.SS template<classT> ACE_Unbounded_Stack<T>::ACE_ALLOC_HOOK_DECLARE
.PP
Declare the dynamic allocation hooks.
.PP
.SS template<classT> \fBACE_Allocator\fR * ACE_Unbounded_Stack<T>::allocator_\fC [private]\fR
.PP
Allocation strategy of the stack.
.PP
.SS template<classT> size_t ACE_Unbounded_Stack<T>::cur_size_\fC [private]\fR
.PP
Current size of the stack.
.PP
.SS template<classT> \fBACE_Node\fR< T >* ACE_Unbounded_Stack<T>::head_\fC [private]\fR
.PP
Head of the linked list of Nodes.
.PP


.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.