.TH ACE_Double_Linked_List_Iterator_Base 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_Double_Linked_List_Iterator_Base \- Implements a common base class for iterators for a double linked list ADT. 
.SH SYNOPSIS
.br
.PP
\fC#include <Containers_T.h>\fR
.PP
Inherited by \fBACE_Double_Linked_List_Iterator\fR, and \fBACE_Double_Linked_List_Reverse_Iterator\fR.
.PP
.SS Public Methods

.in +1c
.ti -1c
.RI "int \fBnext\fR (T *&) const"
.br
.RI "\fIPasses back the <entry> under the iterator. Returns 0 if the iteration has completed, otherwise 1.\fR"
.ti -1c
.RI "T* \fBnext\fR (void) const"
.br
.ti -1c
.RI "int \fBdone\fR (void) const"
.br
.RI "\fIReturns 1 when all items have been seen, else 0.\fR"
.ti -1c
.RI "T& \fBoperator *\fR (void) const"
.br
.RI "\fISTL-like iterator dereference operator: returns a reference to the node underneath the iterator.\fR"
.ti -1c
.RI "void \fBreset\fR (\fBACE_Double_Linked_List\fR<T> &)"
.br
.in -1c
.SS Public Attributes

.in +1c
.ti -1c
.RI "\fBACE_ALLOC_HOOK_DECLARE\fR"
.br
.RI "\fIDeclare the dynamic allocation hooks.\fR"
.in -1c
.SS Protected Methods

.in +1c
.ti -1c
.RI "\fBACE_Double_Linked_List_Iterator_Base\fR (const \fBACE_Double_Linked_List\fR<T> &)"
.br
.RI "\fIConstructor.\fR"
.ti -1c
.RI "\fBACE_Double_Linked_List_Iterator_Base\fR (const ACE_Double_Linked_List_Iterator_Base<T> &iter)"
.br
.RI "\fICopy constructor.\fR"
.ti -1c
.RI "int \fBgo_head\fR (void)"
.br
.ti -1c
.RI "int \fBgo_tail\fR (void)"
.br
.RI "\fIMove to the last element of the list. Returns 0 if the list is empty, else 1.\fR"
.ti -1c
.RI "T* \fBnot_done\fR (void) const"
.br
.ti -1c
.RI "T* \fBdo_advance\fR (void)"
.br
.RI "\fIAdvance to the next element in the list. Return the address of the next element if there are more, 0 otherwise.\fR"
.ti -1c
.RI "T* \fBdo_retreat\fR (void)"
.br
.RI "\fIRetreat to the previous element in the list. Return the address of the previous element if there are more, 0 otherwise.\fR"
.ti -1c
.RI "void \fBdump_i\fR (void) const"
.br
.RI "\fIDump the state of an object.\fR"
.in -1c
.SS Protected Attributes

.in +1c
.ti -1c
.RI "T* \fBcurrent_\fR"
.br
.RI "\fIRemember where we are.\fR"
.ti -1c
.RI "const \fBACE_Double_Linked_List\fR<T>* \fBdllist_\fR"
.br
.in -1c
.SH DETAILED DESCRIPTION
.PP 

.SS template<class T>  template class ACE_Double_Linked_List_Iterator_Base
Implements a common base class for iterators for a double linked list ADT.
.PP
.SH CONSTRUCTOR & DESTRUCTOR DOCUMENTATION
.PP 
.SS template<classT> ACE_Double_Linked_List_Iterator_Base<T>::ACE_Double_Linked_List_Iterator_Base<T> (const \fBACE_Double_Linked_List\fR< T >&)\fC [protected]\fR
.PP
Constructor.
.PP
.SS template<classT> ACE_Double_Linked_List_Iterator_Base<T>::ACE_Double_Linked_List_Iterator_Base<T> (const ACE_Double_Linked_List_Iterator_Base< T >& iter)\fC [protected]\fR
.PP
Copy constructor.
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS template<classT> T * ACE_Double_Linked_List_Iterator_Base<T>::do_advance (void)\fC [protected]\fR
.PP
Advance to the next element in the list. Return the address of the next element if there are more, 0 otherwise.
.PP
.SS template<classT> T * ACE_Double_Linked_List_Iterator_Base<T>::do_retreat (void)\fC [protected]\fR
.PP
Retreat to the previous element in the list. Return the address of the previous element if there are more, 0 otherwise.
.PP
.SS template<classT> int ACE_Double_Linked_List_Iterator_Base<T>::done (void) const
.PP
Returns 1 when all items have been seen, else 0.
.PP
.SS template<classT> void ACE_Double_Linked_List_Iterator_Base<T>::dump_i (void) const\fC [protected]\fR
.PP
Dump the state of an object.
.PP
.SS template<classT> int ACE_Double_Linked_List_Iterator_Base<T>::go_head (void)\fC [protected]\fR
.PP
Move to the first element of the list. Returns 0 if the list is empty, else 1. Note: the head of the \fBACE_DLList\fR is actually a null entry, so the first element is actually the 2n'd entry 
.SS template<classT> int ACE_Double_Linked_List_Iterator_Base<T>::go_tail (void)\fC [protected]\fR
.PP
Move to the last element of the list. Returns 0 if the list is empty, else 1.
.PP
.SS template<classT> T * ACE_Double_Linked_List_Iterator_Base<T>::next (void) const
.PP
Return the address of next (current) unvisited item in the list. 0 if there is no more element available. DEPRECATED 
.PP
Reimplemented in \fBACE_DLList_Iterator\fR, and \fBACE_DLList_Reverse_Iterator\fR.
.SS template<classT> int ACE_Double_Linked_List_Iterator_Base<T>::next (T *&) const
.PP
Passes back the <entry> under the iterator. Returns 0 if the iteration has completed, otherwise 1.
.PP
.SS template<classT> T * ACE_Double_Linked_List_Iterator_Base<T>::not_done (void) const\fC [protected]\fR
.PP
Check if we reach the end of the list. Can also be used to get the *current* element in the list. Return the address of the current item if there are still elements left , 0 if we run out of element. 
.SS template<classT> T & ACE_Double_Linked_List_Iterator_Base<T>::operator * (void) const
.PP
STL-like iterator dereference operator: returns a reference to the node underneath the iterator.
.PP
.SS template<classT> void ACE_Double_Linked_List_Iterator_Base<T>::reset (\fBACE_Double_Linked_List\fR< T >&)
.PP
Retasks the iterator to iterate over a new Double_Linked_List. This allows clients to reuse an iterator without incurring the constructor overhead. If you do use this, be aware that if there are more than one reference to this iterator, the other "clients" may be very bothered when their iterator changes. @ Here be dragons. Comments? 
.PP
Reimplemented in \fBACE_Double_Linked_List_Iterator\fR, and \fBACE_Double_Linked_List_Reverse_Iterator\fR.
.SH MEMBER DATA DOCUMENTATION
.PP 
.SS template<classT> ACE_Double_Linked_List_Iterator_Base<T>::ACE_ALLOC_HOOK_DECLARE
.PP
Declare the dynamic allocation hooks.
.PP
Reimplemented in \fBACE_Double_Linked_List_Iterator\fR, and \fBACE_Double_Linked_List_Reverse_Iterator\fR.
.SS template<classT> T * ACE_Double_Linked_List_Iterator_Base<T>::current_\fC [protected]\fR
.PP
Remember where we are.
.PP
.SS template<classT> const \fBACE_Double_Linked_List\fR< T >* ACE_Double_Linked_List_Iterator_Base<T>::dllist_\fC [protected]\fR
.PP


.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.