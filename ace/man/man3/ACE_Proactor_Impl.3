.TH ACE_Proactor_Impl 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_Proactor_Impl \- A manager for asynchronous event demultiplexing. This class is the base class for all the concrete implementation classes. 
.SH SYNOPSIS
.br
.PP
\fC#include <Proactor_Impl.h>\fR
.PP
Inherits \fBACE_Event_Handler\fR.
.PP
Inherited by \fBACE_POSIX_Proactor\fR, and \fBACE_WIN32_Proactor\fR.
.PP
.SS Public Methods

.in +1c
.ti -1c
.RI "virtual \fB~ACE_Proactor_Impl\fR (void)"
.br
.RI "\fIVirtual destruction.\fR"
.ti -1c
.RI "virtual int \fBclose\fR (void) = 0"
.br
.RI "\fIClose the IO completion port.\fR"
.ti -1c
.RI "virtual int \fBregister_handle\fR (ACE_HANDLE handle, const void *completion_key) = 0"
.br
.RI "\fIThis method adds the <handle> to the I/O completion port. This function is a no-op function for Unix systems.\fR"
.ti -1c
.RI "virtual int \fBhandle_events\fR (\fBACE_Time_Value\fR &wait_time) = 0"
.br
.ti -1c
.RI "virtual int \fBhandle_events\fR (void) = 0"
.br
.ti -1c
.RI "virtual int \fBwake_up_dispatch_threads\fR (void) = 0"
.br
.RI "\fIAdd wakeup dispatch threads (reinit).\fR"
.ti -1c
.RI "virtual int \fBclose_dispatch_threads\fR (int wait) = 0"
.br
.RI "\fIClose all dispatch threads.\fR"
.ti -1c
.RI "virtual size_t \fBnumber_of_threads\fR (void) const = 0"
.br
.RI "\fINumber of thread used as a parameter to CreatIoCompletionPort.\fR"
.ti -1c
.RI "virtual void \fBnumber_of_threads\fR (size_t threads) = 0"
.br
.ti -1c
.RI "virtual ACE_HANDLE \fBget_handle\fR (void) const = 0"
.br
.RI "\fIGet the event handle.\fR"
.ti -1c
.RI "virtual \fBACE_Asynch_Read_Stream_Impl\fR* \fBcreate_asynch_read_stream\fR (void) = 0"
.br
.RI "\fICreate the correct implementation class for doing Asynch_Read_Stream.\fR"
.ti -1c
.RI "virtual \fBACE_Asynch_Write_Stream_Impl\fR* \fBcreate_asynch_write_stream\fR (void) = 0"
.br
.RI "\fICreate the correct implementation class for doing Asynch_Write_Stream.\fR"
.ti -1c
.RI "virtual \fBACE_Asynch_Read_File_Impl\fR* \fBcreate_asynch_read_file\fR (void) = 0"
.br
.RI "\fICreate the correct implementation class for doing Asynch_Read_File.\fR"
.ti -1c
.RI "virtual \fBACE_Asynch_Write_File_Impl\fR* \fBcreate_asynch_write_file\fR (void) = 0"
.br
.RI "\fICreate the correct implementation class for doing Asynch_Write_File.\fR"
.ti -1c
.RI "virtual \fBACE_Asynch_Accept_Impl\fR* \fBcreate_asynch_accept\fR (void) = 0"
.br
.RI "\fICreate the correct implementation class for doing Asynch_Accept.\fR"
.ti -1c
.RI "virtual \fBACE_Asynch_Transmit_File_Impl\fR* \fBcreate_asynch_transmit_file\fR (void) = 0"
.br
.RI "\fICreate the correct implementation class for doing Asynch_Transmit_File.\fR"
.ti -1c
.RI "virtual \fBACE_Asynch_Read_Dgram_Impl\fR* \fBcreate_asynch_read_dgram\fR (void) = 0"
.br
.RI "\fICreate the correct implementation class for doing Asynch_Read_Dgram.\fR"
.ti -1c
.RI "virtual \fBACE_Asynch_Write_Dgram_Impl\fR* \fBcreate_asynch_write_dgram\fR (void) = 0"
.br
.RI "\fICreate the correct implementation class for doing Asynch_Write_Dgram.\fR"
.ti -1c
.RI "virtual \fBACE_Asynch_Read_Stream_Result_Impl\fR* \fBcreate_asynch_read_stream_result\fR (\fBACE_Handler\fR &handler, ACE_HANDLE handle, \fBACE_Message_Block\fR &message_block, u_long bytes_to_read, const void* act, ACE_HANDLE event = ACE_INVALID_HANDLE, int priority = 0, int signal_number = ACE_SIGRTMIN) = 0"
.br
.RI "\fICreate the correct implementation class for \fBACE_Asynch_Read_Stream::Result\fR class.\fR"
.ti -1c
.RI "virtual \fBACE_Asynch_Write_Stream_Result_Impl\fR* \fBcreate_asynch_write_stream_result\fR (\fBACE_Handler\fR &handler, ACE_HANDLE handle, \fBACE_Message_Block\fR &message_block, u_long bytes_to_write, const void* act, ACE_HANDLE event = ACE_INVALID_HANDLE, int priority = 0, int signal_number = ACE_SIGRTMIN) = 0"
.br
.RI "\fICreate the correct implementation class for \fBACE_Asynch_Write_Stream::Result\fR.\fR"
.ti -1c
.RI "virtual \fBACE_Asynch_Read_File_Result_Impl\fR* \fBcreate_asynch_read_file_result\fR (\fBACE_Handler\fR &handler, ACE_HANDLE handle, \fBACE_Message_Block\fR &message_block, u_long bytes_to_read, const void* act, u_long offset, u_long offset_high, ACE_HANDLE event = ACE_INVALID_HANDLE, int priority = 0, int signal_number = ACE_SIGRTMIN) = 0"
.br
.RI "\fICreate the correct implementation class for \fBACE_Asynch_Read_File::Result\fR.\fR"
.ti -1c
.RI "virtual \fBACE_Asynch_Write_File_Result_Impl\fR* \fBcreate_asynch_write_file_result\fR (\fBACE_Handler\fR &handler, ACE_HANDLE handle, \fBACE_Message_Block\fR &message_block, u_long bytes_to_write, const void* act, u_long offset, u_long offset_high, ACE_HANDLE event = ACE_INVALID_HANDLE, int priority = 0, int signal_number = ACE_SIGRTMIN) = 0"
.br
.RI "\fICreate the correct implementation class for \fBACE_Asynch_Write_File::Result\fR.\fR"
.ti -1c
.RI "virtual \fBACE_Asynch_Read_Dgram_Result_Impl\fR* \fBcreate_asynch_read_dgram_result\fR (\fBACE_Handler\fR &handler, ACE_HANDLE handle, \fBACE_Message_Block\fR *message_block, size_t bytes_to_read, int flags, int protocol_family, const void* act, ACE_HANDLE event = ACE_INVALID_HANDLE, int priority = 0, int signal_number = ACE_SIGRTMIN) = 0"
.br
.RI "\fICreate the correct implementation class for \fBACE_Asynch_Read_Dgram::Result\fR.\fR"
.ti -1c
.RI "virtual \fBACE_Asynch_Write_Dgram_Result_Impl\fR* \fBcreate_asynch_write_dgram_result\fR (\fBACE_Handler\fR &handler, ACE_HANDLE handle, \fBACE_Message_Block\fR *message_block, size_t bytes_to_write, int flags, const void* act, ACE_HANDLE event = ACE_INVALID_HANDLE, int priority = 0, int signal_number = ACE_SIGRTMIN) = 0"
.br
.RI "\fICreate the correct implementation class for \fBACE_Asynch_Write_Dgram::Result\fR.\fR"
.ti -1c
.RI "virtual \fBACE_Asynch_Accept_Result_Impl\fR* \fBcreate_asynch_accept_result\fR (\fBACE_Handler\fR &handler, ACE_HANDLE listen_handle, ACE_HANDLE accept_handle, \fBACE_Message_Block\fR &message_block, u_long bytes_to_read, const void* act, ACE_HANDLE event = ACE_INVALID_HANDLE, int priority = 0, int signal_number = ACE_SIGRTMIN) = 0"
.br
.RI "\fICreate the correct implementation class for \fBACE_Asynch_Accept::Result\fR.\fR"
.ti -1c
.RI "virtual \fBACE_Asynch_Transmit_File_Result_Impl\fR* \fBcreate_asynch_transmit_file_result\fR (\fBACE_Handler\fR &handler, ACE_HANDLE socket, ACE_HANDLE file, \fBACE_Asynch_Transmit_File::Header_And_Trailer\fR *header_and_trailer, u_long bytes_to_write, u_long offset, u_long offset_high, u_long bytes_per_send, u_long flags, const void *act, ACE_HANDLE event = ACE_INVALID_HANDLE, int priority = 0, int signal_number = ACE_SIGRTMIN) = 0"
.br
.RI "\fICreate the correct implementation class for \fBACE_Asynch_Transmit_File::Result\fR.\fR"
.ti -1c
.RI "virtual \fBACE_Asynch_Result_Impl\fR* \fBcreate_asynch_timer\fR (\fBACE_Handler\fR &handler, const void *act, const \fBACE_Time_Value\fR &tv, ACE_HANDLE event = ACE_INVALID_HANDLE, int priority = 0, int signal_number = 0) = 0"
.br
.ti -1c
.RI "virtual int \fBpost_wakeup_completions\fR (int how_many) = 0"
.br
.in -1c
.SH DETAILED DESCRIPTION
.PP 
A manager for asynchronous event demultiplexing. This class is the base class for all the concrete implementation classes.
.PP
.PP
 See the Proactor pattern description at http://www.cs.wustl.edu/~schmidt/proactor.ps.gz for more details. 
.PP
.SH CONSTRUCTOR & DESTRUCTOR DOCUMENTATION
.PP 
.SS ACE_Proactor_Impl::~ACE_Proactor_Impl (void)\fC [inline, virtual]\fR
.PP
Virtual destruction.
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS int ACE_Proactor_Impl::close (void)\fC [pure virtual]\fR
.PP
Close the IO completion port.
.PP
Reimplemented in \fBACE_POSIX_Proactor\fR, and \fBACE_WIN32_Proactor\fR.
.SS int ACE_Proactor_Impl::close_dispatch_threads (int wait)\fC [pure virtual]\fR
.PP
Close all dispatch threads.
.PP
Reimplemented in \fBACE_POSIX_Proactor\fR, and \fBACE_WIN32_Proactor\fR.
.SS \fBACE_Asynch_Accept_Impl\fR * ACE_Proactor_Impl::create_asynch_accept (void)\fC [pure virtual]\fR
.PP
Create the correct implementation class for doing Asynch_Accept.
.PP
Reimplemented in \fBACE_POSIX_AIOCB_Proactor\fR, and \fBACE_WIN32_Proactor\fR.
.SS \fBACE_Asynch_Accept_Result_Impl\fR * ACE_Proactor_Impl::create_asynch_accept_result (\fBACE_Handler\fR & handler, ACE_HANDLE listen_handle, ACE_HANDLE accept_handle, \fBACE_Message_Block\fR & message_block, u_long bytes_to_read, const void * act, ACE_HANDLE event = ACE_INVALID_HANDLE, int priority = 0, int signal_number = ACE_SIGRTMIN)\fC [pure virtual]\fR
.PP
Create the correct implementation class for \fBACE_Asynch_Accept::Result\fR.
.PP
Reimplemented in \fBACE_POSIX_Proactor\fR, and \fBACE_WIN32_Proactor\fR.
.SS \fBACE_Asynch_Read_Dgram_Impl\fR * ACE_Proactor_Impl::create_asynch_read_dgram (void)\fC [pure virtual]\fR
.PP
Create the correct implementation class for doing Asynch_Read_Dgram.
.PP
Reimplemented in \fBACE_POSIX_AIOCB_Proactor\fR, and \fBACE_WIN32_Proactor\fR.
.SS \fBACE_Asynch_Read_Dgram_Result_Impl\fR * ACE_Proactor_Impl::create_asynch_read_dgram_result (\fBACE_Handler\fR & handler, ACE_HANDLE handle, \fBACE_Message_Block\fR * message_block, size_t bytes_to_read, int flags, int protocol_family, const void * act, ACE_HANDLE event = ACE_INVALID_HANDLE, int priority = 0, int signal_number = ACE_SIGRTMIN)\fC [pure virtual]\fR
.PP
Create the correct implementation class for \fBACE_Asynch_Read_Dgram::Result\fR.
.PP
Reimplemented in \fBACE_POSIX_Proactor\fR, and \fBACE_WIN32_Proactor\fR.
.SS \fBACE_Asynch_Read_File_Impl\fR * ACE_Proactor_Impl::create_asynch_read_file (void)\fC [pure virtual]\fR
.PP
Create the correct implementation class for doing Asynch_Read_File.
.PP
Reimplemented in \fBACE_POSIX_AIOCB_Proactor\fR, and \fBACE_WIN32_Proactor\fR.
.SS \fBACE_Asynch_Read_File_Result_Impl\fR * ACE_Proactor_Impl::create_asynch_read_file_result (\fBACE_Handler\fR & handler, ACE_HANDLE handle, \fBACE_Message_Block\fR & message_block, u_long bytes_to_read, const void * act, u_long offset, u_long offset_high, ACE_HANDLE event = ACE_INVALID_HANDLE, int priority = 0, int signal_number = ACE_SIGRTMIN)\fC [pure virtual]\fR
.PP
Create the correct implementation class for \fBACE_Asynch_Read_File::Result\fR.
.PP
Reimplemented in \fBACE_POSIX_Proactor\fR, and \fBACE_WIN32_Proactor\fR.
.SS \fBACE_Asynch_Read_Stream_Impl\fR * ACE_Proactor_Impl::create_asynch_read_stream (void)\fC [pure virtual]\fR
.PP
Create the correct implementation class for doing Asynch_Read_Stream.
.PP
Reimplemented in \fBACE_POSIX_AIOCB_Proactor\fR, and \fBACE_WIN32_Proactor\fR.
.SS \fBACE_Asynch_Read_Stream_Result_Impl\fR * ACE_Proactor_Impl::create_asynch_read_stream_result (\fBACE_Handler\fR & handler, ACE_HANDLE handle, \fBACE_Message_Block\fR & message_block, u_long bytes_to_read, const void * act, ACE_HANDLE event = ACE_INVALID_HANDLE, int priority = 0, int signal_number = ACE_SIGRTMIN)\fC [pure virtual]\fR
.PP
Create the correct implementation class for \fBACE_Asynch_Read_Stream::Result\fR class.
.PP
Reimplemented in \fBACE_POSIX_Proactor\fR, and \fBACE_WIN32_Proactor\fR.
.SS \fBACE_Asynch_Result_Impl\fR * ACE_Proactor_Impl::create_asynch_timer (\fBACE_Handler\fR & handler, const void * act, const \fBACE_Time_Value\fR & tv, ACE_HANDLE event = ACE_INVALID_HANDLE, int priority = 0, int signal_number = 0)\fC [pure virtual]\fR
.PP
Create the correct implementation object for the Timer result. POSIX_SIG_Proactor will create a Timer object with a meaningful signal number, if you leave the signal number as 0. 
.PP
Reimplemented in \fBACE_POSIX_Proactor\fR, \fBACE_POSIX_SIG_Proactor\fR, and \fBACE_WIN32_Proactor\fR.
.SS \fBACE_Asynch_Transmit_File_Impl\fR * ACE_Proactor_Impl::create_asynch_transmit_file (void)\fC [pure virtual]\fR
.PP
Create the correct implementation class for doing Asynch_Transmit_File.
.PP
Reimplemented in \fBACE_POSIX_AIOCB_Proactor\fR, and \fBACE_WIN32_Proactor\fR.
.SS \fBACE_Asynch_Transmit_File_Result_Impl\fR * ACE_Proactor_Impl::create_asynch_transmit_file_result (\fBACE_Handler\fR & handler, ACE_HANDLE socket, ACE_HANDLE file, \fBACE_Asynch_Transmit_File::Header_And_Trailer\fR * header_and_trailer, u_long bytes_to_write, u_long offset, u_long offset_high, u_long bytes_per_send, u_long flags, const void * act, ACE_HANDLE event = ACE_INVALID_HANDLE, int priority = 0, int signal_number = ACE_SIGRTMIN)\fC [pure virtual]\fR
.PP
Create the correct implementation class for \fBACE_Asynch_Transmit_File::Result\fR.
.PP
Reimplemented in \fBACE_POSIX_Proactor\fR, and \fBACE_WIN32_Proactor\fR.
.SS \fBACE_Asynch_Write_Dgram_Impl\fR * ACE_Proactor_Impl::create_asynch_write_dgram (void)\fC [pure virtual]\fR
.PP
Create the correct implementation class for doing Asynch_Write_Dgram.
.PP
Reimplemented in \fBACE_POSIX_AIOCB_Proactor\fR, and \fBACE_WIN32_Proactor\fR.
.SS \fBACE_Asynch_Write_Dgram_Result_Impl\fR * ACE_Proactor_Impl::create_asynch_write_dgram_result (\fBACE_Handler\fR & handler, ACE_HANDLE handle, \fBACE_Message_Block\fR * message_block, size_t bytes_to_write, int flags, const void * act, ACE_HANDLE event = ACE_INVALID_HANDLE, int priority = 0, int signal_number = ACE_SIGRTMIN)\fC [pure virtual]\fR
.PP
Create the correct implementation class for \fBACE_Asynch_Write_Dgram::Result\fR.
.PP
Reimplemented in \fBACE_POSIX_Proactor\fR, and \fBACE_WIN32_Proactor\fR.
.SS \fBACE_Asynch_Write_File_Impl\fR * ACE_Proactor_Impl::create_asynch_write_file (void)\fC [pure virtual]\fR
.PP
Create the correct implementation class for doing Asynch_Write_File.
.PP
Reimplemented in \fBACE_POSIX_AIOCB_Proactor\fR, and \fBACE_WIN32_Proactor\fR.
.SS \fBACE_Asynch_Write_File_Result_Impl\fR * ACE_Proactor_Impl::create_asynch_write_file_result (\fBACE_Handler\fR & handler, ACE_HANDLE handle, \fBACE_Message_Block\fR & message_block, u_long bytes_to_write, const void * act, u_long offset, u_long offset_high, ACE_HANDLE event = ACE_INVALID_HANDLE, int priority = 0, int signal_number = ACE_SIGRTMIN)\fC [pure virtual]\fR
.PP
Create the correct implementation class for \fBACE_Asynch_Write_File::Result\fR.
.PP
Reimplemented in \fBACE_POSIX_Proactor\fR, and \fBACE_WIN32_Proactor\fR.
.SS \fBACE_Asynch_Write_Stream_Impl\fR * ACE_Proactor_Impl::create_asynch_write_stream (void)\fC [pure virtual]\fR
.PP
Create the correct implementation class for doing Asynch_Write_Stream.
.PP
Reimplemented in \fBACE_POSIX_AIOCB_Proactor\fR, and \fBACE_WIN32_Proactor\fR.
.SS \fBACE_Asynch_Write_Stream_Result_Impl\fR * ACE_Proactor_Impl::create_asynch_write_stream_result (\fBACE_Handler\fR & handler, ACE_HANDLE handle, \fBACE_Message_Block\fR & message_block, u_long bytes_to_write, const void * act, ACE_HANDLE event = ACE_INVALID_HANDLE, int priority = 0, int signal_number = ACE_SIGRTMIN)\fC [pure virtual]\fR
.PP
Create the correct implementation class for \fBACE_Asynch_Write_Stream::Result\fR.
.PP
Reimplemented in \fBACE_POSIX_Proactor\fR, and \fBACE_WIN32_Proactor\fR.
.SS ACE_HANDLE ACE_Proactor_Impl::get_handle (void) const\fC [pure virtual]\fR
.PP
Get the event handle.
.PP
Reimplemented from \fBACE_Event_Handler\fR.
.PP
Reimplemented in \fBACE_POSIX_Proactor\fR, and \fBACE_WIN32_Proactor\fR.
.SS int ACE_Proactor_Impl::handle_events (void)\fC [pure virtual]\fR
.PP
Block indefinitely until at least one event is dispatched. Dispatch a single set of events. If <wait_time> elapses before any events occur, return 0. Return 1 on success i.e., when a completion is dispatched, non-zero (-1) on errors and errno is set accordingly. 
.PP
Reimplemented in \fBACE_POSIX_AIOCB_Proactor\fR, \fBACE_POSIX_SIG_Proactor\fR, and \fBACE_WIN32_Proactor\fR.
.SS int ACE_Proactor_Impl::handle_events (\fBACE_Time_Value\fR & wait_time)\fC [pure virtual]\fR
.PP
Dispatch a single set of events. If <wait_time> elapses before any events occur, return 0. Return 1 on success i.e., when a completion is dispatched, non-zero (-1) on errors and errno is set accordingly. 
.PP
Reimplemented in \fBACE_POSIX_AIOCB_Proactor\fR, \fBACE_POSIX_SIG_Proactor\fR, and \fBACE_WIN32_Proactor\fR.
.SS virtual void ACE_Proactor_Impl::number_of_threads (size_t threads)\fC [pure virtual]\fR
.PP
Reimplemented in \fBACE_POSIX_Proactor\fR, and \fBACE_WIN32_Proactor\fR.
.SS size_t ACE_Proactor_Impl::number_of_threads (void) const\fC [pure virtual]\fR
.PP
Number of thread used as a parameter to CreatIoCompletionPort.
.PP
Reimplemented in \fBACE_POSIX_Proactor\fR, and \fBACE_WIN32_Proactor\fR.
.SS int ACE_Proactor_Impl::post_wakeup_completions (int how_many)\fC [pure virtual]\fR
.PP
Post <how_many> completions to the completion port so that all threads can wake up. This is used in conjunction with the <run_event_loop>. 
.PP
Reimplemented in \fBACE_POSIX_Proactor\fR, and \fBACE_WIN32_Proactor\fR.
.SS int ACE_Proactor_Impl::register_handle (ACE_HANDLE handle, const void * completion_key)\fC [pure virtual]\fR
.PP
This method adds the <handle> to the I/O completion port. This function is a no-op function for Unix systems.
.PP
Reimplemented in \fBACE_POSIX_Proactor\fR, and \fBACE_WIN32_Proactor\fR.
.SS int ACE_Proactor_Impl::wake_up_dispatch_threads (void)\fC [pure virtual]\fR
.PP
Add wakeup dispatch threads (reinit).
.PP
Reimplemented in \fBACE_POSIX_Proactor\fR, and \fBACE_WIN32_Proactor\fR.

.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.