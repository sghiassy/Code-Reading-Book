.TH ACE_LOCK_SOCK_Acceptor 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_LOCK_SOCK_Acceptor \- Specialize  to lock around ;. 
.SH SYNOPSIS
.br
.PP
\fC#include <LOCK_SOCK_Acceptor.h>\fR
.PP
Inherits \fBACE_SOCK_Acceptor\fR.
.PP
.SS Public Methods

.in +1c
.ti -1c
.RI "int \fBaccept\fR (\fBACE_SOCK_Stream\fR &new_stream, \fBACE_Addr\fR *remote_addr = 0, \fBACE_Time_Value\fR *timeout = 0, int restart = 1, int reset_new_handle = 0) const"
.br
.RI "\fIAccept the connection under the control of the .\fR"
.ti -1c
.RI "ACE_LOCK& \fBlock\fR (void)"
.br
.RI "\fIReturn a reference to the lock.\fR"
.in -1c
.SS Protected Attributes

.in +1c
.ti -1c
.RI "ACE_LOCK \fBlock_\fR"
.br
.RI "\fIType of locking mechanism.\fR"
.in -1c
.SH DETAILED DESCRIPTION
.PP 

.SS template<class ACE_LOCK>  template class ACE_LOCK_SOCK_Acceptor
Specialize  to lock around ;.
.PP
.PP
 This class is necessary since some OS platforms (e.g., Solaris 2.5) do not allow multiple threads/processes to simultaneously call  on the same listen-mode port/socket. Thus, we need to protect against multiple concurrent accesses by using the appropriate type of lock. 
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS template<classACE_LOCK> int ACE_LOCK_SOCK_Acceptor<ACE_LOCK>::accept (\fBACE_SOCK_Stream\fR & new_stream, \fBACE_Addr\fR * remote_addr = 0, \fBACE_Time_Value\fR * timeout = 0, int restart = 1, int reset_new_handle = 0) const
.PP
Accept the connection under the control of the .
.PP
Reimplemented from \fBACE_SOCK_Acceptor\fR.
.SS template<classACE_LOCK> ACE_LOCK & ACE_LOCK_SOCK_Acceptor<ACE_LOCK>::lock (void)
.PP
Return a reference to the lock.
.PP
.SH MEMBER DATA DOCUMENTATION
.PP 
.SS template<classACE_LOCK> ACE_LOCK ACE_LOCK_SOCK_Acceptor<ACE_LOCK>::lock_\fC [protected]\fR
.PP
Type of locking mechanism.
.PP


.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.