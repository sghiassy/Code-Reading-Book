.TH ACE_TLI_Acceptor 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_TLI_Acceptor \- Defines the member functions for ACE_TLI_Acceptor abstraction. 
.SH SYNOPSIS
.br
.PP
\fC#include <TLI_Acceptor.h>\fR
.PP
Inherits \fBACE_TLI\fR.
.PP
.SS Public Types

.in +1c
.ti -1c
.RI "typedef \fBACE_INET_Addr\fR \fBPEER_ADDR\fR"
.br
.ti -1c
.RI "typedef \fBACE_TLI_Stream\fR \fBPEER_STREAM\fR"
.br
.in -1c
.SS Public Methods

.in +1c
.ti -1c
.RI "\fBACE_TLI_Acceptor\fR (void)"
.br
.RI "\fIDefault constructor.\fR"
.ti -1c
.RI "\fBACE_TLI_Acceptor\fR (const \fBACE_Addr\fR &remote_sap, int reuse_addr = 0, int oflag = O_RDWR, struct t_info *info = 0, int backlog = ACE_DEFAULT_BACKLOG, const char device[] = ACE_TLI_TCP_DEVICE)"
.br
.RI "\fIInitiate a passive mode socket.\fR"
.ti -1c
.RI "ACE_HANDLE \fBopen\fR (const \fBACE_Addr\fR &remote_sap, int reuse_addr = 0, int oflag = O_RDWR, struct t_info *info = 0, int backlog = ACE_DEFAULT_BACKLOG, const char device[] = ACE_TLI_TCP_DEVICE)"
.br
.RI "\fIInitiate a passive mode socket.\fR"
.ti -1c
.RI "int \fBclose\fR (void)"
.br
.RI "\fIClose down the acceptor and release resources.\fR"
.ti -1c
.RI "int \fBaccept\fR (\fBACE_TLI_Stream\fR &new_tli_sap, \fBACE_Addr\fR *remote_addr = 0, \fBACE_Time_Value\fR *timeout = 0, int restart = 1, int reset_new_handle = 0, int rwflag = 1, netbuf *udata = 0, netbuf *opt = 0)"
.br
.ti -1c
.RI "void \fBdump\fR (void) const"
.br
.RI "\fIDump the state of an object.\fR"
.in -1c
.SS Public Attributes

.in +1c
.ti -1c
.RI "\fBACE_ALLOC_HOOK_DECLARE\fR"
.br
.RI "\fIDeclare the dynamic allocation hooks.\fR"
.in -1c
.SS Private Methods

.in +1c
.ti -1c
.RI "int \fBhandle_async_event\fR (int restart, int rwflag)"
.br
.RI "\fIHandle TLI accept insanity...\fR"
.in -1c
.SS Private Attributes

.in +1c
.ti -1c
.RI "const char* \fBdevice_\fR"
.br
.RI "\fINetwork "device" we are using.\fR"
.ti -1c
.RI "int \fBbacklog_\fR"
.br
.RI "\fINumber of connections to queue.\fR"
.ti -1c
.RI "int \fBrwflag_\fR"
.br
.RI "\fIAre we using "tirdwr" mod?\fR"
.ti -1c
.RI "ACE_TLI_Request_Queue* \fBqueue_\fR"
.br
.RI "\fIUsed for queueing up pending requests.\fR"
.ti -1c
.RI "struct t_discon* \fBdisp_\fR"
.br
.RI "\fIUsed for handling disconnects.\fR"
.in -1c
.SS Friends

.in +1c
.ti -1c
.RI "class \fBACE_Request_Queue\fR"
.br
.in -1c
.SH DETAILED DESCRIPTION
.PP 
Defines the member functions for ACE_TLI_Acceptor abstraction.
.PP
.PP
 This class implements the algorithm described in Steve Rago's book on System V UNIX network programming. It basically makes TLI look like the C++ SOCK_SAP socket wrappers with respect to establishing passive-mode listener endpoints. 
.PP
.SH MEMBER TYPEDEF DOCUMENTATION
.PP 
.SS typedef \fBACE_INET_Addr\fR ACE_TLI_Acceptor::PEER_ADDR
.PP
.SS typedef \fBACE_TLI_Stream\fR ACE_TLI_Acceptor::PEER_STREAM
.PP
.SH CONSTRUCTOR & DESTRUCTOR DOCUMENTATION
.PP 
.SS ACE_TLI_Acceptor::ACE_TLI_Acceptor (void)
.PP
Default constructor.
.PP
.SS ACE_TLI_Acceptor::ACE_TLI_Acceptor (const \fBACE_Addr\fR & remote_sap, int reuse_addr = 0, int oflag = O_RDWR, struct t_info * info = 0, int backlog = ACE_DEFAULT_BACKLOG, const char device[] = ACE_TLI_TCP_DEVICE)
.PP
Initiate a passive mode socket.
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS int ACE_TLI_Acceptor::accept (\fBACE_TLI_Stream\fR & new_tli_sap, \fBACE_Addr\fR * remote_addr = 0, \fBACE_Time_Value\fR * timeout = 0, int restart = 1, int reset_new_handle = 0, int rwflag = 1, netbuf * udata = 0, netbuf * opt = 0)
.PP
Accept a new data transfer connection. A <timeout> of 0 means block forever, a <timeout> of {0, 0} means poll. <restart> == 1 means "restart if interrupted." 
.SS int ACE_TLI_Acceptor::close (void)
.PP
Close down the acceptor and release resources.
.PP
Reimplemented from \fBACE_TLI\fR.
.SS void ACE_TLI_Acceptor::dump (void) const
.PP
Dump the state of an object.
.PP
Reimplemented from \fBACE_TLI\fR.
.SS int ACE_TLI_Acceptor::handle_async_event (int restart, int rwflag)\fC [private]\fR
.PP
Handle TLI accept insanity...
.PP
.SS ACE_HANDLE ACE_TLI_Acceptor::open (const \fBACE_Addr\fR & remote_sap, int reuse_addr = 0, int oflag = O_RDWR, struct t_info * info = 0, int backlog = ACE_DEFAULT_BACKLOG, const char device[] = ACE_TLI_TCP_DEVICE)
.PP
Initiate a passive mode socket.
.PP
.SH FRIENDS AND RELATED FUNCTION DOCUMENTATION
.PP 
.SS class ACE_Request_Queue\fC [friend]\fR
.PP
.SH MEMBER DATA DOCUMENTATION
.PP 
.SS ACE_TLI_Acceptor::ACE_ALLOC_HOOK_DECLARE
.PP
Declare the dynamic allocation hooks.
.PP
Reimplemented from \fBACE_TLI\fR.
.SS int ACE_TLI_Acceptor::backlog_\fC [private]\fR
.PP
Number of connections to queue.
.PP
.SS const char * ACE_TLI_Acceptor::device_\fC [private]\fR
.PP
Network "device" we are using.
.PP
.SS struct t_discon * ACE_TLI_Acceptor::disp_\fC [private]\fR
.PP
Used for handling disconnects.
.PP
.SS ACE_TLI_Request_Queue * ACE_TLI_Acceptor::queue_\fC [private]\fR
.PP
Used for queueing up pending requests.
.PP
.SS int ACE_TLI_Acceptor::rwflag_\fC [private]\fR
.PP
Are we using "tirdwr" mod?
.PP


.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.