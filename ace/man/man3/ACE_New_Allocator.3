.TH ACE_New_Allocator 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_New_Allocator \- Defines a class that provided a simple implementation of memory allocation. 
.SH SYNOPSIS
.br
.PP
\fC#include <Malloc_Allocator.h>\fR
.PP
Inherits \fBACE_Allocator\fR.
.PP
Inherited by \fBACE_Cached_Allocator\fR.
.PP
.SS Public Methods

.in +1c
.ti -1c
.RI "virtual void* \fBmalloc\fR (size_t nbytes)"
.br
.RI "\fIThese methods are defined.\fR"
.ti -1c
.RI "virtual void* \fBcalloc\fR (size_t nbytes, char initial_value = '\\0')"
.br
.RI "\fIAllocate <nbytes>, giving them <initial_value>.\fR"
.ti -1c
.RI "virtual void* \fBcalloc\fR (size_t n_elem, size_t elem_size, char initial_value = '\\0')"
.br
.RI "\fIAllocate <n_elem> each of size <elem_size>, giving them <initial_value>.\fR"
.ti -1c
.RI "virtual void \fBfree\fR (void *ptr)"
.br
.RI "\fIFree <ptr> (must have been allocated by ).\fR"
.ti -1c
.RI "virtual int \fBremove\fR (void)"
.br
.RI "\fIThese methods are no-ops.\fR"
.ti -1c
.RI "virtual int \fBbind\fR (const char *name, void *pointer, int duplicates = 0)"
.br
.ti -1c
.RI "virtual int \fBtrybind\fR (const char *name, void *&pointer)"
.br
.ti -1c
.RI "virtual int \fBfind\fR (const char *name, void *&pointer)"
.br
.RI "\fILocate <name> and pass out parameter via pointer. If found, return 0, Returns -1 if failure occurs.\fR"
.ti -1c
.RI "virtual int \fBfind\fR (const char *name)"
.br
.RI "\fIreturns 0 if the name is in the mapping. -1, otherwise.\fR"
.ti -1c
.RI "virtual int \fBunbind\fR (const char *name)"
.br
.RI "\fIUnbind (remove) the name from the map. Don't return the pointer to the caller.\fR"
.ti -1c
.RI "virtual int \fBunbind\fR (const char *name, void *&pointer)"
.br
.RI "\fIBreak any association of name. Returns the value of pointer in case the caller needs to deallocate memory.\fR"
.ti -1c
.RI "virtual int \fBsync\fR (\fBssize_t\fR len = -1, int flags = MS_SYNC)"
.br
.ti -1c
.RI "virtual int \fBsync\fR (void *addr, size_t len, int flags = MS_SYNC)"
.br
.RI "\fISync <len> bytes of the memory region to the backing store starting at .\fR"
.ti -1c
.RI "virtual int \fBprotect\fR (\fBssize_t\fR len = -1, int prot = PROT_RDWR)"
.br
.ti -1c
.RI "virtual int \fBprotect\fR (void *addr, size_t len, int prot = PROT_RDWR)"
.br
.RI "\fIChange the protection of the pages of the mapped region to <prot> starting at  up to <len> bytes.\fR"
.ti -1c
.RI "virtual void \fBdump\fR (void) const"
.br
.RI "\fIDump the state of the object.\fR"
.in -1c
.SH DETAILED DESCRIPTION
.PP 
Defines a class that provided a simple implementation of memory allocation.
.PP
.PP
 This class uses the new/delete operators to allocate and free up memory. Please note that the only methods that are supported are <malloc>, <calloc>, and <free>. All other methods are no-ops that return -1 and set <errno> to <ENOTSUP>. If you require this functionality, please use: \fBACE_Allocator_Adapter\fR  >, which will allow you to use the added functionality of bind/find/etc. while using the new/delete operators. 
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS virtual int ACE_New_Allocator::bind (const char * name, void * pointer, int duplicates = 0)\fC [virtual]\fR
.PP
Associate <name> with <pointer>. If <duplicates> == 0 then do not allow duplicate <name>/<pointer> associations, else if <duplicates> != 0 then allow duplicate <name>/<pointer> assocations. Returns 0 if successfully binds (1) a previously unbound <name> or (2) <duplicates> != 0, returns 1 if trying to bind a previously bound <name> and <duplicates> == 0, else returns -1 if a resource failure occurs. 
.PP
Reimplemented from \fBACE_Allocator\fR.
.SS virtual void* ACE_New_Allocator::calloc (size_t n_elem, size_t elem_size, char initial_value = '\\0')\fC [virtual]\fR
.PP
Allocate <n_elem> each of size <elem_size>, giving them <initial_value>.
.PP
Reimplemented from \fBACE_Allocator\fR.
.PP
Reimplemented in \fBACE_Cached_Allocator\fR.
.SS virtual void* ACE_New_Allocator::calloc (size_t nbytes, char initial_value = '\\0')\fC [virtual]\fR
.PP
Allocate <nbytes>, giving them <initial_value>.
.PP
Reimplemented from \fBACE_Allocator\fR.
.PP
Reimplemented in \fBACE_Cached_Allocator\fR.
.SS virtual void ACE_New_Allocator::dump (void) const\fC [virtual]\fR
.PP
Dump the state of the object.
.PP
Reimplemented from \fBACE_Allocator\fR.
.SS virtual int ACE_New_Allocator::find (const char * name)\fC [virtual]\fR
.PP
returns 0 if the name is in the mapping. -1, otherwise.
.PP
Reimplemented from \fBACE_Allocator\fR.
.SS virtual int ACE_New_Allocator::find (const char * name, void *& pointer)\fC [virtual]\fR
.PP
Locate <name> and pass out parameter via pointer. If found, return 0, Returns -1 if failure occurs.
.PP
Reimplemented from \fBACE_Allocator\fR.
.SS virtual void ACE_New_Allocator::free (void * ptr)\fC [virtual]\fR
.PP
Free <ptr> (must have been allocated by ).
.PP
Reimplemented from \fBACE_Allocator\fR.
.PP
Reimplemented in \fBACE_Cached_Allocator\fR.
.SS void * ACE_New_Allocator::malloc (size_t nbytes)\fC [virtual]\fR
.PP
These methods are defined.
.PP
Reimplemented from \fBACE_Allocator\fR.
.PP
Reimplemented in \fBACE_Cached_Allocator\fR.
.SS virtual int ACE_New_Allocator::protect (void * addr, size_t len, int prot = PROT_RDWR)\fC [virtual]\fR
.PP
Change the protection of the pages of the mapped region to <prot> starting at  up to <len> bytes.
.PP
Reimplemented from \fBACE_Allocator\fR.
.SS virtual int ACE_New_Allocator::protect (\fBssize_t\fR len = -1, int prot = PROT_RDWR)\fC [virtual]\fR
.PP
Change the protection of the pages of the mapped region to <prot> starting at <this->base_addr_> up to <len> bytes. If <len> == -1 then change protection of all pages in the mapped region. 
.PP
Reimplemented from \fBACE_Allocator\fR.
.SS int ACE_New_Allocator::remove (void)\fC [virtual]\fR
.PP
These methods are no-ops.
.PP
Reimplemented from \fBACE_Allocator\fR.
.SS virtual int ACE_New_Allocator::sync (void * addr, size_t len, int flags = MS_SYNC)\fC [virtual]\fR
.PP
Sync <len> bytes of the memory region to the backing store starting at .
.PP
Reimplemented from \fBACE_Allocator\fR.
.SS virtual int ACE_New_Allocator::sync (\fBssize_t\fR len = -1, int flags = MS_SYNC)\fC [virtual]\fR
.PP
Sync <len> bytes of the memory region to the backing store starting at <this->base_addr_>. If <len> == -1 then sync the whole region. 
.PP
Reimplemented from \fBACE_Allocator\fR.
.SS virtual int ACE_New_Allocator::trybind (const char * name, void *& pointer)\fC [virtual]\fR
.PP
Associate <name> with <pointer>. Does not allow duplicate <name>/<pointer> associations. Returns 0 if successfully binds (1) a previously unbound <name>, 1 if trying to bind a previously bound <name>, or returns -1 if a resource failure occurs. When this call returns <pointer>'s value will always reference the void * that <name> is associated with. Thus, if the caller needs to use <pointer> (e.g., to free it) a copy must be maintained by the caller. 
.PP
Reimplemented from \fBACE_Allocator\fR.
.SS virtual int ACE_New_Allocator::unbind (const char * name, void *& pointer)\fC [virtual]\fR
.PP
Break any association of name. Returns the value of pointer in case the caller needs to deallocate memory.
.PP
Reimplemented from \fBACE_Allocator\fR.
.SS virtual int ACE_New_Allocator::unbind (const char * name)\fC [virtual]\fR
.PP
Unbind (remove) the name from the map. Don't return the pointer to the caller.
.PP
Reimplemented from \fBACE_Allocator\fR.

.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.