.TH ACE_Hash_Cache_Map_Manager 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_Hash_Cache_Map_Manager \- Defines a abstraction which will purge entries from a map. The map considered is the \fBACE_Hash_Map_Manager_Ex\fR. 
.SH SYNOPSIS
.br
.PP
\fC#include <Hash_Cache_Map_Manager_T.h>\fR
.PP
Inherits \fBACE_CACHE_MAP_MANAGER\fR.
.PP
.SS Public Types

.in +1c
.ti -1c
.RI "typedef \fBACE_Pair\fR<VALUE, ATTRIBUTES> \fBCACHE_VALUE\fR"
.br
.ti -1c
.RI "typedef \fBACE_Hash_Map_Manager_Ex\fR<KEY, \fBCACHE_VALUE\fR, HASH_KEY, COMPARE_KEYS, \fBACE_Null_Mutex\fR> \fBHASH_MAP\fR"
.br
.ti -1c
.RI "typedef \fBACE_Hash_Map_Entry\fR<KEY, \fBCACHE_VALUE\fR> \fBCACHE_ENTRY\fR"
.br
.ti -1c
.RI "typedef KEY \fBkey_type\fR"
.br
.ti -1c
.RI "typedef VALUE \fBmapped_type\fR"
.br
.in -1c
.SS Public Methods

.in +1c
.ti -1c
.RI "\fBACE_Hash_Cache_Map_Manager\fR (CACHING_STRATEGY &caching_s, size_t size = ACE_DEFAULT_MAP_SIZE, \fBACE_Allocator\fR *alloc = 0)"
.br
.RI "\fIInitialize a <Hash_Cache_Map_Manager> with <size> entries.\fR"
.ti -1c
.RI "\fB~ACE_Hash_Cache_Map_Manager\fR (void)"
.br
.RI "\fIClose down a <Cache_Map_Manager> and release dynamically allocated resources.\fR"
.ti -1c
.RI "int \fBbind\fR (const KEY &key, const VALUE &value)"
.br
.ti -1c
.RI "int \fBbind\fR (const KEY &key, const VALUE &value, \fBCACHE_ENTRY\fR *&entry)"
.br
.ti -1c
.RI "int \fBfind\fR (const KEY &key, VALUE &value)"
.br
.RI "\fILoopkup entry<key,value> in the cache.\fR"
.ti -1c
.RI "int \fBfind\fR (const KEY &key)"
.br
.RI "\fIIs <key> in the cache?\fR"
.ti -1c
.RI "int \fBfind\fR (const KEY &key, \fBCACHE_ENTRY\fR *&entry)"
.br
.RI "\fIObtain the entry when the find succeeds.\fR"
.ti -1c
.RI "int \fBrebind\fR (const KEY &key, const VALUE &value)"
.br
.ti -1c
.RI "int \fBrebind\fR (const KEY &key, const VALUE &value, VALUE &old_value)"
.br
.ti -1c
.RI "int \fBrebind\fR (const KEY &key, const VALUE &value, KEY &old_key, VALUE &old_value)"
.br
.ti -1c
.RI "int \fBrebind\fR (const KEY &key, const VALUE &value, \fBCACHE_ENTRY\fR *&entry)"
.br
.ti -1c
.RI "int \fBtrybind\fR (const KEY &key, VALUE &value)"
.br
.ti -1c
.RI "int \fBtrybind\fR (const KEY &key, VALUE &value, \fBCACHE_ENTRY\fR *&entry)"
.br
.ti -1c
.RI "int \fBunbind\fR (const KEY &key)"
.br
.RI "\fIRemove <key> from the cache.\fR"
.ti -1c
.RI "int \fBunbind\fR (const KEY &key, VALUE &value)"
.br
.RI "\fIRemove <key> from the cache, and return the <value> associated with <key>.\fR"
.ti -1c
.RI "int \fBunbind\fR (\fBCACHE_ENTRY\fR *entry)"
.br
.RI "\fIRemove entry from map.\fR"
.in -1c
.SS Protected Types

.in +1c
.ti -1c
.RI "typedef \fBACE_CACHE_MAP_MANAGER\fR \fBACE_HCMM_BASE\fR"
.br
.RI "\fIBase class.\fR"
.in -1c
.SH DETAILED DESCRIPTION
.PP 

.SS template<class KEY, class VALUE, class HASH_KEY, class COMPARE_KEYS, class CACHING_STRATEGY, class ATTRIBUTES>  template class ACE_Hash_Cache_Map_Manager
Defines a abstraction which will purge entries from a map. The map considered is the \fBACE_Hash_Map_Manager_Ex\fR.
.PP
.PP
 The Hash_Cache_Map_Manager will manage the map it contains and provide purging on demand from the map. The strategy for caching is decided by the user and provided to the Cache Manager. The Cache Manager acts as a agent and communicates between the Map and the Strategy for purging entries from the map. To tap the optimal methods like find(key,value,entry) present in the \fBACE_Hash_Map_Manager\fR, Hash_Cache_Map_Manager provides extra functionality on top of the Cache_Map_Manager. No locking mechanism provided since locking at this level isnt efficient. Locking has to be provided by the application. 
.PP
.SH MEMBER TYPEDEF DOCUMENTATION
.PP 
.SS template<classKEY, classVALUE, classHASH_KEY, classCOMPARE_KEYS, classCACHING_STRATEGY, classATTRIBUTES> typedef \fBACE_CACHE_MAP_MANAGER\fR ACE_Hash_Cache_Map_Manager<KEY, VALUE, HASH_KEY, COMPARE_KEYS, CACHING_STRATEGY, ATTRIBUTES>::ACE_HCMM_BASE\fC [protected]\fR
.PP
Base class.
.PP
.SS template<classKEY, classVALUE, classHASH_KEY, classCOMPARE_KEYS, classCACHING_STRATEGY, classATTRIBUTES> typedef \fBACE_Hash_Map_Entry\fR<KEY, \fBCACHE_VALUE\fR> ACE_Hash_Cache_Map_Manager<KEY, VALUE, HASH_KEY, COMPARE_KEYS, CACHING_STRATEGY, ATTRIBUTES>::CACHE_ENTRY
.PP
.SS template<classKEY, classVALUE, classHASH_KEY, classCOMPARE_KEYS, classCACHING_STRATEGY, classATTRIBUTES> typedef \fBACE_Pair\fR<VALUE, ATTRIBUTES> ACE_Hash_Cache_Map_Manager<KEY, VALUE, HASH_KEY, COMPARE_KEYS, CACHING_STRATEGY, ATTRIBUTES>::CACHE_VALUE
.PP
The actual value mapped to the key in the map. The  are used by the strategy and is transparent to the user of this class. 
.SS template<classKEY, classVALUE, classHASH_KEY, classCOMPARE_KEYS, classCACHING_STRATEGY, classATTRIBUTES> typedef \fBACE_Hash_Map_Manager_Ex\fR<KEY, \fBCACHE_VALUE\fR, HASH_KEY, COMPARE_KEYS, \fBACE_Null_Mutex\fR> ACE_Hash_Cache_Map_Manager<KEY, VALUE, HASH_KEY, COMPARE_KEYS, CACHING_STRATEGY, ATTRIBUTES>::HASH_MAP
.PP
.SS template<classKEY, classVALUE, classHASH_KEY, classCOMPARE_KEYS, classCACHING_STRATEGY, classATTRIBUTES> typedef KEY ACE_Hash_Cache_Map_Manager<KEY, VALUE, HASH_KEY, COMPARE_KEYS, CACHING_STRATEGY, ATTRIBUTES>::key_type
.PP
.SS template<classKEY, classVALUE, classHASH_KEY, classCOMPARE_KEYS, classCACHING_STRATEGY, classATTRIBUTES> typedef VALUE ACE_Hash_Cache_Map_Manager<KEY, VALUE, HASH_KEY, COMPARE_KEYS, CACHING_STRATEGY, ATTRIBUTES>::mapped_type
.PP
.SH CONSTRUCTOR & DESTRUCTOR DOCUMENTATION
.PP 
.SS template<classKEY, classVALUE, classHASH_KEY, classCOMPARE_KEYS, classCACHING_STRATEGY, classATTRIBUTES> ACE_Hash_Cache_Map_Manager<KEY, VALUE, HASH_KEY, COMPARE_KEYS, CACHING_STRATEGY, ATTRIBUTES>::ACE_Hash_Cache_Map_Manager<KEY, VALUE, HASH_KEY, COMPARE_KEYS, CACHING_STRATEGY, ATTRIBUTES> (CACHING_STRATEGY & caching_s, size_t size = ACE_DEFAULT_MAP_SIZE, \fBACE_Allocator\fR * alloc = 0)
.PP
Initialize a <Hash_Cache_Map_Manager> with <size> entries.
.PP
.SS template<classKEY, classVALUE, classHASH_KEY, classCOMPARE_KEYS, classCACHING_STRATEGY, classATTRIBUTES> ACE_Hash_Cache_Map_Manager<KEY, VALUE, HASH_KEY, COMPARE_KEYS, CACHING_STRATEGY, ATTRIBUTES>::~ACE_Hash_Cache_Map_Manager<KEY, VALUE, HASH_KEY, COMPARE_KEYS, CACHING_STRATEGY, ATTRIBUTES> (void)
.PP
Close down a <Cache_Map_Manager> and release dynamically allocated resources.
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS template<classKEY, classVALUE, classHASH_KEY, classCOMPARE_KEYS, classCACHING_STRATEGY, classATTRIBUTES> int ACE_Hash_Cache_Map_Manager<KEY, VALUE, HASH_KEY, COMPARE_KEYS, CACHING_STRATEGY, ATTRIBUTES>::bind (const KEY & key, const VALUE & value, \fBCACHE_ENTRY\fR *& entry)
.PP
Same as a normal bind, except the cache entry is also passed back to the caller. The entry in this case will either be the newly created entry, or the existing one. 
.SS template<classKEY, classVALUE, classHASH_KEY, classCOMPARE_KEYS, classCACHING_STRATEGY, classATTRIBUTES> int ACE_Hash_Cache_Map_Manager<KEY, VALUE, HASH_KEY, COMPARE_KEYS, CACHING_STRATEGY, ATTRIBUTES>::bind (const KEY & key, const VALUE & value)
.PP
Associate <key> with <value>. If <key> is already in the MAP then the ENTRY is not changed. Returns 0 if a new entry is bound successfully, returns 1 if an attempt is made to bind an existing entry, and returns -1 if failures occur. 
.SS template<classKEY, classVALUE, classHASH_KEY, classCOMPARE_KEYS, classCACHING_STRATEGY, classATTRIBUTES> int ACE_Hash_Cache_Map_Manager<KEY, VALUE, HASH_KEY, COMPARE_KEYS, CACHING_STRATEGY, ATTRIBUTES>::find (const KEY & key, \fBCACHE_ENTRY\fR *& entry)
.PP
Obtain the entry when the find succeeds.
.PP
.SS template<classKEY, classVALUE, classHASH_KEY, classCOMPARE_KEYS, classCACHING_STRATEGY, classATTRIBUTES> int ACE_Hash_Cache_Map_Manager<KEY, VALUE, HASH_KEY, COMPARE_KEYS, CACHING_STRATEGY, ATTRIBUTES>::find (const KEY & key)
.PP
Is <key> in the cache?
.PP
.SS template<classKEY, classVALUE, classHASH_KEY, classCOMPARE_KEYS, classCACHING_STRATEGY, classATTRIBUTES> int ACE_Hash_Cache_Map_Manager<KEY, VALUE, HASH_KEY, COMPARE_KEYS, CACHING_STRATEGY, ATTRIBUTES>::find (const KEY & key, VALUE & value)
.PP
Loopkup entry<key,value> in the cache.
.PP
.SS template<classKEY, classVALUE, classHASH_KEY, classCOMPARE_KEYS, classCACHING_STRATEGY, classATTRIBUTES> int ACE_Hash_Cache_Map_Manager<KEY, VALUE, HASH_KEY, COMPARE_KEYS, CACHING_STRATEGY, ATTRIBUTES>::rebind (const KEY & key, const VALUE & value, \fBCACHE_ENTRY\fR *& entry)
.PP
Same as a normal rebind, except the cache entry is also passed back to the caller. The entry in this case will either be the newly created entry, or the existing one. 
.SS template<classKEY, classVALUE, classHASH_KEY, classCOMPARE_KEYS, classCACHING_STRATEGY, classATTRIBUTES> int ACE_Hash_Cache_Map_Manager<KEY, VALUE, HASH_KEY, COMPARE_KEYS, CACHING_STRATEGY, ATTRIBUTES>::rebind (const KEY & key, const VALUE & value, KEY & old_key, VALUE & old_value)
.PP
Reassociate <key> with <value>, storing the old key and value into the "out" parameters <old_key> and <old_value>. The function fails if <key> is not in the cache for caches that do not allow user specified keys. However, for caches that allow user specified keys, if the key is not in the cache, a new <key>/<value> association is created. 
.SS template<classKEY, classVALUE, classHASH_KEY, classCOMPARE_KEYS, classCACHING_STRATEGY, classATTRIBUTES> int ACE_Hash_Cache_Map_Manager<KEY, VALUE, HASH_KEY, COMPARE_KEYS, CACHING_STRATEGY, ATTRIBUTES>::rebind (const KEY & key, const VALUE & value, VALUE & old_value)
.PP
Reassociate <key> with <value>, storing the old value into the "out" parameter <old_value>. The function fails if <key> is not in the cache for caches that do not allow user specified keys. However, for caches that allow user specified keys, if the key is not in the cache, a new <key>/<value> association is created. 
.SS template<classKEY, classVALUE, classHASH_KEY, classCOMPARE_KEYS, classCACHING_STRATEGY, classATTRIBUTES> int ACE_Hash_Cache_Map_Manager<KEY, VALUE, HASH_KEY, COMPARE_KEYS, CACHING_STRATEGY, ATTRIBUTES>::rebind (const KEY & key, const VALUE & value)
.PP
Reassociate the <key> with <value>. If the <key> already exists in the cache then returns 1, on a new bind returns 0 and returns -1 in case of any failures. 
.SS template<classKEY, classVALUE, classHASH_KEY, classCOMPARE_KEYS, classCACHING_STRATEGY, classATTRIBUTES> int ACE_Hash_Cache_Map_Manager<KEY, VALUE, HASH_KEY, COMPARE_KEYS, CACHING_STRATEGY, ATTRIBUTES>::trybind (const KEY & key, VALUE & value, \fBCACHE_ENTRY\fR *& entry)
.PP
Same as a normal trybind, except the cache entry is also passed back to the caller. The entry in this case will either be the newly created entry, or the existing one. 
.SS template<classKEY, classVALUE, classHASH_KEY, classCOMPARE_KEYS, classCACHING_STRATEGY, classATTRIBUTES> int ACE_Hash_Cache_Map_Manager<KEY, VALUE, HASH_KEY, COMPARE_KEYS, CACHING_STRATEGY, ATTRIBUTES>::trybind (const KEY & key, VALUE & value)
.PP
Associate <key> with <value> if and only if <key> is not in the cache. If <key> is already in the cache, then the <value> parameter is overwritten with the existing value in the cache. Returns 0 if a new <key>/<value> association is created. Returns 1 if an attempt is made to bind an existing entry. This function fails for maps that do not allow user specified keys. 
.SS template<classKEY, classVALUE, classHASH_KEY, classCOMPARE_KEYS, classCACHING_STRATEGY, classATTRIBUTES> int ACE_Hash_Cache_Map_Manager<KEY, VALUE, HASH_KEY, COMPARE_KEYS, CACHING_STRATEGY, ATTRIBUTES>::unbind (\fBCACHE_ENTRY\fR * entry)
.PP
Remove entry from map.
.PP
.SS template<classKEY, classVALUE, classHASH_KEY, classCOMPARE_KEYS, classCACHING_STRATEGY, classATTRIBUTES> int ACE_Hash_Cache_Map_Manager<KEY, VALUE, HASH_KEY, COMPARE_KEYS, CACHING_STRATEGY, ATTRIBUTES>::unbind (const KEY & key, VALUE & value)
.PP
Remove <key> from the cache, and return the <value> associated with <key>.
.PP
.SS template<classKEY, classVALUE, classHASH_KEY, classCOMPARE_KEYS, classCACHING_STRATEGY, classATTRIBUTES> int ACE_Hash_Cache_Map_Manager<KEY, VALUE, HASH_KEY, COMPARE_KEYS, CACHING_STRATEGY, ATTRIBUTES>::unbind (const KEY & key)
.PP
Remove <key> from the cache.
.PP


.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.