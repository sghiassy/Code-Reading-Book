.TH ACE_Acceptor 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_Acceptor \- Abstract factory for creating a service handler (SVC_HANDLER), accepting into the SVC_HANDLER, and activating the SVC_HANDLER. 
.SH SYNOPSIS
.br
.PP
\fC#include <Acceptor.h>\fR
.PP
Inherits \fBACE_Service_Object\fR.
.PP
Inherited by \fBACE_Strategy_Acceptor\fR.
.PP
.SS Public Methods

.in +1c
.ti -1c
.RI "\fBACE_Acceptor\fR (\fBACE_Reactor\fR * = 0, int use_select = 1)"
.br
.RI "\fI"Do-nothing" constructor.\fR"
.ti -1c
.RI "\fBACE_Acceptor\fR (const ACE_PEER_ACCEPTOR_ADDR &local_addr, \fBACE_Reactor\fR * = ACE_Reactor::instance (), int flags = 0, int use_select = 1, int reuse_addr = 1)"
.br
.ti -1c
.RI "int \fBopen\fR (const ACE_PEER_ACCEPTOR_ADDR &, \fBACE_Reactor\fR * = ACE_Reactor::instance (), int flags = 0, int use_select = 1, int reuse_addr = 1)"
.br
.ti -1c
.RI "virtual \fB~ACE_Acceptor\fR (void)"
.br
.RI "\fIClose down the Acceptor's resources.\fR"
.ti -1c
.RI "virtual \fBoperator ACE_PEER_ACCEPTOR &\fR () const"
.br
.RI "\fIReturn the underlying PEER_ACCEPTOR object.\fR"
.ti -1c
.RI "virtual ACE_PEER_ACCEPTOR& \fBacceptor\fR (void) const"
.br
.RI "\fIReturn the underlying PEER_ACCEPTOR object.\fR"
.ti -1c
.RI "virtual ACE_HANDLE \fBget_handle\fR (void) const"
.br
.RI "\fIReturns the listening acceptor's .\fR"
.ti -1c
.RI "virtual int \fBclose\fR (void)"
.br
.RI "\fIClose down the Acceptor.\fR"
.ti -1c
.RI "void \fBdump\fR (void) const"
.br
.RI "\fIDump the state of an object.\fR"
.ti -1c
.RI "virtual int \fBsuspend\fR (void)"
.br
.RI "\fIThis method calls <Reactor::suspend>.\fR"
.ti -1c
.RI "virtual int \fBresume\fR (void)"
.br
.RI "\fIThis method calls <Reactor::resume>.\fR"
.in -1c
.SS Public Attributes

.in +1c
.ti -1c
.RI "\fBACE_ALLOC_HOOK_DECLARE\fR"
.br
.RI "\fIDeclare the dynamic allocation hooks.\fR"
.in -1c
.SS Protected Methods

.in +1c
.ti -1c
.RI "virtual int \fBmake_svc_handler\fR (SVC_HANDLER *&sh)"
.br
.ti -1c
.RI "virtual int \fBaccept_svc_handler\fR (SVC_HANDLER *svc_handler)"
.br
.ti -1c
.RI "virtual int \fBactivate_svc_handler\fR (SVC_HANDLER *svc_handler)"
.br
.ti -1c
.RI "virtual int \fBhandle_close\fR (ACE_HANDLE = ACE_INVALID_HANDLE, \fBACE_Reactor_Mask\fR = ACE_Event_Handler::ALL_EVENTS_MASK)"
.br
.RI "\fIPerform termination activities when <this> is removed from the <reactor>.\fR"
.ti -1c
.RI "virtual int \fBhandle_input\fR (ACE_HANDLE)"
.br
.RI "\fIAccepts all pending connections from clients, and creates and activates SVC_HANDLERs.\fR"
.ti -1c
.RI "virtual int \fBinit\fR (int argc, \fBACE_TCHAR\fR *argv[])"
.br
.RI "\fIDefault version does no work and returns -1. Must be overloaded by application developer to do anything meaningful.\fR"
.ti -1c
.RI "virtual int \fBfini\fR (void)"
.br
.RI "\fICalls <handle_close>.\fR"
.ti -1c
.RI "virtual int \fBinfo\fR (\fBACE_TCHAR\fR **buf, size_t) const"
.br
.RI "\fIDefault version returns address info in <buf>.\fR"
.in -1c
.SS Protected Attributes

.in +1c
.ti -1c
.RI "ACE_PEER_ACCEPTOR \fBpeer_acceptor_\fR"
.br
.RI "\fIConcrete factory for accepting connections from clients...\fR"
.ti -1c
.RI "ACE_PEER_ACCEPTOR_ADDR \fBpeer_acceptor_addr_\fR"
.br
.RI "\fINeeded to reopen the socket if  fails.\fR"
.ti -1c
.RI "int \fBflags_\fR"
.br
.ti -1c
.RI "int \fBuse_select_\fR"
.br
.RI "\fIFlag that indicates whether it shall use <select> in the -loop.\fR"
.ti -1c
.RI "int \fBreuse_addr_\fR"
.br
.RI "\fINeeded to reopen the socket if  fails.\fR"
.in -1c
.SH DETAILED DESCRIPTION
.PP 

.SS template<class SVC_HANDLER, ACE_PEER_ACCEPTOR_1>  template class ACE_Acceptor
Abstract factory for creating a service handler (SVC_HANDLER), accepting into the SVC_HANDLER, and activating the SVC_HANDLER.
.PP
.PP
 Implements the basic strategy for passively establishing connections with clients. An ACE_Acceptor is parameterized by concrete types that conform to the interfaces of PEER_ACCEPTOR and SVC_HANDLER. The PEER_ACCEPTOR is instantiated with a transport mechanism that passively establishes connections. The SVC_HANDLER is instantiated with a concrete type that performs the application-specific service. An ACE_Acceptor inherits from \fBACE_Service_Object\fR, which in turn inherits from \fBACE_Event_Handler\fR. This enables the \fBACE_Reactor\fR to dispatch the ACE_Acceptor's handle_input method when connection events occur. The handle_input method performs the ACE_Acceptor's default creation, connection establishment, and service activation strategies. These strategies can be overridden by subclasses individually or as a group. 
.PP
.SH CONSTRUCTOR & DESTRUCTOR DOCUMENTATION
.PP 
.SS template<classSVC_HANDLER, ACE_PEER_ACCEPTOR_1> ACE_Acceptor<SVC_HANDLER, >::ACE_Acceptor<SVC_HANDLER, > (\fBACE_Reactor\fR * = 0, int use_select = 1)
.PP
"Do-nothing" constructor.
.PP
.SS template<classSVC_HANDLER, ACE_PEER_ACCEPTOR_1> ACE_Acceptor<SVC_HANDLER, >::ACE_Acceptor<SVC_HANDLER, > (const ACE_PEER_ACCEPTOR_ADDR & local_addr, \fBACE_Reactor\fR * = ACE_Reactor::instance (), int flags = 0, int use_select = 1, int reuse_addr = 1)
.PP
Initialize and register <this> with the Reactor and listen for connection requests at the designated <local_addr>. <flags> indicates how <SVC_HANDLER>'s should be initialized prior to being activated. Right now, the only flag that is processed is , which enabled non-blocking I/O on the <SVC_HANDLER> when it is opened. If <use_select> is non-zero then <select> is used to determine when to break out of the  loop. <reuse_addr> is passed down to the <PEER_ACCEPTOR>. If it is non-zero this will allow the OS to reuse this listen port. 
.SS template<classSVC_HANDLER, ACE_PEER_ACCEPTOR_1> ACE_Acceptor<SVC_HANDLER, >::~ACE_Acceptor<SVC_HANDLER, > (void)\fC [virtual]\fR
.PP
Close down the Acceptor's resources.
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS template<classSVC_HANDLER, ACE_PEER_ACCEPTOR_1> int ACE_Acceptor<SVC_HANDLER, >::accept_svc_handler (SVC_HANDLER * svc_handler)\fC [protected, virtual]\fR
.PP
Bridge method for accepting the new connection into the <svc_handler>. The default behavior delegates to the PEER_ACCEPTOR::accept. 
.PP
Reimplemented in \fBACE_Strategy_Acceptor\fR.
.SS template<classSVC_HANDLER, ACE_PEER_ACCEPTOR_1> ACE_PEER_ACCEPTOR & ACE_Acceptor<SVC_HANDLER, >::acceptor (void) const\fC [virtual]\fR
.PP
Return the underlying PEER_ACCEPTOR object.
.PP
Reimplemented in \fBACE_Strategy_Acceptor\fR.
.SS template<classSVC_HANDLER, ACE_PEER_ACCEPTOR_1> int ACE_Acceptor<SVC_HANDLER, >::activate_svc_handler (SVC_HANDLER * svc_handler)\fC [protected, virtual]\fR
.PP
Bridge method for activating a <svc_handler> with the appropriate concurrency strategy. The default behavior of this method is to activate the SVC_HANDLER by calling its <open> method (which allows the SVC_HANDLER to define its own concurrency strategy). However, subclasses can override this strategy to do more sophisticated concurrency activations (such as making the SVC_HANDLER as an "active object" via multi-threading or multi-processing). 
.PP
Reimplemented in \fBACE_Strategy_Acceptor\fR.
.SS template<classSVC_HANDLER, ACE_PEER_ACCEPTOR_1> int ACE_Acceptor<SVC_HANDLER, >::close (void)\fC [virtual]\fR
.PP
Close down the Acceptor.
.PP
.SS template<classSVC_HANDLER, ACE_PEER_ACCEPTOR_1> void ACE_Acceptor<SVC_HANDLER, >::dump (void) const
.PP
Dump the state of an object.
.PP
Reimplemented in \fBACE_Strategy_Acceptor\fR.
.SS template<classSVC_HANDLER, ACE_PEER_ACCEPTOR_1> int ACE_Acceptor<SVC_HANDLER, >::fini (void)\fC [protected, virtual]\fR
.PP
Calls <handle_close>.
.PP
Reimplemented from \fBACE_Shared_Object\fR.
.PP
Reimplemented in \fBACE_Strategy_Acceptor\fR.
.SS template<classSVC_HANDLER, ACE_PEER_ACCEPTOR_1> ACE_HANDLE ACE_Acceptor<SVC_HANDLER, >::get_handle (void) const\fC [virtual]\fR
.PP
Returns the listening acceptor's .
.PP
Reimplemented from \fBACE_Event_Handler\fR.
.PP
Reimplemented in \fBACE_Strategy_Acceptor\fR.
.SS template<classSVC_HANDLER, ACE_PEER_ACCEPTOR_1> int ACE_Acceptor<SVC_HANDLER, >::handle_close (ACE_HANDLE handle = ACE_INVALID_HANDLE, \fBACE_Reactor_Mask\fR close_mask = ACE_Event_Handler::ALL_EVENTS_MASK)\fC [protected, virtual]\fR
.PP
Perform termination activities when <this> is removed from the <reactor>.
.PP
Reimplemented from \fBACE_Event_Handler\fR.
.PP
Reimplemented in \fBACE_Strategy_Acceptor\fR.
.SS template<classSVC_HANDLER, ACE_PEER_ACCEPTOR_1> int ACE_Acceptor<SVC_HANDLER, >::handle_input (ACE_HANDLE fd)\fC [protected, virtual]\fR
.PP
Accepts all pending connections from clients, and creates and activates SVC_HANDLERs.
.PP
Reimplemented from \fBACE_Event_Handler\fR.
.SS template<classSVC_HANDLER, ACE_PEER_ACCEPTOR_1> int ACE_Acceptor<SVC_HANDLER, >::info (\fBACE_TCHAR\fR ** buf, size_t length) const\fC [protected, virtual]\fR
.PP
Default version returns address info in <buf>.
.PP
Reimplemented from \fBACE_Shared_Object\fR.
.PP
Reimplemented in \fBACE_Strategy_Acceptor\fR.
.SS template<classSVC_HANDLER, ACE_PEER_ACCEPTOR_1> int ACE_Acceptor<SVC_HANDLER, >::init (int argc, \fBACE_TCHAR\fR * argv[])\fC [protected, virtual]\fR
.PP
Default version does no work and returns -1. Must be overloaded by application developer to do anything meaningful.
.PP
Reimplemented from \fBACE_Shared_Object\fR.
.SS template<classSVC_HANDLER, ACE_PEER_ACCEPTOR_1> int ACE_Acceptor<SVC_HANDLER, >::make_svc_handler (SVC_HANDLER *& sh)\fC [protected, virtual]\fR
.PP
Bridge method for creating a SVC_HANDLER. The default is to create a new <SVC_HANDLER> if <sh> == 0, else <sh> is unchanged. However, subclasses can override this policy to perform SVC_HANDLER creation in any way that they like (such as creating subclass instances of SVC_HANDLER, using a singleton, dynamically linking the handler, etc.). Returns -1 on failure, else 0. 
.PP
Reimplemented in \fBACE_Strategy_Acceptor\fR.
.SS template<classSVC_HANDLER, ACE_PEER_ACCEPTOR_1> int ACE_Acceptor<SVC_HANDLER, >::open (const ACE_PEER_ACCEPTOR_ADDR &, \fBACE_Reactor\fR * = ACE_Reactor::instance (), int flags = 0, int use_select = 1, int reuse_addr = 1)
.PP
Initialize and register <this> with the Reactor and listen for connection requests at the designated <local_addr>. <flags> indicates how <SVC_HANDLER>'s should be initialized prior to being activated. Right now, the only flag that is processed is , which enabled non-blocking I/O on the <SVC_HANDLER> when it is opened. If <use_select> is non-zero then <select> is used to determine when to break out of the  loop. <reuse_addr> is passed down to the <PEER_ACCEPTOR>. If it is non-zero this will allow the OS to reuse this listen port. 
.SS template<classSVC_HANDLER, ACE_PEER_ACCEPTOR_1> ACE_Acceptor<SVC_HANDLER, >::operator ACE_PEER_ACCEPTOR & () const\fC [virtual]\fR
.PP
Return the underlying PEER_ACCEPTOR object.
.PP
Reimplemented in \fBACE_Strategy_Acceptor\fR.
.SS template<classSVC_HANDLER, ACE_PEER_ACCEPTOR_1> int ACE_Acceptor<SVC_HANDLER, >::resume (void)\fC [virtual]\fR
.PP
This method calls <Reactor::resume>.
.PP
Reimplemented from \fBACE_Service_Object\fR.
.PP
Reimplemented in \fBACE_Strategy_Acceptor\fR.
.SS template<classSVC_HANDLER, ACE_PEER_ACCEPTOR_1> int ACE_Acceptor<SVC_HANDLER, >::suspend (void)\fC [virtual]\fR
.PP
This method calls <Reactor::suspend>.
.PP
Reimplemented from \fBACE_Service_Object\fR.
.PP
Reimplemented in \fBACE_Strategy_Acceptor\fR.
.SH MEMBER DATA DOCUMENTATION
.PP 
.SS template<classSVC_HANDLER, ACE_PEER_ACCEPTOR_1> ACE_Acceptor<SVC_HANDLER, >::ACE_ALLOC_HOOK_DECLARE
.PP
Declare the dynamic allocation hooks.
.PP
Reimplemented in \fBACE_Strategy_Acceptor\fR.
.SS template<classSVC_HANDLER, ACE_PEER_ACCEPTOR_1> int ACE_Acceptor<SVC_HANDLER, >::flags_\fC [protected]\fR
.PP
Flags that indicate how <SVC_HANDLER>'s should be initialized prior to being activated. Right now, the only flag that is processed is , which enabled non-blocking I/O on the <SVC_HANDLER> when it is opened. 
.SS template<classSVC_HANDLER, ACE_PEER_ACCEPTOR_1> ACE_PEER_ACCEPTOR ACE_Acceptor<SVC_HANDLER, >::peer_acceptor_\fC [protected]\fR
.PP
Concrete factory for accepting connections from clients...
.PP
.SS template<classSVC_HANDLER, ACE_PEER_ACCEPTOR_1> ACE_PEER_ACCEPTOR_ADDR ACE_Acceptor<SVC_HANDLER, >::peer_acceptor_addr_\fC [protected]\fR
.PP
Needed to reopen the socket if  fails.
.PP
.SS template<classSVC_HANDLER, ACE_PEER_ACCEPTOR_1> int ACE_Acceptor<SVC_HANDLER, >::reuse_addr_\fC [protected]\fR
.PP
Needed to reopen the socket if  fails.
.PP
.SS template<classSVC_HANDLER, ACE_PEER_ACCEPTOR_1> int ACE_Acceptor<SVC_HANDLER, >::use_select_\fC [protected]\fR
.PP
Flag that indicates whether it shall use <select> in the -loop.
.PP


.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.