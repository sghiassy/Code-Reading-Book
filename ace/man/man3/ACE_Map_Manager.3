.TH ACE_Map_Manager 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_Map_Manager \- Define a map abstraction that associates <EXT_ID>s with <INT_ID>s. 
.SH SYNOPSIS
.br
.PP
\fC#include <Map_Manager.h>\fR
.PP
Inherited by \fBACE_Active_Map_Manager\fR.
.PP
.SS Public Types

.in +1c
.ti -1c
.RI "typedef EXT_ID \fBKEY\fR"
.br
.ti -1c
.RI "typedef INT_ID \fBVALUE\fR"
.br
.ti -1c
.RI "typedef \fBACE_Map_Entry\fR<EXT_ID, INT_ID> \fBENTRY\fR"
.br
.ti -1c
.RI "typedef \fBACE_Map_Iterator\fR<EXT_ID, INT_ID, ACE_LOCK> \fBITERATOR\fR"
.br
.ti -1c
.RI "typedef \fBACE_Map_Const_Iterator\fR<EXT_ID, INT_ID, ACE_LOCK> \fBCONST_ITERATOR\fR"
.br
.ti -1c
.RI "typedef \fBACE_Map_Reverse_Iterator\fR<EXT_ID, INT_ID, ACE_LOCK> \fBREVERSE_ITERATOR\fR"
.br
.ti -1c
.RI "typedef \fBACE_Map_Iterator\fR<EXT_ID, INT_ID, ACE_LOCK> \fBiterator\fR"
.br
.ti -1c
.RI "typedef \fBACE_Map_Const_Iterator\fR<EXT_ID, INT_ID, ACE_LOCK> \fBconst_iterator\fR"
.br
.ti -1c
.RI "typedef \fBACE_Map_Reverse_Iterator\fR<EXT_ID, INT_ID, ACE_LOCK> \fBreverse_iterator\fR"
.br
.in -1c
.SS Public Methods

.in +1c
.ti -1c
.RI "\fBACE_Map_Manager\fR (\fBACE_Allocator\fR *alloc = 0)"
.br
.RI "\fIInitialize a <Map_Manager> with the .\fR"
.ti -1c
.RI "\fBACE_Map_Manager\fR (size_t size, \fBACE_Allocator\fR *alloc = 0)"
.br
.RI "\fIInitialize a <Map_Manager> with <size> entries.\fR"
.ti -1c
.RI "int \fBopen\fR (size_t length = ACE_DEFAULT_MAP_SIZE, \fBACE_Allocator\fR *alloc = 0)"
.br
.RI "\fIInitialize a <Map_Manager> with size <length>.\fR"
.ti -1c
.RI "int \fBclose\fR (void)"
.br
.RI "\fIClose down a <Map_Manager> and release dynamically allocated resources.\fR"
.ti -1c
.RI "\fB~ACE_Map_Manager\fR (void)"
.br
.RI "\fIClose down a <Map_Manager> and release dynamically allocated resources.\fR"
.ti -1c
.RI "int \fBbind\fR (const EXT_ID &ext_id, const INT_ID &int_id)"
.br
.ti -1c
.RI "int \fBrebind\fR (const EXT_ID &ext_id, const INT_ID &int_id, EXT_ID &old_ext_id, INT_ID &old_int_id)"
.br
.ti -1c
.RI "int \fBrebind\fR (const EXT_ID &ext_id, const INT_ID &int_id, INT_ID &old_int_id)"
.br
.ti -1c
.RI "int \fBrebind\fR (const EXT_ID &ext_id, const INT_ID &int_id)"
.br
.RI "\fIReassociate <ext_id> with <int_id>. Old values in the map are ignored.\fR"
.ti -1c
.RI "int \fBtrybind\fR (const EXT_ID &ext_id, INT_ID &int_id)"
.br
.ti -1c
.RI "int \fBfind\fR (const EXT_ID &ext_id, INT_ID &int_id) const"
.br
.RI "\fILocate <ext_id> and pass out parameter via <int_id>. Returns 0 if found, returns -1 if not found.\fR"
.ti -1c
.RI "int \fBfind\fR (const EXT_ID &ext_id) const"
.br
.RI "\fIReturns 0 if the <ext_id> is in the mapping, otherwise -1.\fR"
.ti -1c
.RI "int \fBunbind\fR (const EXT_ID &ext_id)"
.br
.ti -1c
.RI "int \fBunbind\fR (const EXT_ID &ext_id, INT_ID &int_id)"
.br
.ti -1c
.RI "void \fBunbind_all\fR (void)"
.br
.ti -1c
.RI "size_t \fBcurrent_size\fR (void) const"
.br
.RI "\fIReturn the current size of the map.\fR"
.ti -1c
.RI "size_t \fBtotal_size\fR (void) const"
.br
.RI "\fIReturn the total size of the map.\fR"
.ti -1c
.RI "ACE_LOCK& \fBmutex\fR (void)"
.br
.ti -1c
.RI "void \fBdump\fR (void) const"
.br
.RI "\fIDump the state of an object.\fR"
.ti -1c
.RI "\fBACE_Map_Iterator\fR<EXT_ID, INT_ID, ACE_LOCK> \fBbegin\fR (void)"
.br
.RI "\fIReturn forward iterator.\fR"
.ti -1c
.RI "\fBACE_Map_Iterator\fR<EXT_ID, INT_ID, ACE_LOCK> \fBend\fR (void)"
.br
.ti -1c
.RI "\fBACE_Map_Reverse_Iterator\fR<EXT_ID, INT_ID, ACE_LOCK> \fBrbegin\fR (void)"
.br
.RI "\fIReturn reverse iterator.\fR"
.ti -1c
.RI "\fBACE_Map_Reverse_Iterator\fR<EXT_ID, INT_ID, ACE_LOCK> \fBrend\fR (void)"
.br
.in -1c
.SS Public Attributes

.in +1c
.ti -1c
.RI "\fBACE_ALLOC_HOOK_DECLARE\fR"
.br
.RI "\fIDeclare the dynamic allocation hooks.\fR"
.in -1c
.SS Protected Types

.in +1c
.ti -1c
.RI "enum { \fBMAX_EXPONENTIAL\fR = 64 * 1024, \fBLINEAR_INCREASE\fR = 32 * 1024 }"
.br
.in -1c
.SS Protected Methods

.in +1c
.ti -1c
.RI "int \fBbind_i\fR (const EXT_ID &ext_id, const INT_ID &int_id)"
.br
.RI "\fIPerforms the binding of <ext_id> to <int_id>. Must be called with locks held.\fR"
.ti -1c
.RI "int \fBshared_bind\fR (const EXT_ID &ext_id, const INT_ID &int_id)"
.br
.RI "\fIBind an entry (without finding first). Must be called with locks held.\fR"
.ti -1c
.RI "int \fBrebind_i\fR (const EXT_ID &ext_id, const INT_ID &int_id, EXT_ID &old_ext_id, INT_ID &old_int_id)"
.br
.RI "\fIPerforms a rebinding of <ext_it> to <int_id>. Also, recovers old values. Must be called with locks held.\fR"
.ti -1c
.RI "int \fBrebind_i\fR (const EXT_ID &ext_id, const INT_ID &int_id, INT_ID &old_int_id)"
.br
.RI "\fIPerforms a rebinding of <ext_it> to <int_id>. Also, recovers old values. Must be called with locks held.\fR"
.ti -1c
.RI "int \fBrebind_i\fR (const EXT_ID &ext_id, const INT_ID &int_id)"
.br
.RI "\fIPerforms a rebinding of <ext_it> to <int_id>. Must be called with locks held.\fR"
.ti -1c
.RI "int \fBtrybind_i\fR (const EXT_ID &ext_id, INT_ID &int_id)"
.br
.RI "\fIPerforms a conditional bind of <int_id> using <ext_id> as the key. Must be called with locks held.\fR"
.ti -1c
.RI "int \fBfind_i\fR (const EXT_ID &ext_id, INT_ID &int_id)"
.br
.RI "\fIPerforms a find of <int_id> using <ext_id> as the key. Must be called with locks held.\fR"
.ti -1c
.RI "int \fBfind_and_return_index\fR (const EXT_ID &ext_id, ACE_UINT32 &slot)"
.br
.RI "\fIPerforms a find using <ext_id> as the key. Must be called with locks held.\fR"
.ti -1c
.RI "int \fBunbind_i\fR (const EXT_ID &ext_id, INT_ID &int_id)"
.br
.RI "\fIPerforms an unbind of <int_id> using <ext_id> as the key. Must be called with locks held.\fR"
.ti -1c
.RI "int \fBunbind_i\fR (const EXT_ID &ext_id)"
.br
.RI "\fIPerforms an unbind using <ext_id> as the key. Must be called with locks held.\fR"
.ti -1c
.RI "int \fBunbind_and_return_index\fR (const EXT_ID &ext_id, ACE_UINT32 &slot)"
.br
.RI "\fIPerforms an unbind using <ext_id> as the key. Must be called with locks held.\fR"
.ti -1c
.RI "void \fBunbind_slot\fR (ACE_UINT32 slot)"
.br
.RI "\fIUnbind <slot>.\fR"
.ti -1c
.RI "int \fBresize_i\fR (ACE_UINT32 size)"
.br
.RI "\fIResize the map. Must be called with locks held.\fR"
.ti -1c
.RI "int \fBclose_i\fR (void)"
.br
.RI "\fIClose down a <Map_Manager>. Must be called with locks held.\fR"
.ti -1c
.RI "int \fBequal\fR (const EXT_ID &id1, const EXT_ID &id2)"
.br
.RI "\fIReturns 1 if <id1> == <id2>, else 0. This is defined as a separate method to facilitate template specialization.\fR"
.ti -1c
.RI "ACE_UINT32 \fBnew_size\fR (void)"
.br
.RI "\fIThis function returns the new size of the Map Manager. This function is called when we run out of room and need to resize.\fR"
.ti -1c
.RI "void \fBfree_search_structure\fR (void)"
.br
.RI "\fIExplicitly call the destructors and free up the <search_structure_>.\fR"
.ti -1c
.RI "ACE_UINT32 \fBfree_list_id\fR (void) const"
.br
.RI "\fIId of the free list sentinel.\fR"
.ti -1c
.RI "ACE_UINT32 \fBoccupied_list_id\fR (void) const"
.br
.RI "\fIId of the occupied list sentinel.\fR"
.ti -1c
.RI "int \fBnext_free\fR (ACE_UINT32 &slot)"
.br
.RI "\fIFinds the next free slot.\fR"
.ti -1c
.RI "void \fBmove_from_free_list_to_occupied_list\fR (ACE_UINT32 slot)"
.br
.RI "\fIMove from free list to occupied list.\fR"
.ti -1c
.RI "void \fBmove_from_occupied_list_to_free_list\fR (ACE_UINT32 slot)"
.br
.RI "\fIMove from occupied list to free list.\fR"
.ti -1c
.RI "void \fBshared_move\fR (ACE_UINT32 slot, \fBACE_Map_Entry\fR<EXT_ID, INT_ID> &current_list, ACE_UINT32 current_list_id, \fBACE_Map_Entry\fR<EXT_ID, INT_ID> &new_list, ACE_UINT32 new_list_id)"
.br
.RI "\fIMove helper.\fR"
.in -1c
.SS Protected Attributes

.in +1c
.ti -1c
.RI "\fBACE_Allocator\fR* \fBallocator_\fR"
.br
.RI "\fIPointer to a memory allocator.\fR"
.ti -1c
.RI "ACE_LOCK \fBlock_\fR"
.br
.RI "\fISynchronization variable for the MT_SAFE .\fR"
.ti -1c
.RI "\fBACE_Map_Entry\fR<EXT_ID, INT_ID>* \fBsearch_structure_\fR"
.br
.RI "\fIImplement the Map as a resizeable array of .\fR"
.ti -1c
.RI "ACE_UINT32 \fBtotal_size_\fR"
.br
.RI "\fITotal number of elements in this->search_structure_.\fR"
.ti -1c
.RI "ACE_UINT32 \fBcur_size_\fR"
.br
.RI "\fICurrent size of the map.\fR"
.ti -1c
.RI "\fBACE_Map_Entry\fR<EXT_ID, INT_ID> \fBfree_list_\fR"
.br
.RI "\fIFree list.\fR"
.ti -1c
.RI "\fBACE_Map_Entry\fR<EXT_ID, INT_ID> \fBoccupied_list_\fR"
.br
.RI "\fIOccupied list.\fR"
.in -1c
.SS Private Methods

.in +1c
.ti -1c
.RI "void \fBoperator=\fR (const ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK> &)"
.br
.ti -1c
.RI "\fBACE_Map_Manager\fR (const ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK> &)"
.br
.in -1c
.SS Friends

.in +1c
.ti -1c
.RI "class \fBACE_Map_Iterator_Base< EXT_ID,INT_ID,ACE_LOCK >\fR"
.br
.ti -1c
.RI "class \fBACE_Map_Const_Iterator_Base< EXT_ID,INT_ID,ACE_LOCK >\fR"
.br
.ti -1c
.RI "class \fBACE_Map_Iterator< EXT_ID,INT_ID,ACE_LOCK >\fR"
.br
.ti -1c
.RI "class \fBACE_Map_Const_Iterator< EXT_ID,INT_ID,ACE_LOCK >\fR"
.br
.ti -1c
.RI "class \fBACE_Map_Reverse_Iterator< EXT_ID,INT_ID,ACE_LOCK >\fR"
.br
.in -1c
.SH DETAILED DESCRIPTION
.PP 

.SS template<class EXT_ID, class INT_ID, class ACE_LOCK>  template class ACE_Map_Manager
Define a map abstraction that associates <EXT_ID>s with <INT_ID>s.
.PP
.PP
 The <EXT_ID> must support <operator==>. This constraint can be alleviated via template specialization, as shown in the $ACE_ROOT/tests/Conn_Test.cpp test. This class uses an  to allocate memory. The user can make this a persistant class by providing an  with a persistable memory pool. This implementation of a map uses an array, which is searched linearly. For more efficient searching you should use the . 
.PP
.SH MEMBER TYPEDEF DOCUMENTATION
.PP 
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> typedef \fBACE_Map_Const_Iterator\fR<EXT_ID, INT_ID, ACE_LOCK> ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::CONST_ITERATOR
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> typedef \fBACE_Map_Entry\fR<EXT_ID, INT_ID> ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::ENTRY
.PP
Reimplemented in \fBACE_Active_Map_Manager\fR.
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> typedef \fBACE_Map_Iterator\fR<EXT_ID, INT_ID, ACE_LOCK> ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::ITERATOR
.PP
Reimplemented in \fBACE_Active_Map_Manager\fR.
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> typedef EXT_ID ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::KEY
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> typedef \fBACE_Map_Reverse_Iterator\fR<EXT_ID, INT_ID, ACE_LOCK> ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::REVERSE_ITERATOR
.PP
Reimplemented in \fBACE_Active_Map_Manager\fR.
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> typedef INT_ID ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::VALUE
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> typedef \fBACE_Map_Const_Iterator\fR<EXT_ID, INT_ID, ACE_LOCK> ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::const_iterator
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> typedef \fBACE_Map_Iterator\fR<EXT_ID, INT_ID, ACE_LOCK> ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::iterator
.PP
Reimplemented in \fBACE_Active_Map_Manager\fR.
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> typedef \fBACE_Map_Reverse_Iterator\fR<EXT_ID, INT_ID, ACE_LOCK> ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::reverse_iterator
.PP
Reimplemented in \fBACE_Active_Map_Manager\fR.
.SH MEMBER ENUMERATION DOCUMENTATION
.PP 
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> anonymous enum\fC [protected]\fR
.PP
\fBEnumeration values:\fR
.in +1c
.TP
\fB\fIMAX_EXPONENTIAL\fR \fRGrow map exponentially up to 64K.
.TP
\fB\fILINEAR_INCREASE\fR \fRAfterwards grow in chunks of 32K.
.SH CONSTRUCTOR & DESTRUCTOR DOCUMENTATION
.PP 
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK> (\fBACE_Allocator\fR * alloc = 0)
.PP
Initialize a <Map_Manager> with the .
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK> (size_t size, \fBACE_Allocator\fR * alloc = 0)
.PP
Initialize a <Map_Manager> with <size> entries.
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::~ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK> (void)
.PP
Close down a <Map_Manager> and release dynamically allocated resources.
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK> (const ACE_Map_Manager< EXT_ID,INT_ID,ACE_LOCK >&)\fC [private]\fR
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> \fBACE_Map_Iterator\fR< EXT_ID,INT_ID,ACE_LOCK > ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::begin (void)
.PP
Return forward iterator.
.PP
Reimplemented in \fBACE_Active_Map_Manager\fR.
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> int ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::bind (const EXT_ID & ext_id, const INT_ID & int_id)
.PP
Associate <ext_id> with <int_id>. If <ext_id> is already in the map then the <Map_Entry> is not changed. Returns 0 if a new entry is bound successfully, returns 1 if an attempt is made to bind an existing entry, and returns -1 if failures occur. 
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> int ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::bind_i (const EXT_ID & ext_id, const INT_ID & int_id)\fC [protected]\fR
.PP
Performs the binding of <ext_id> to <int_id>. Must be called with locks held.
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> int ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::close (void)
.PP
Close down a <Map_Manager> and release dynamically allocated resources.
.PP
Reimplemented in \fBACE_Active_Map_Manager\fR.
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> int ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::close_i (void)\fC [protected]\fR
.PP
Close down a <Map_Manager>. Must be called with locks held.
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> size_t ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::current_size (void) const
.PP
Return the current size of the map.
.PP
Reimplemented in \fBACE_Active_Map_Manager\fR.
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> void ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::dump (void) const
.PP
Dump the state of an object.
.PP
Reimplemented in \fBACE_Active_Map_Manager\fR.
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> \fBACE_Map_Iterator\fR<EXT_ID, INT_ID, ACE_LOCK> ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::end (void)
.PP
Reimplemented in \fBACE_Active_Map_Manager\fR.
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> int ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::equal (const EXT_ID & id1, const EXT_ID & id2)\fC [protected]\fR
.PP
Returns 1 if <id1> == <id2>, else 0. This is defined as a separate method to facilitate template specialization.
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> int ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::find (const EXT_ID & ext_id) const
.PP
Returns 0 if the <ext_id> is in the mapping, otherwise -1.
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> int ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::find (const EXT_ID & ext_id, INT_ID & int_id) const
.PP
Locate <ext_id> and pass out parameter via <int_id>. Returns 0 if found, returns -1 if not found.
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> int ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::find_and_return_index (const EXT_ID & ext_id, ACE_UINT32 & slot)\fC [protected]\fR
.PP
Performs a find using <ext_id> as the key. Must be called with locks held.
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> int ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::find_i (const EXT_ID & ext_id, INT_ID & int_id)\fC [protected]\fR
.PP
Performs a find of <int_id> using <ext_id> as the key. Must be called with locks held.
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> ACE_UINT32 ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::free_list_id (void) const\fC [protected]\fR
.PP
Id of the free list sentinel.
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> void ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::free_search_structure (void)\fC [protected]\fR
.PP
Explicitly call the destructors and free up the <search_structure_>.
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> void ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::move_from_free_list_to_occupied_list (ACE_UINT32 slot)\fC [protected]\fR
.PP
Move from free list to occupied list.
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> void ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::move_from_occupied_list_to_free_list (ACE_UINT32 slot)\fC [protected]\fR
.PP
Move from occupied list to free list.
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> ACE_LOCK & ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::mutex (void)
.PP
Returns a reference to the underlying . This makes it possible to acquire the lock explicitly, which can be useful in some cases if you instantiate the  with an  or , or if you need to guard the state of an iterator. NOTE: the right name would be <lock>, but HP/C++ will choke on that! 
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> ACE_UINT32 ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::new_size (void)\fC [protected]\fR
.PP
This function returns the new size of the Map Manager. This function is called when we run out of room and need to resize.
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> int ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::next_free (ACE_UINT32 & slot)\fC [protected]\fR
.PP
Finds the next free slot.
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> ACE_UINT32 ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::occupied_list_id (void) const\fC [protected]\fR
.PP
Id of the occupied list sentinel.
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> int ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::open (size_t length = ACE_DEFAULT_MAP_SIZE, \fBACE_Allocator\fR * alloc = 0)
.PP
Initialize a <Map_Manager> with size <length>.
.PP
Reimplemented in \fBACE_Active_Map_Manager\fR.
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> void ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::operator= (const ACE_Map_Manager< EXT_ID,INT_ID,ACE_LOCK >&)\fC [private]\fR
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> \fBACE_Map_Reverse_Iterator\fR< EXT_ID,INT_ID,ACE_LOCK > ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::rbegin (void)
.PP
Return reverse iterator.
.PP
Reimplemented in \fBACE_Active_Map_Manager\fR.
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> int ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::rebind (const EXT_ID & ext_id, const INT_ID & int_id)
.PP
Reassociate <ext_id> with <int_id>. Old values in the map are ignored.
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> int ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::rebind (const EXT_ID & ext_id, const INT_ID & int_id, INT_ID & old_int_id)
.PP
Reassociate <ext_id> with <int_id>. If <ext_id> is not in the map then behaves just like <bind>. Otherwise, store the old values of <int_id> into the "out" parameter and rebind the new parameters. Returns 0 if a new entry is bound successfully, returns 1 if an existing entry was rebound, and returns -1 if failures occur. 
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> int ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::rebind (const EXT_ID & ext_id, const INT_ID & int_id, EXT_ID & old_ext_id, INT_ID & old_int_id)
.PP
Reassociate <ext_id> with <int_id>. If <ext_id> is not in the map then behaves just like <bind>. Otherwise, store the old values of <ext_id> and <int_id> into the "out" parameters and rebind the new parameters. This is very useful if you need to have an atomic way of updating <Map_Entries> and you also need full control over memory allocation. Returns 0 if a new entry is bound successfully, returns 1 if an existing entry was rebound, and returns -1 if failures occur. 
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> int ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::rebind_i (const EXT_ID & ext_id, const INT_ID & int_id)\fC [protected]\fR
.PP
Performs a rebinding of <ext_it> to <int_id>. Must be called with locks held.
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> int ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::rebind_i (const EXT_ID & ext_id, const INT_ID & int_id, INT_ID & old_int_id)\fC [protected]\fR
.PP
Performs a rebinding of <ext_it> to <int_id>. Also, recovers old values. Must be called with locks held.
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> int ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::rebind_i (const EXT_ID & ext_id, const INT_ID & int_id, EXT_ID & old_ext_id, INT_ID & old_int_id)\fC [protected]\fR
.PP
Performs a rebinding of <ext_it> to <int_id>. Also, recovers old values. Must be called with locks held.
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> \fBACE_Map_Reverse_Iterator\fR<EXT_ID, INT_ID, ACE_LOCK> ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::rend (void)
.PP
Reimplemented in \fBACE_Active_Map_Manager\fR.
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> int ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::resize_i (ACE_UINT32 size)\fC [protected]\fR
.PP
Resize the map. Must be called with locks held.
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> int ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::shared_bind (const EXT_ID & ext_id, const INT_ID & int_id)\fC [protected]\fR
.PP
Bind an entry (without finding first). Must be called with locks held.
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> void ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::shared_move (ACE_UINT32 slot, \fBACE_Map_Entry\fR< EXT_ID,INT_ID >& current_list, ACE_UINT32 current_list_id, \fBACE_Map_Entry\fR< EXT_ID,INT_ID >& new_list, ACE_UINT32 new_list_id)\fC [protected]\fR
.PP
Move helper.
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> size_t ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::total_size (void) const
.PP
Return the total size of the map.
.PP
Reimplemented in \fBACE_Active_Map_Manager\fR.
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> int ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::trybind (const EXT_ID & ext_id, INT_ID & int_id)
.PP
Associate <ext_id> with <int_id> if and only if <ext_id> is not in the map. If <ext_id> is already in the map then the <int_id> parameter is overwritten with the existing value in the map Returns 0 if a new entry is bound successfully, returns 1 if an attempt is made to bind an existing entry, and returns -1 if failures occur. 
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> int ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::trybind_i (const EXT_ID & ext_id, INT_ID & int_id)\fC [protected]\fR
.PP
Performs a conditional bind of <int_id> using <ext_id> as the key. Must be called with locks held.
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> int ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::unbind (const EXT_ID & ext_id, INT_ID & int_id)
.PP
Break any association of <ext_id>. Returns the value of <int_id> in case the caller needs to deallocate memory. Returns 0 if successful, else -1. 
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> int ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::unbind (const EXT_ID & ext_id)
.PP
Unbind (remove) the <ext_id> from the map. Don't return the <int_id> to the caller (this is useful for collections where the <int_id>s are *not* dynamically allocated...) Returns 0 if successful, else -1. 
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> void ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::unbind_all (void)
.PP
Unbind all entires. 
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> int ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::unbind_and_return_index (const EXT_ID & ext_id, ACE_UINT32 & slot)\fC [protected]\fR
.PP
Performs an unbind using <ext_id> as the key. Must be called with locks held.
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> int ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::unbind_i (const EXT_ID & ext_id)\fC [protected]\fR
.PP
Performs an unbind using <ext_id> as the key. Must be called with locks held.
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> int ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::unbind_i (const EXT_ID & ext_id, INT_ID & int_id)\fC [protected]\fR
.PP
Performs an unbind of <int_id> using <ext_id> as the key. Must be called with locks held.
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> void ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::unbind_slot (ACE_UINT32 slot)\fC [protected]\fR
.PP
Unbind <slot>.
.PP
.SH FRIENDS AND RELATED FUNCTION DOCUMENTATION
.PP 
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> class \fBACE_Map_Const_Iterator\fR\fC [friend]\fR
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> class \fBACE_Map_Const_Iterator_Base\fR\fC [friend]\fR
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> class \fBACE_Map_Iterator\fR\fC [friend]\fR
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> class \fBACE_Map_Iterator_Base\fR\fC [friend]\fR
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> class \fBACE_Map_Reverse_Iterator\fR\fC [friend]\fR
.PP
.SH MEMBER DATA DOCUMENTATION
.PP 
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::ACE_ALLOC_HOOK_DECLARE
.PP
Declare the dynamic allocation hooks.
.PP
Reimplemented in \fBACE_Active_Map_Manager\fR.
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> \fBACE_Allocator\fR * ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::allocator_\fC [protected]\fR
.PP
Pointer to a memory allocator.
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> ACE_UINT32 ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::cur_size_\fC [protected]\fR
.PP
Current size of the map.
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> \fBACE_Map_Entry\fR< EXT_ID,INT_ID > ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::free_list_\fC [protected]\fR
.PP
Free list.
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> ACE_LOCK ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::lock_\fC [protected]\fR
.PP
Synchronization variable for the MT_SAFE .
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> \fBACE_Map_Entry\fR< EXT_ID,INT_ID > ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::occupied_list_\fC [protected]\fR
.PP
Occupied list.
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> \fBACE_Map_Entry\fR< EXT_ID,INT_ID >* ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::search_structure_\fC [protected]\fR
.PP
Implement the Map as a resizeable array of .
.PP
.SS template<classEXT_ID, classINT_ID, classACE_LOCK> ACE_UINT32 ACE_Map_Manager<EXT_ID, INT_ID, ACE_LOCK>::total_size_\fC [protected]\fR
.PP
Total number of elements in this->search_structure_.
.PP


.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.