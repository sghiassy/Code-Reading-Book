.TH ACE_MEM_Addr 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_MEM_Addr \- Defines a C++ wrapper facade for the shared memory transport address family format. 
.SH SYNOPSIS
.br
.PP
\fC#include <MEM_Addr.h>\fR
.PP
Inherits \fBACE_Addr\fR.
.PP
.SS Public Methods

.in +1c
.ti -1c
.RI "\fBACE_MEM_Addr\fR (void)"
.br
.RI "\fIDefault constructor.\fR"
.ti -1c
.RI "\fBACE_MEM_Addr\fR (const ACE_MEM_Addr &)"
.br
.RI "\fICopy constructor.\fR"
.ti -1c
.RI "\fBACE_MEM_Addr\fR (u_short port_number)"
.br
.RI "\fICreates an  from a <port_number> and the remote <host_name>.\fR"
.ti -1c
.RI "ACE_EXPLICIT \fBACE_MEM_Addr\fR (const \fBACE_TCHAR\fR port_name[])"
.br
.RI "\fICreates an  from a <port_name>.\fR"
.ti -1c
.RI "\fB~ACE_MEM_Addr\fR (void)"
.br
.RI "\fIDefault dtor.\fR"
.ti -1c
.RI "int \fBinitialize_local\fR (u_short port)"
.br
.RI "\fIdefault initialization routine.\fR"
.ti -1c
.RI "int \fBsame_host\fR (const \fBACE_INET_Addr\fR& sap)"
.br
.RI "\fICheck if <sap> designate an enpoint withing the same host.\fR"
.ti -1c
.RI "int \fBset\fR (u_short port_number, int encode = 1)"
.br
.ti -1c
.RI "int \fBset\fR (const \fBACE_TCHAR\fR port_name[])"
.br
.RI "\fIUses <getservbyname> to initialize an  from a <port_name>, the remote <host_name>, and the <protocol>.\fR"
.ti -1c
.RI "virtual void* \fBget_addr\fR (void) const"
.br
.RI "\fIReturn a pointer to the underlying network address.\fR"
.ti -1c
.RI "virtual void \fBset_addr\fR (void *, int len)"
.br
.RI "\fISet a pointer to the address.\fR"
.ti -1c
.RI "virtual int \fBaddr_to_string\fR (\fBACE_TCHAR\fR buffer[], size_t size, int ipaddr_format = 1) const"
.br
.RI "\fITransform the external  address into string format.\fR"
.ti -1c
.RI "virtual int \fBstring_to_addr\fR (const \fBACE_TCHAR\fR address[])"
.br
.RI "\fIInitializes the external  from the .\fR"
.ti -1c
.RI "void \fBset_port_number\fR (u_short, int encode = 1)"
.br
.RI "\fISets the port number.\fR"
.ti -1c
.RI "u_short \fBget_port_number\fR (void) const"
.br
.RI "\fIReturn the port number, converting it into host byte order.\fR"
.ti -1c
.RI "int \fBget_host_name\fR (\fBACE_TCHAR\fR hostname[], size_t hostnamelen) const"
.br
.RI "\fIReturn the character representation of the hostname.\fR"
.ti -1c
.RI "const char* \fBget_host_name\fR (void) const"
.br
.ti -1c
.RI "const char* \fBget_host_addr\fR (void) const"
.br
.RI "\fIReturn the "dotted decimal" external address.\fR"
.ti -1c
.RI "ACE_UINT32 \fBget_ip_address\fR (void) const"
.br
.RI "\fIReturn the 4-byte external IP address, converting it into host byte order.\fR"
.ti -1c
.RI "const \fBACE_INET_Addr\fR& \fBget_remote_addr\fR (void) const"
.br
.ti -1c
.RI "const \fBACE_INET_Addr\fR& \fBget_local_addr\fR (void) const"
.br
.ti -1c
.RI "int \fBoperator==\fR (const ACE_MEM_Addr &SAP) const"
.br
.RI "\fICompare two addresses for equality. The addresses are considered equal if they contain the same IP address and port number.\fR"
.ti -1c
.RI "int \fBoperator==\fR (const \fBACE_INET_Addr\fR &SAP) const"
.br
.ti -1c
.RI "int \fBoperator!=\fR (const ACE_MEM_Addr &SAP) const"
.br
.RI "\fICompare two addresses for inequality.\fR"
.ti -1c
.RI "int \fBoperator!=\fR (const \fBACE_INET_Addr\fR &SAP) const"
.br
.ti -1c
.RI "virtual u_long \fBhash\fR (void) const"
.br
.RI "\fIComputes and returns hash value.\fR"
.ti -1c
.RI "void \fBdump\fR (void) const"
.br
.RI "\fIDump the state of an object.\fR"
.in -1c
.SS Public Attributes

.in +1c
.ti -1c
.RI "\fBACE_ALLOC_HOOK_DECLARE\fR"
.br
.RI "\fIDeclare the dynamic allocation hooks.\fR"
.in -1c
.SS Private Attributes

.in +1c
.ti -1c
.RI "\fBACE_INET_Addr\fR \fBexternal_\fR"
.br
.RI "\fIExternal INET addr used for identifying host.\fR"
.ti -1c
.RI "\fBACE_INET_Addr\fR \fBinternal_\fR"
.br
.RI "\fIInternal INET addr for accepting/connecting.\fR"
.in -1c
.SH DETAILED DESCRIPTION
.PP 
Defines a C++ wrapper facade for the shared memory transport address family format.
.PP
.SH CONSTRUCTOR & DESTRUCTOR DOCUMENTATION
.PP 
.SS ACE_MEM_Addr::ACE_MEM_Addr (void)
.PP
Default constructor.
.PP
.SS ACE_MEM_Addr::ACE_MEM_Addr (const ACE_MEM_Addr &)
.PP
Copy constructor.
.PP
.SS ACE_MEM_Addr::ACE_MEM_Addr (u_short port_number)
.PP
Creates an  from a <port_number> and the remote <host_name>.
.PP
.SS ACE_EXPLICIT ACE_MEM_Addr::ACE_MEM_Addr (const \fBACE_TCHAR\fR port_name[])
.PP
Creates an  from a <port_name>.
.PP
.SS ACE_MEM_Addr::~ACE_MEM_Addr (void)
.PP
Default dtor.
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS int ACE_MEM_Addr::addr_to_string (\fBACE_TCHAR\fR buffer[], size_t size, int ipaddr_format = 1) const\fC [virtual]\fR
.PP
Transform the external  address into string format.
.PP
.SS void ACE_MEM_Addr::dump (void) const
.PP
Dump the state of an object.
.PP
Reimplemented from \fBACE_Addr\fR.
.SS void * ACE_MEM_Addr::get_addr (void) const\fC [virtual]\fR
.PP
Return a pointer to the underlying network address.
.PP
Reimplemented from \fBACE_Addr\fR.
.SS const char * ACE_MEM_Addr::get_host_addr (void) const
.PP
Return the "dotted decimal" external address.
.PP
.SS const char * ACE_MEM_Addr::get_host_name (void) const
.PP
Return the character representation of the hostname (this version is non-reentrant since it returns a pointer to a static data area). 
.SS int ACE_MEM_Addr::get_host_name (\fBACE_TCHAR\fR hostname[], size_t hostnamelen) const
.PP
Return the character representation of the hostname.
.PP
.SS ACE_UINT32 ACE_MEM_Addr::get_ip_address (void) const
.PP
Return the 4-byte external IP address, converting it into host byte order.
.PP
.SS const \fBACE_INET_Addr\fR& ACE_MEM_Addr::get_local_addr (void) const
.PP
.SS u_short ACE_MEM_Addr::get_port_number (void) const
.PP
Return the port number, converting it into host byte order.
.PP
.SS const \fBACE_INET_Addr\fR& ACE_MEM_Addr::get_remote_addr (void) const
.PP
.SS u_long ACE_MEM_Addr::hash (void) const\fC [virtual]\fR
.PP
Computes and returns hash value.
.PP
Reimplemented from \fBACE_Addr\fR.
.SS int ACE_MEM_Addr::initialize_local (u_short port)
.PP
default initialization routine.
.PP
.SS int ACE_MEM_Addr::operator!= (const \fBACE_INET_Addr\fR & SAP) const
.PP
.SS int ACE_MEM_Addr::operator!= (const ACE_MEM_Addr & SAP) const
.PP
Compare two addresses for inequality.
.PP
.SS int ACE_MEM_Addr::operator== (const \fBACE_INET_Addr\fR & SAP) const
.PP
.SS int ACE_MEM_Addr::operator== (const ACE_MEM_Addr & SAP) const
.PP
Compare two addresses for equality. The addresses are considered equal if they contain the same IP address and port number.
.PP
.SS int ACE_MEM_Addr::same_host (const \fBACE_INET_Addr\fR & sap)
.PP
Check if <sap> designate an enpoint withing the same host.
.PP
.SS int ACE_MEM_Addr::set (const \fBACE_TCHAR\fR port_name[])
.PP
Uses <getservbyname> to initialize an  from a <port_name>, the remote <host_name>, and the <protocol>.
.PP
.SS int ACE_MEM_Addr::set (u_short port_number, int encode = 1)
.PP
Initializes an  from a <port_number> and the remote <host_name>. If <encode> is enabled then <port_number> is converted into network byte order, otherwise it is assumed to be in network byte order already and are passed straight through. 
.SS void ACE_MEM_Addr::set_addr (void * addr, int len)\fC [virtual]\fR
.PP
Set a pointer to the address.
.PP
Reimplemented from \fBACE_Addr\fR.
.SS void ACE_MEM_Addr::set_port_number (u_short, int encode = 1)
.PP
Sets the port number.
.PP
.SS int ACE_MEM_Addr::string_to_addr (const \fBACE_TCHAR\fR address[])\fC [virtual]\fR
.PP
Initializes the external  from the .
.PP
.SH MEMBER DATA DOCUMENTATION
.PP 
.SS ACE_MEM_Addr::ACE_ALLOC_HOOK_DECLARE
.PP
Declare the dynamic allocation hooks.
.PP
Reimplemented from \fBACE_Addr\fR.
.SS \fBACE_INET_Addr\fR ACE_MEM_Addr::external_\fC [private]\fR
.PP
External INET addr used for identifying host.
.PP
.SS \fBACE_INET_Addr\fR ACE_MEM_Addr::internal_\fC [private]\fR
.PP
Internal INET addr for accepting/connecting.
.PP


.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.