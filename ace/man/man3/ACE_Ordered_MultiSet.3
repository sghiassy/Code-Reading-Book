.TH ACE_Ordered_MultiSet 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_Ordered_MultiSet \- Implement a simple ordered multiset of <T> of unbounded size that allows duplicates. This class template requires that < operator semantics be defined for the parameterized type <T>, but does not impose any restriction on how that ordering operator is implemented. 
.SH SYNOPSIS
.br
.PP
\fC#include <Containers_T.h>\fR
.PP
.SS Public Types

.in +1c
.ti -1c
.RI "typedef \fBACE_Ordered_MultiSet_Iterator\fR<T> \fBITERATOR\fR"
.br
.in -1c
.SS Public Methods

.in +1c
.ti -1c
.RI "\fBACE_Ordered_MultiSet\fR (\fBACE_Allocator\fR *alloc = 0)"
.br
.RI "\fIConstructor. Use user specified allocation strategy if specified.\fR"
.ti -1c
.RI "\fBACE_Ordered_MultiSet\fR (const ACE_Ordered_MultiSet<T> &)"
.br
.RI "\fICopy constructor.\fR"
.ti -1c
.RI "\fB~ACE_Ordered_MultiSet\fR (void)"
.br
.RI "\fIDestructor.\fR"
.ti -1c
.RI "void \fBoperator=\fR (const ACE_Ordered_MultiSet<T> &)"
.br
.RI "\fIAssignment operator.\fR"
.ti -1c
.RI "int \fBis_empty\fR (void) const"
.br
.RI "\fIReturns 1 if the container is empty, otherwise returns 0.\fR"
.ti -1c
.RI "size_t \fBsize\fR (void) const"
.br
.RI "\fISize of the set.\fR"
.ti -1c
.RI "int \fBinsert\fR (const T &new_item)"
.br
.RI "\fIInsert <new_item> into the ordered multiset. Returns -1 if failures occur, else 0.\fR"
.ti -1c
.RI "int \fBinsert\fR (const T &new_item, \fBITERATOR\fR &iter)"
.br
.ti -1c
.RI "int \fBremove\fR (const T &item)"
.br
.RI "\fIRemove first occurrence of <item> from the set. Returns 0 if it removes the item, -1 if it can't find the item.\fR"
.ti -1c
.RI "int \fBfind\fR (const T &item, \fBITERATOR\fR &iter) const"
.br
.ti -1c
.RI "void \fBreset\fR (void)"
.br
.RI "\fIReset the  to be empty.\fR"
.ti -1c
.RI "void \fBdump\fR (void) const"
.br
.RI "\fIDump the state of an object.\fR"
.in -1c
.SS Public Attributes

.in +1c
.ti -1c
.RI "\fBACE_ALLOC_HOOK_DECLARE\fR"
.br
.RI "\fIDeclare the dynamic allocation hooks.\fR"
.in -1c
.SS Private Methods

.in +1c
.ti -1c
.RI "int \fBinsert_from\fR (const T &item, \fBACE_DNode\fR<T> *start_position, \fBACE_DNode\fR<T> **new_position)"
.br
.ti -1c
.RI "int \fBlocate\fR (const T &item, \fBACE_DNode\fR<T> *start_position, \fBACE_DNode\fR<T> *&new_position) const"
.br
.ti -1c
.RI "void \fBdelete_nodes\fR (void)"
.br
.RI "\fIDelete all the nodes in the Set.\fR"
.ti -1c
.RI "void \fBcopy_nodes\fR (const ACE_Ordered_MultiSet<T> &)"
.br
.RI "\fICopy nodes into this set.\fR"
.in -1c
.SS Private Attributes

.in +1c
.ti -1c
.RI "\fBACE_DNode\fR<T>* \fBhead_\fR"
.br
.RI "\fIHead of the bilinked list of Nodes.\fR"
.ti -1c
.RI "\fBACE_DNode\fR<T>* \fBtail_\fR"
.br
.RI "\fIHead of the bilinked list of Nodes.\fR"
.ti -1c
.RI "size_t \fBcur_size_\fR"
.br
.RI "\fICurrent size of the set.\fR"
.ti -1c
.RI "\fBACE_Allocator\fR* \fBallocator_\fR"
.br
.RI "\fIAllocation strategy of the set.\fR"
.in -1c
.SS Friends

.in +1c
.ti -1c
.RI "class \fBACE_Ordered_MultiSet_Iterator< T >\fR"
.br
.in -1c
.SH DETAILED DESCRIPTION
.PP 

.SS template<class T>  template class ACE_Ordered_MultiSet
Implement a simple ordered multiset of <T> of unbounded size that allows duplicates. This class template requires that < operator semantics be defined for the parameterized type <T>, but does not impose any restriction on how that ordering operator is implemented.
.PP
.SH MEMBER TYPEDEF DOCUMENTATION
.PP 
.SS template<classT> typedef \fBACE_Ordered_MultiSet_Iterator\fR<T> ACE_Ordered_MultiSet<T>::ITERATOR
.PP
.SH CONSTRUCTOR & DESTRUCTOR DOCUMENTATION
.PP 
.SS template<classT> ACE_Ordered_MultiSet<T>::ACE_Ordered_MultiSet<T> (\fBACE_Allocator\fR * alloc = 0)
.PP
Constructor. Use user specified allocation strategy if specified.
.PP
.SS template<classT> ACE_Ordered_MultiSet<T>::ACE_Ordered_MultiSet<T> (const ACE_Ordered_MultiSet< T >&)
.PP
Copy constructor.
.PP
.SS template<classT> ACE_Ordered_MultiSet<T>::~ACE_Ordered_MultiSet<T> (void)
.PP
Destructor.
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS template<classT> void ACE_Ordered_MultiSet<T>::copy_nodes (const ACE_Ordered_MultiSet< T >&)\fC [private]\fR
.PP
Copy nodes into this set.
.PP
.SS template<classT> void ACE_Ordered_MultiSet<T>::delete_nodes (void)\fC [private]\fR
.PP
Delete all the nodes in the Set.
.PP
.SS template<classT> void ACE_Ordered_MultiSet<T>::dump (void) const
.PP
Dump the state of an object.
.PP
.SS template<classT> int ACE_Ordered_MultiSet<T>::find (const T & item, \fBITERATOR\fR & iter) const
.PP
Finds first occurrance of <item> in the multiset, using the iterator's current position as a hint to improve performance. If find succeeds, it positions the iterator at that node and returns 0, or if it cannot locate the node, it leaves the iterator alone and just returns -1. 
.SS template<classT> int ACE_Ordered_MultiSet<T>::insert (const T & new_item, \fBITERATOR\fR & iter)
.PP
Insert <new_item> into the ordered multiset, starting its search at the node pointed to by the iterator, and if insertion was successful, updates the iterator to point to the newly inserted node. Returns -1 if failures occur, else 0. 
.SS template<classT> int ACE_Ordered_MultiSet<T>::insert (const T & new_item)
.PP
Insert <new_item> into the ordered multiset. Returns -1 if failures occur, else 0.
.PP
.SS template<classT> int ACE_Ordered_MultiSet<T>::insert_from (const T & item, \fBACE_DNode\fR< T >* start_position, \fBACE_DNode\fR< T >** new_position)\fC [private]\fR
.PP
Insert <item>, starting its search at the position given, and if successful updates the passed pointer to point to the newly inserted item's node. 
.SS template<classT> int ACE_Ordered_MultiSet<T>::is_empty (void) const
.PP
Returns 1 if the container is empty, otherwise returns 0.
.PP
.SS template<classT> int ACE_Ordered_MultiSet<T>::locate (const T & item, \fBACE_DNode\fR< T >* start_position, \fBACE_DNode\fR< T >*& new_position) const\fC [private]\fR
.PP
looks for first occurance of <item> in the ordered set, using the passed starting position as a hint: if there is such an instance, it updates the new_position pointer to point to this node and returns 0; if there is no such node, then if there is a node before where the item would have been, it updates the new_position pointer to point to this node and returns -1; if there is no such node, then if there is a node after where the item would have been, it updates the new_position pointer to point to this node (or 0 if there is no such node) and returns 1; 
.SS template<classT> void ACE_Ordered_MultiSet<T>::operator= (const ACE_Ordered_MultiSet< T >&)
.PP
Assignment operator.
.PP
.SS template<classT> int ACE_Ordered_MultiSet<T>::remove (const T & item)
.PP
Remove first occurrence of <item> from the set. Returns 0 if it removes the item, -1 if it can't find the item.
.PP
.SS template<classT> void ACE_Ordered_MultiSet<T>::reset (void)
.PP
Reset the  to be empty.
.PP
.SS template<classT> size_t ACE_Ordered_MultiSet<T>::size (void) const
.PP
Size of the set.
.PP
.SH FRIENDS AND RELATED FUNCTION DOCUMENTATION
.PP 
.SS template<classT> class \fBACE_Ordered_MultiSet_Iterator\fR\fC [friend]\fR
.PP
.SH MEMBER DATA DOCUMENTATION
.PP 
.SS template<classT> ACE_Ordered_MultiSet<T>::ACE_ALLOC_HOOK_DECLARE
.PP
Declare the dynamic allocation hooks.
.PP
.SS template<classT> \fBACE_Allocator\fR * ACE_Ordered_MultiSet<T>::allocator_\fC [private]\fR
.PP
Allocation strategy of the set.
.PP
.SS template<classT> size_t ACE_Ordered_MultiSet<T>::cur_size_\fC [private]\fR
.PP
Current size of the set.
.PP
.SS template<classT> \fBACE_DNode\fR< T >* ACE_Ordered_MultiSet<T>::head_\fC [private]\fR
.PP
Head of the bilinked list of Nodes.
.PP
.SS template<classT> \fBACE_DNode\fR< T >* ACE_Ordered_MultiSet<T>::tail_\fC [private]\fR
.PP
Head of the bilinked list of Nodes.
.PP


.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.