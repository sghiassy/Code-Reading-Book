.TH ACE_Future_Set 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_Future_Set \- This class implements a mechanism which allows the values of a collections of  objects to be accessed by reader threads as they become available. 
.SH SYNOPSIS
.br
.PP
\fC#include <Future_Set.h>\fR
.PP
Inherits \fBACE_Future_Observer< T >\fR.
.PP
.SS Public Methods

.in +1c
.ti -1c
.RI "\fBACE_Future_Set\fR (\fBACE_Message_Queue\fR<ACE_SYNCH> *\fBfuture_notification_queue_\fR = 0)"
.br
.RI "\fIConstructor.\fR"
.ti -1c
.RI "\fB~ACE_Future_Set\fR (void)"
.br
.RI "\fIDestructor.\fR"
.ti -1c
.RI "int \fBis_empty\fR (void) const"
.br
.RI "\fIReturn 1 if their are no  objects left on its queue and 0 otherwise.\fR"
.ti -1c
.RI "int \fBinsert\fR (\fBACE_Future\fR<T> &future)"
.br
.ti -1c
.RI "int \fBnext_readable\fR (\fBACE_Future\fR<T> &result, \fBACE_Time_Value\fR *tv = 0)"
.br
.ti -1c
.RI "virtual void \fBupdate\fR (const \fBACE_Future\fR<T> &future)"
.br
.RI "\fICalled by the  subject in which we are subscribed to when its value is written to.\fR"
.in -1c
.SS Public Attributes

.in +1c
.ti -1c
.RI "\fBACE_ALLOC_HOOK_DECLARE\fR"
.br
.RI "\fIDeclare the dynamic allocation hooks.\fR"
.in -1c
.SS Private Types

.in +1c
.ti -1c
.RI "typedef \fBACE_Future\fR<T> \fBFUTURE\fR"
.br
.ti -1c
.RI "typedef \fBACE_Future_Rep\fR<T> \fBFUTURE_REP\fR"
.br
.ti -1c
.RI "typedef \fBACE_Future_Holder\fR<T> \fBFUTURE_HOLDER\fR"
.br
.ti -1c
.RI "typedef \fBACE_Pointer_Hash\fR<\fBFUTURE_REP\fR *> \fBFUTURE_REP_HASH\fR"
.br
.ti -1c
.RI "typedef \fBACE_Equal_To\fR<\fBFUTURE_REP\fR *> \fBFUTURE_REP_COMPARE\fR"
.br
.ti -1c
.RI "typedef \fBACE_Hash_Map_Manager_Ex\fR<\fBFUTURE_REP\fR *, \fBFUTURE_HOLDER\fR *, \fBFUTURE_REP_HASH\fR, \fBFUTURE_REP_COMPARE\fR, \fBACE_Null_Mutex\fR> \fBFUTURE_HASH_MAP\fR"
.br
.in -1c
.SS Private Methods

.in +1c
.ti -1c
.RI "void \fBoperator=\fR (const ACE_Future_Set<T> &)"
.br
.ti -1c
.RI "\fBACE_Future_Set\fR (const ACE_Future_Set<T> &)"
.br
.in -1c
.SS Private Attributes

.in +1c
.ti -1c
.RI "\fBFUTURE_HASH_MAP\fR \fBfuture_map_\fR"
.br
.RI "\fIMap of , subjects, which have not been written to by client's writer thread.\fR"
.ti -1c
.RI "\fBACE_Message_Queue\fR<ACE_SYNCH>* \fBfuture_notification_queue_\fR"
.br
.RI "\fIMessage queue for notifying the reader thread of  which have been written to by client's writer thread.\fR"
.ti -1c
.RI "int \fBdelete_queue_\fR"
.br
.RI "\fIKeeps track of whether we need to delete the message queue.\fR"
.in -1c
.SH DETAILED DESCRIPTION
.PP 

.SS template<class T>  template class ACE_Future_Set
This class implements a mechanism which allows the values of a collections of  objects to be accessed by reader threads as they become available.
.PP
.SH MEMBER TYPEDEF DOCUMENTATION
.PP 
.SS template<classT> typedef \fBACE_Future\fR<T> ACE_Future_Set<T>::FUTURE\fC [private]\fR
.PP
.SS template<classT> typedef \fBACE_Hash_Map_Manager_Ex\fR<\fBFUTURE_REP\fR *, \fBFUTURE_HOLDER\fR *, \fBFUTURE_REP_HASH\fR, \fBFUTURE_REP_COMPARE\fR, \fBACE_Null_Mutex\fR> ACE_Future_Set<T>::FUTURE_HASH_MAP\fC [private]\fR
.PP
.SS template<classT> typedef \fBACE_Future_Holder\fR<T> ACE_Future_Set<T>::FUTURE_HOLDER\fC [private]\fR
.PP
.SS template<classT> typedef \fBACE_Future_Rep\fR<T> ACE_Future_Set<T>::FUTURE_REP\fC [private]\fR
.PP
.SS template<classT> typedef \fBACE_Equal_To\fR<\fBFUTURE_REP\fR *> ACE_Future_Set<T>::FUTURE_REP_COMPARE\fC [private]\fR
.PP
.SS template<classT> typedef \fBACE_Pointer_Hash\fR<\fBFUTURE_REP\fR *> ACE_Future_Set<T>::FUTURE_REP_HASH\fC [private]\fR
.PP
.SH CONSTRUCTOR & DESTRUCTOR DOCUMENTATION
.PP 
.SS template<classT> ACE_Future_Set<T>::ACE_Future_Set<T> (\fBACE_Message_Queue\fR< ACE_SYNCH >* future_notification_queue_ = 0)
.PP
Constructor.
.PP
.SS template<classT> ACE_Future_Set<T>::~ACE_Future_Set<T> (void)
.PP
Destructor.
.PP
.SS template<classT> ACE_Future_Set<T>::ACE_Future_Set<T> (const ACE_Future_Set< T >&)\fC [private]\fR
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS template<classT> int ACE_Future_Set<T>::insert (\fBACE_Future\fR< T >& future)
.PP
Enqueus the given  into this objects queue when it is readable.
.PP
Returns 0 if the future is successfully inserted, 1 if the future is already inserted, and -1 if failures occur. 
.SS template<classT> int ACE_Future_Set<T>::is_empty (void) const
.PP
Return 1 if their are no  objects left on its queue and 0 otherwise.
.PP
.SS template<classT> int ACE_Future_Set<T>::next_readable (\fBACE_Future\fR< T >& result, \fBACE_Time_Value\fR * tv = 0)
.PP
Wait up to <tv> time to get the <value>. Note that <tv> must be specified in absolute time rather than relative time.); get the next  that is readable. If <tv> = 0, the will block forever.
.PP
If a readable future becomes available, then the input result will be assigned with it and 1 will will be returned. If the set is empty, then 0 is returned. 
.SS template<classT> void ACE_Future_Set<T>::operator= (const ACE_Future_Set< T >&)\fC [private]\fR
.PP
.SS template<classT> void ACE_Future_Set<T>::update (const \fBACE_Future\fR< T >& future)\fC [virtual]\fR
.PP
Called by the  subject in which we are subscribed to when its value is written to.
.PP
Reimplemented from \fBACE_Future_Observer\fR.
.SH MEMBER DATA DOCUMENTATION
.PP 
.SS template<classT> ACE_Future_Set<T>::ACE_ALLOC_HOOK_DECLARE
.PP
Declare the dynamic allocation hooks.
.PP
Reimplemented from \fBACE_Future_Observer\fR.
.SS template<classT> int ACE_Future_Set<T>::delete_queue_\fC [private]\fR
.PP
Keeps track of whether we need to delete the message queue.
.PP
.SS template<classT> \fBFUTURE_HASH_MAP\fR ACE_Future_Set<T>::future_map_\fC [private]\fR
.PP
Map of , subjects, which have not been written to by client's writer thread.
.PP
.SS template<classT> \fBACE_Message_Queue\fR< ACE_SYNCH >* ACE_Future_Set<T>::future_notification_queue_\fC [private]\fR
.PP
Message queue for notifying the reader thread of  which have been written to by client's writer thread.
.PP


.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.